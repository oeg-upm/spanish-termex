{
    "id": "J-57",
    "original_text": "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents. This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner. We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation. The Shapley value can be computed in time linear in the size of the input. The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation. Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1. INTRODUCTION Agents can often benefit by coordinating their actions. Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives. As an abstraction, coalitional games assign a payoff to each group of agents in the game. This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group. These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce. In [7], Kleinberg et al. use coalitional games to study recommendation systems. In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them. The payoffs to groups of agents are the total number of distinct items known by its members. Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2). These values can then be used to determine how much each agent should receive for participating in the system. As another example, consider the economics behind supply chain formation. The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem. Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases. The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers. Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives. The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers. A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games. The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game. For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems. Therefore, it is critical to find good representation schemes for coalitional games. We believe that the quality of a representation scheme should be evaluated by four criteria. Expressivity: the breadth of the class of coalitional games covered by the representation. Conciseness: the space requirement of the representation. Efficiency: the efficiency of the algorithms we can develop for the representation. Simplicity: the ease of use of the representation by users of the system. The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use. The goal of this paper is to develop a representation scheme that has properties close to the ideal representation. Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints. For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme. For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately. For some problems, however, there may not be efficient algorithms for customized representations. By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4]. In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs. While the representation is compact, it is not fully expressive. In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games. They developed a compact representation scheme for such games, but again the representation is not fully expressive either. In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition. Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents. We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents. We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2. PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail. Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members. This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff. This representation is known as the characteristic form. As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game. An outcome in a coalitional game specifies the utilities the agents receive. A solution concept assigns to each coalitional game a set of reasonable outcomes. Different solution concepts attempt to capture in some way outcomes that are stable and/or fair. Two of the best known solution concepts are the Shapley value and the core. The Shapley value is a normative solution concept. It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed. The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents. Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s!(n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature. It has a very useful axiomatic characterization. Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N). Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}). Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4. The core is another major solution concept for coalitional games. It is a descriptive solution concept that focuses on outcomes that are stable. Stability under core means that no set of players can jointly deviate to improve their payoffs. Formally, let x(S) denote i∈S xi. An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail. An important question for a given coalitional game is whether the core is empty. In other words, whether there is any outcome that is stable relative to group deviation. For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows. Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1. This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced. Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty. Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice. In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4]. In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them. Notice that this representation is concise since the space required to specify such a game is O(n2 ). However, this representation is not general; it will not be able to represent interactions among three or more agents. For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2. On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights. However, in the unrestricted case, determining whether the core is non-empty is coNP-complete. Conitzer and Sandholm in [2] considered coalitional games that are superadditive. They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive. More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}). While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent. For example, it will not be able to represent any games with substitutability among the agents. An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅. Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete. In fact, even determining the value of a group of agents is NP-complete. In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3]. The payoffs in these subgames are then represented by their respective characteristic functions. This scheme is fully general as the characteristic form is a special case of this representation. For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity. For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ). On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3. MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme. We will show that the idea is flexible, and we can easily extend it to increase its conciseness. We will also show how we can use this scheme to represent the recommendation game from the introduction. Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules. The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern. In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it. The value of a group of agents is defined to be the sum over the values of all rules that apply to the group. For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7. MC-nets is a very flexible representation scheme, and can be extended in different ways. One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules. A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents. This is useful for expressing concepts such as substitutability or default values. Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals. Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals. To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2. To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle. On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc. The representational savings can be exponential in the number of agents. Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph. We call this graph the agent graph. The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents. Notice that to accommodate negative literals, we will need to annotate the clique appropriately. This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5. We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them. To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values. There is no overhead on top of that since there is a natural ordering of the groups. For MC-nets, however, specification of the rules requires specifying both the patterns and the values. The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify. The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them. However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction. For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents. This can be captured by a scaled unit game. Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product. The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection. Proposition 1. Marginal contribution networks constitute a fully expressive representation scheme. Proof. Consider an arbitrary coalitional game N, v in characteristic form representation. We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules. For any singleton set {i}, we create a rule {i} → v(i). For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}. We can continue to build up rules in a manner similar to the inclusion-exclusion principle. Since the game is arbitrary, MC-nets are fully expressive. Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space. Proposition 2. Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game. Proof. Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames. Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule. On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation. On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme. Proposition 3. Marginal contribution networks are exponentially more concise than multi-issue representation for certain games. Proof. Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals. However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation. Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs. Proposition 4. Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space. Proof. Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij. Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4. COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game. Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule. For each agent, we then sum up the Shapley values of that agent over all the rules. We first show that this final summing process correctly computes the Shapley value of the agents. Proposition 5. The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule. Proof. For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules. The remaining question is how to compute the Shapley values of the rules. We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals. For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule. This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other. For rules that have both positive and negative literals, we can consider the positive and the negative literals separately. For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals. Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals. Therefore, φj = p!(n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj. Note that the sum over all agents in rules with mixed literals is 0. This is to be expected as these rules contribute 0 to the grand coalition. The fact that these rules have no effect on the grand coalition may appear odd at first. But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition. In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5. ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core. We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core. Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty. In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems. We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership. Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth. We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6. Core-Membership for games represented as marginal contribution networks is coNP-complete. Proof. Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core. As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4. Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard. Proposition 7. Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard. Proof. The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness. We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now. Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size. In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph. In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty. On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative. To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques. For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph. Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core. By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3. A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj. The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one. The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph. Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4. A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1. Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V . Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj. Join nodes i have two children j and k with Xi = Xj = Xk. An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1. In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x. By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S). Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition. We call this difference the excess of group S. Definition 5. The excess of a coalition S, e(S), is defined as x(S) − v(S). A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative. However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph. Tree decomposition is the key to take advantage of such inferences in a structured way. For now, let us focus on rules with positive literals. Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess. A na¨ıve solution will be to compute the excesses of all sets that include i. The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut. However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U. Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}). This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U. However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess. In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group. Definition 6. The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U. We denote this value by r(S, U). We will refer to the group T that has the minimum excess as arg r(S, U). We will also call U the limiting set of the reserve and S the base set of the reserve. Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition. Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S). The agents in (Xi\\S) are excluded to ensure that S is an entry set. Specifically, S is the entry set to ((Ti \\ Xi) ∪ S). To accomodate for negative literals, we will need to make two adjustments. Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly. Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group. As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1. At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S). We sometimes refer to these values as the r-values of a node. The details of the r-value computations are in Algorithm 1. To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative. If this is so for all nodes in the tree, the payoff vector x is in the core. The correctness of the algorithm is due to the following proposition. Proposition 8. The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative. Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0. Let Xroot be the set of nodes at the root. Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S). The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅. Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative. If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint. Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well. Therefore, we only need to check the r-values of the nodes on the individual trees in the forest. But for each tree in the forest, we can apply the same argument restricted to the agents in the tree. In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i. If R∗ = {i}, then r({i}) = e({i}) < 0. Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative. We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes. A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2. Proposition 9. The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes. Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition. Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi. Forget nodes (i with child j) Let m be the forgotten node. For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j. Introduce nodes (i with child j) Let m be the introduced node. For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}). By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi. As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j. Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern. Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut). Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property. Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right. The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted. We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S). Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness. As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3). Unfortunately, that program has an exponential number of variables. On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2. Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty. We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated. Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated. Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph. Note that when the core is not empty, this program will return an outcome in the core. 6. CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents. Our focus on general representation is in contrast to the approach taken in [3, 4]. We have also developed an efficient algorithm for the computation of the Shapley values for this representation. While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph. We have also extended the algorithm to solve Core-Non-Emptiness. Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature. The work in this paper is related to a number of areas in computer science, especially in artificial intelligence. For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community. They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs. In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6]. The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10]. The OR-bid language, for example, is strongly related to superadditivity. The question of the representation power of different patterns is also related to Boolean expression complexity [12]. We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games. Finally, we would like to end with some ideas for extending the work in this paper. One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models. The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely. This will also address the problem of unpleasing assymetric representations of symmetric games in our representation. Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions. More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class. The use of functions will allow concise description of marginal diminishing returns (MDRs). Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n). With the use of functions, the space required can be reduced to O(1). Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously. This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously. For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time. Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules. The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7. ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8. REFERENCES [1] H. L. Bodlaender. Treewidth: Algorithmic techniques and results. In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36. Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm. Complexity of determining nonemptiness of the core. In Proc. 18th Int. Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm. Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains. In Proc. 19th Nat. Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou. On the complexity of cooperative solution concepts. Math. Oper. Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham. Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches. In Proc. 16th Int. Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh. Graphical models for game theory. In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan. On the value of private information. In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara. Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace. Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green. Microeconomic Theory. Oxford University Press, New York, 1995. [10] N. Nisan. Bidding and allocation in combinatorial auctions. In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein. A Course in Game Theory. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. The Complexity of Boolean Functions. John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes. Lemma 1. The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct. Proof. Let node m be the newly introduced agent at i. Let U denote the set of agents in the subtree rooted at i. By the running intersection property, all interactions (the hyperedges) between m and U must be in node i. For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2. The procedure for computing the r-values of join nodes in Algorithm 1 is correct. Proof. Consider any set S ⊆ Xi. Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj). Let Uk, Rk, and Qk be defined analogously for the right child. Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202",
    "original_translation": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202",
    "original_sentences": [
        "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
        "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
        "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
        "The Shapley value can be computed in time linear in the size of the input.",
        "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
        "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
        "INTRODUCTION Agents can often benefit by coordinating their actions.",
        "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
        "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
        "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
        "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
        "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
        "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
        "The payoffs to groups of agents are the total number of distinct items known by its members.",
        "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
        "These values can then be used to determine how much each agent should receive for participating in the system.",
        "As another example, consider the economics behind supply chain formation.",
        "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
        "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
        "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
        "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
        "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
        "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
        "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
        "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
        "Therefore, it is critical to find good representation schemes for coalitional games.",
        "We believe that the quality of a representation scheme should be evaluated by four criteria.",
        "Expressivity: the breadth of the class of coalitional games covered by the representation.",
        "Conciseness: the space requirement of the representation.",
        "Efficiency: the efficiency of the algorithms we can develop for the representation.",
        "Simplicity: the ease of use of the representation by users of the system.",
        "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
        "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
        "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
        "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
        "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
        "For some problems, however, there may not be efficient algorithms for customized representations.",
        "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
        "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
        "While the representation is compact, it is not fully expressive.",
        "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
        "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
        "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
        "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
        "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
        "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
        "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
        "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
        "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
        "This representation is known as the characteristic form.",
        "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
        "An outcome in a coalitional game specifies the utilities the agents receive.",
        "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
        "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
        "Two of the best known solution concepts are the Shapley value and the core.",
        "The Shapley value is a normative solution concept.",
        "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
        "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
        "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
        "It has a very useful axiomatic characterization.",
        "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
        "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
        "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
        "The core is another major solution concept for coalitional games.",
        "It is a descriptive solution concept that focuses on outcomes that are stable.",
        "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
        "Formally, let x(S) denote i∈S xi.",
        "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
        "An important question for a given coalitional game is whether the core is empty.",
        "In other words, whether there is any outcome that is stable relative to group deviation.",
        "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
        "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
        "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
        "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
        "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
        "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
        "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
        "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
        "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
        "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
        "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
        "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
        "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
        "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
        "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
        "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
        "For example, it will not be able to represent any games with substitutability among the agents.",
        "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
        "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
        "In fact, even determining the value of a group of agents is NP-complete.",
        "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
        "The payoffs in these subgames are then represented by their respective characteristic functions.",
        "This scheme is fully general as the characteristic form is a special case of this representation.",
        "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
        "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
        "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
        "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
        "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
        "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
        "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
        "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
        "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
        "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
        "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
        "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
        "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
        "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
        "This is useful for expressing concepts such as substitutability or default values.",
        "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
        "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
        "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
        "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
        "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
        "The representational savings can be exponential in the number of agents.",
        "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
        "We call this graph the agent graph.",
        "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
        "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
        "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
        "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
        "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
        "There is no overhead on top of that since there is a natural ordering of the groups.",
        "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
        "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
        "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
        "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
        "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
        "This can be captured by a scaled unit game.",
        "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
        "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
        "Proposition 1.",
        "Marginal contribution networks constitute a fully expressive representation scheme.",
        "Proof.",
        "Consider an arbitrary coalitional game N, v in characteristic form representation.",
        "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
        "For any singleton set {i}, we create a rule {i} → v(i).",
        "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
        "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
        "Since the game is arbitrary, MC-nets are fully expressive.",
        "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
        "Proposition 2.",
        "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
        "Proof.",
        "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
        "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
        "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
        "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
        "Proposition 3.",
        "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
        "Proof.",
        "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
        "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
        "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
        "Proposition 4.",
        "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
        "Proof.",
        "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
        "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
        "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
        "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
        "For each agent, we then sum up the Shapley values of that agent over all the rules.",
        "We first show that this final summing process correctly computes the Shapley value of the agents.",
        "Proposition 5.",
        "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
        "Proof.",
        "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
        "The remaining question is how to compute the Shapley values of the rules.",
        "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
        "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
        "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
        "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
        "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
        "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
        "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
        "Note that the sum over all agents in rules with mixed literals is 0.",
        "This is to be expected as these rules contribute 0 to the grand coalition.",
        "The fact that these rules have no effect on the grand coalition may appear odd at first.",
        "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
        "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
        "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
        "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
        "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
        "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
        "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
        "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
        "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
        "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
        "Proof.",
        "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
        "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
        "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
        "Proposition 7.",
        "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
        "Proof.",
        "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
        "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
        "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
        "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
        "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
        "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
        "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
        "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
        "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
        "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
        "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
        "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
        "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
        "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
        "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
        "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
        "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
        "Join nodes i have two children j and k with Xi = Xj = Xk.",
        "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
        "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
        "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
        "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
        "We call this difference the excess of group S. Definition 5.",
        "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
        "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
        "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
        "Tree decomposition is the key to take advantage of such inferences in a structured way.",
        "For now, let us focus on rules with positive literals.",
        "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
        "A na¨ıve solution will be to compute the excesses of all sets that include i.",
        "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
        "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
        "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
        "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
        "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
        "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
        "Definition 6.",
        "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
        "We denote this value by r(S, U).",
        "We will refer to the group T that has the minimum excess as arg r(S, U).",
        "We will also call U the limiting set of the reserve and S the base set of the reserve.",
        "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
        "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
        "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
        "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
        "To accomodate for negative literals, we will need to make two adjustments.",
        "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
        "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
        "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
        "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
        "We sometimes refer to these values as the r-values of a node.",
        "The details of the r-value computations are in Algorithm 1.",
        "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
        "If this is so for all nodes in the tree, the payoff vector x is in the core.",
        "The correctness of the algorithm is due to the following proposition.",
        "Proposition 8.",
        "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
        "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
        "Let Xroot be the set of nodes at the root.",
        "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
        "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
        "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
        "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
        "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
        "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
        "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
        "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
        "If R∗ = {i}, then r({i}) = e({i}) < 0.",
        "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
        "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
        "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
        "Proposition 9.",
        "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
        "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
        "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
        "Forget nodes (i with child j) Let m be the forgotten node.",
        "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
        "Introduce nodes (i with child j) Let m be the introduced node.",
        "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
        "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
        "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
        "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
        "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
        "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
        "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
        "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
        "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
        "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
        "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
        "Unfortunately, that program has an exponential number of variables.",
        "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
        "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
        "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
        "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
        "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
        "Note that when the core is not empty, this program will return an outcome in the core. 6.",
        "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
        "Our focus on general representation is in contrast to the approach taken in [3, 4].",
        "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
        "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
        "We have also extended the algorithm to solve Core-Non-Emptiness.",
        "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
        "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
        "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
        "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
        "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
        "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
        "The OR-bid language, for example, is strongly related to superadditivity.",
        "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
        "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
        "Finally, we would like to end with some ideas for extending the work in this paper.",
        "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
        "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
        "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
        "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
        "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
        "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
        "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
        "With the use of functions, the space required can be reduced to O(1).",
        "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
        "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
        "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
        "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
        "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
        "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
        "REFERENCES [1] H. L. Bodlaender.",
        "Treewidth: Algorithmic techniques and results.",
        "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
        "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
        "Complexity of determining nonemptiness of the core.",
        "In Proc. 18th Int.",
        "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
        "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
        "In Proc. 19th Nat.",
        "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
        "On the complexity of cooperative solution concepts.",
        "Math.",
        "Oper.",
        "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
        "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
        "In Proc. 16th Int.",
        "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
        "Graphical models for game theory.",
        "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
        "On the value of private information.",
        "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
        "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
        "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
        "Microeconomic Theory.",
        "Oxford University Press, New York, 1995. [10] N. Nisan.",
        "Bidding and allocation in combinatorial auctions.",
        "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
        "A Course in Game Theory.",
        "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
        "The Complexity of Boolean Functions.",
        "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
        "Lemma 1.",
        "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
        "Proof.",
        "Let node m be the newly introduced agent at i.",
        "Let U denote the set of agents in the subtree rooted at i.",
        "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
        "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
        "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
        "Proof.",
        "Consider any set S ⊆ Xi.",
        "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
        "Let Uk, Rk, and Qk be defined analogously for the right child.",
        "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
    ],
    "translated_text_sentences": [
        "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes.",
        "Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa.",
        "También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación.",
        "El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada.",
        "La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación.",
        "Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía.",
        "INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones.",
        "Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas.",
        "Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego.",
        "Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo.",
        "Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico.",
        "En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación.",
        "En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos.",
        "Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros.",
        "Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2).",
        "Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema.",
        "Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro.",
        "El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro.",
        "Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras.",
        "La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores.",
        "Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban.",
        "El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes.",
        "Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos.",
        "La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego.",
        "Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas.",
        "Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales.",
        "Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios.",
        "Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación.",
        "Concisión: el requisito de espacio de la representación.",
        "Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación.",
        "Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema.",
        "La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar.",
        "El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal.",
        "Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información.",
        "Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general.",
        "Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada.",
        "Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas.",
        "Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4].",
        "En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos.",
        "Si bien la representación es compacta, no es completamente expresiva.",
        "En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos.",
        "Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva.",
        "En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición.",
        "Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes.",
        "Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes.",
        "Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo.",
        "PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle.",
        "A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros.",
        "Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real.",
        "Esta representación es conocida como la forma característica.",
        "Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional.",
        "Un resultado en un juego coalicional especifica las utilidades que reciben los agentes.",
        "Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables.",
        "Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos.",
        "Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo.",
        "El valor de Shapley es un concepto de solución normativa.",
        "Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N).",
        "La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes.",
        "Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos.",
        "Tiene una caracterización axiomática muy útil.",
        "Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N).",
        "Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}).",
        "Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4.",
        "El núcleo es otro concepto importante de solución para los juegos coalicionales.",
        "Es un concepto de solución descriptivo que se centra en resultados que son estables.",
        "La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias.",
        "Formalmente, dejemos que x(S) denote i∈S xi.",
        "Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle.",
        "Una pregunta importante para un juego coalicional dado es si el núcleo está vacío.",
        "En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo.",
        "Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera.",
        "Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1.",
        "Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado.",
        "Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío.",
        "Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica.",
        "En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4].",
        "En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos.",
        "Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2).",
        "Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes.",
        "Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2.",
        "Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos.",
        "Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo.",
        "Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos.",
        "Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo.",
        "Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}).",
        "Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar.",
        "Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes.",
        "Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅.",
        "Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo.",
        "De hecho, incluso determinar el valor de un grupo de agentes es NP-completo.",
        "En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3].",
        "Los pagos en estos subjuegos son representados por sus respectivas funciones características.",
        "Este esquema es completamente general ya que la forma característica es un caso especial de esta representación.",
        "Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional.",
        "Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n).",
        "Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo.",
        "CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal.",
        "Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión.",
        "También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción.",
        "Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas.",
        "Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón.",
        "En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él.",
        "El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo.",
        "Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7.",
        "MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas.",
        "Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas.",
        "Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes.",
        "Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados.",
        "Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos.",
        "Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos.",
        "Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2.",
        "Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión.",
        "Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc.",
        "Los ahorros representacionales pueden ser exponenciales en el número de agentes.",
        "Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo.",
        "Llamamos a este gráfico el gráfico de agentes.",
        "Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes.",
        "Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente.",
        "Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5.",
        "Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos.",
        "Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores.",
        "No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos.",
        "Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores.",
        "Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar.",
        "El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos.",
        "Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción.",
        "Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes.",
        "Esto se puede capturar mediante un juego de unidad escalado.",
        "Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto.",
        "El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección.",
        "Proposición 1.",
        "Las redes de contribución marginal constituyen un esquema de representación completamente expresivo.",
        "Prueba.",
        "Considera un juego de coalición arbitrario N, v en representación en forma característica.",
        "Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas.",
        "Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i).",
        "Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}).",
        "Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión.",
        "Dado que el juego es arbitrario, las redes MC son completamente expresivas.",
        "Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio.",
        "Proposición 2.",
        "Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego.",
        "Prueba.",
        "Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos.",
        "Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla.",
        "Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas.",
        "Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema.",
        "Proposición 3.",
        "Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos.",
        "Prueba.",
        "Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos.",
        "Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue.",
        "Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados.",
        "Proposición 4.",
        "Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio.",
        "Prueba.",
        "Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij.",
        "Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4.",
        "CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego.",
        "Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla.",
        "Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas.",
        "Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes.",
        "Proposición 5.",
        "El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla.",
        "Prueba.",
        "Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas.",
        "La pregunta que queda es cómo calcular los valores de Shapley de las reglas.",
        "Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos.",
        "Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla.",
        "Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí.",
        "Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado.",
        "Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos.",
        "Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas.",
        "Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj.",
        "Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0.",
        "Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición.",
        "El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio.",
        "Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición.",
        "En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada.",
        "RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo.",
        "Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo.",
        "Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío.",
        "En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas.",
        "Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central.",
        "A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado.",
        "Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197",
        "La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa.",
        "Prueba.",
        "La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo.",
        "En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4.",
        "Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil.",
        "Proposición 7.",
        "La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil.",
        "Prueba.",
        "El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo.",
        "No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento.",
        "Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial.",
        "En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo.",
        "En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío.",
        "Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa.",
        "Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles.",
        "Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes.",
        "Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo.",
        "Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3.",
        "Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj.",
        "El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno.",
        "El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo.",
        "Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4.",
        "Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1.",
        "Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V.",
        "Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj.",
        "Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk.",
        "Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1.",
        "En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x.",
        "Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S).",
        "Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo.",
        "Llamamos a esta diferencia el exceso del grupo S. Definición 5.",
        "El exceso de una coalición S, e(S), se define como x(S) − v(S).",
        "Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos.",
        "Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo.",
        "La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada.",
        "Por ahora, centrémonos en reglas con literales positivos.",
        "Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo.",
        "Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i.",
        "El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte.",
        "Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U.",
        "Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}).",
        "Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U.",
        "Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo.",
        "En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo.",
        "Definición 6.",
        "La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U.",
        "Denotamos este valor como r(S, U).",
        "Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U).",
        "También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva.",
        "Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol.",
        "Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S).",
        "Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada.",
        "Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S).",
        "Para acomodar los literales negativos, necesitaremos hacer dos ajustes.",
        "En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia.",
        "Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo.",
        "Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1.",
        "En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S).",
        "A veces nos referimos a estos valores como los valores r de un nodo.",
        "Los detalles de los cálculos del valor r están en el Algoritmo 1.",
        "Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos.",
        "Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo.",
        "La corrección del algoritmo se debe a la siguiente proposición.",
        "Proposición 8.",
        "El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos.",
        "Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0.",
        "Sea Xroot el conjunto de nodos en la raíz.",
        "Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S).",
        "La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅.",
        "Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo.",
        "Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos.",
        "Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo.",
        "Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque.",
        "Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol.",
        "En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i.",
        "Si R∗ = {i}, entonces r({i}) = e({i}) < 0.",
        "Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa.",
        "A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol.",
        "Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2.",
        "Proposición 9.",
        "El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol.",
        "Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable.",
        "Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi.",
        "Olvida los nodos (i con hijo j). Sea m el nodo olvidado.",
        "Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j.",
        "Introducir nodos (i con hijo j). Sea m el nodo introducido.",
        "Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}).",
        "Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi.",
        "Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j.",
        "Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón.",
        "Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut).",
        "Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución.",
        "Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha.",
        "La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces.",
        "Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S).",
        "Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo.",
        "Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3).",
        "Desafortunadamente, ese programa tiene un número exponencial de variables.",
        "Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2.",
        "Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío.",
        "Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada.",
        "Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada.",
        "Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo.",
        "Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6.",
        "CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes.",
        "Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4].",
        "También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación.",
        "Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes.",
        "También hemos extendido el algoritmo para resolver la Core-No-Vacuidad.",
        "Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura.",
        "El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial.",
        "Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes.",
        "Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados.",
        "De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6].",
        "Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10].",
        "El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad.",
        "La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12].",
        "Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales.",
        "Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo.",
        "Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos.",
        "El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa.",
        "Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación.",
        "Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales.",
        "Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante.",
        "El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD).",
        "Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n).",
        "Con el uso de funciones, el espacio requerido se puede reducir a O(1).",
        "Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente.",
        "Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente.",
        "Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo.",
        "Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas.",
        "La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7.",
        "AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8.",
        "REFERENCIAS [1] H. L. Bodlaender.",
        "Anchura de árbol: Técnicas algorítmicas y resultados.",
        "En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36.",
        "Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm.",
        "Complejidad de determinar la no vacuidad del núcleo.",
        "En Proc. 18th Int.",
        "Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm.",
        "Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas.",
        "En Proc. 19º Nat.",
        "Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou.",
        "Sobre la complejidad de los conceptos de solución cooperativa.",
        "Matemáticas.",
        "Operación.",
        "Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham.",
        "Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados.",
        "En Proc. 16th Int.",
        "Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh.",
        "Modelos gráficos para teoría de juegos.",
        "En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan.",
        "Sobre el valor de la información privada.",
        "En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara.",
        "Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico.",
        "Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green.",
        "Teoría microeconómica.",
        "Oxford University Press, Nueva York, 1995. [10] N. Nisan.",
        "Subasta y asignación en subastas combinatorias.",
        "En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein.",
        "Un curso de Teoría de Juegos.",
        "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
        "La complejidad de las funciones booleanas.",
        "John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos.",
        "Lema 1.",
        "El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto.",
        "Prueba.",
        "Que el nodo m sea el agente recién introducido en i.",
        "Que U denote el conjunto de agentes en el subárbol con raíz en i.",
        "Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i.",
        "Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2.",
        "El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto.",
        "Prueba.",
        "Considera cualquier conjunto S ⊆ Xi.",
        "Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj).",
        "Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho.",
        "Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202"
    ],
    "error_count": 1,
    "keys": {
        "marginal contribution": {
            "translated_key": "contribución marginal",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>marginal contribution</br> Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the <br>marginal contribution</br> networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average <br>marginal contribution</br> of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his <br>marginal contribution</br> to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "<br>marginal contribution</br> NETS In this section, we will describe the <br>marginal contribution</br> Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind <br>marginal contribution</br> networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "<br>marginal contribution</br> networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "<br>marginal contribution</br> networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "<br>marginal contribution</br> networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "<br>marginal contribution</br> networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a <br>marginal contribution</br> network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as <br>marginal contribution</br> networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as <br>marginal contribution</br> networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "<br>marginal contribution</br> Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the <br>marginal contribution</br> networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "The division of payoff to agent i is the average <br>marginal contribution</br> of agent i over all possible permutations of the agents.",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his <br>marginal contribution</br> to all groups S are the same, φi(v) = v({i}).",
                "<br>marginal contribution</br> NETS In this section, we will describe the <br>marginal contribution</br> Networks representation scheme."
            ],
            "translated_annotated_samples": [
                "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las <br>contribuciones marginales</br> de los agentes.",
                "Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de <br>contribución marginal</br>, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes.",
                "La división del pago al agente i es la <br>contribución marginal</br> promedio del agente i sobre todas las posibles permutaciones de los agentes.",
                "Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su <br>contribución marginal</br> a todos los grupos S es la misma, φi(v) = v({i}).",
                "CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las <br>contribuciones marginales</br> de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de <br>contribución marginal</br>, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la <br>contribución marginal</br> promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su <br>contribución marginal</br> a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. ",
            "candidates": [],
            "error": [
                [
                    "contribuciones marginales",
                    "contribución marginal",
                    "contribución marginal",
                    "contribución marginal"
                ]
            ]
        },
        "compact representation scheme": {
            "translated_key": "esquema de representación compacto",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A <br>compact representation scheme</br> for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a <br>compact representation scheme</br> for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "Marginal Contribution Nets: A <br>compact representation scheme</br> for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "They developed a <br>compact representation scheme</br> for such games, but again the representation is not fully expressive either."
            ],
            "translated_annotated_samples": [
                "Contribuciones marginales netas: Un <br>esquema de representación compacto</br> para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes.",
                "Desarrollaron un <br>esquema de representación compacto</br> para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva."
            ],
            "translated_text": "Contribuciones marginales netas: Un <br>esquema de representación compacto</br> para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un <br>esquema de representación compacto</br> para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "coalitional game": {
            "translated_key": "juego coalicional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this <br>coalitional game</br> setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore <br>coalitional game</br> is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using <br>coalitional game</br> theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for <br>coalitional game</br> Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of <br>coalitional game</br> representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of <br>coalitional game</br> theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on <br>coalitional game</br> representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a <br>coalitional game</br>.",
                "An outcome in a <br>coalitional game</br> specifies the utilities the agents receive.",
                "A solution concept assigns to each <br>coalitional game</br> a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given <br>coalitional game</br> is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a <br>coalitional game</br> is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a <br>coalitional game</br> into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a <br>coalitional game</br> in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary <br>coalitional game</br> N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a <br>coalitional game</br> and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a <br>coalitional game</br>, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "Given this <br>coalitional game</br> setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore <br>coalitional game</br> is a good model for studying the supply chain problem.",
                "The resulting game can be analyzed using <br>coalitional game</br> theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for <br>coalitional game</br> Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of <br>coalitional game</br> representation has only been sparsely explored in the past [2, 3, 4]."
            ],
            "translated_annotated_samples": [
                "Dado este escenario de <br>juego coalicional</br>, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2).",
                "El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el <br>juego coalicional</br> es un buen modelo para estudiar el problema de la cadena de suministro.",
                "El juego resultante puede ser analizado utilizando la <br>teoría de juegos coalicionales</br>, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes.",
                "Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de <br>juegos coalicionales</br>. Para capturar los <br>juegos coalicionales</br> descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos.",
                "Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de <br>juegos coalicionales</br> solo ha sido explorada de manera escasa en el pasado [2, 3, 4]."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de <br>juego coalicional</br>, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el <br>juego coalicional</br> es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la <br>teoría de juegos coalicionales</br>, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de <br>juegos coalicionales</br>. Para capturar los <br>juegos coalicionales</br> descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de <br>juegos coalicionales</br> solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. ",
            "candidates": [],
            "error": [
                [
                    "juego coalicional",
                    "juego coalicional",
                    "teoría de juegos coalicionales",
                    "juegos coalicionales",
                    "juegos coalicionales",
                    "juegos coalicionales"
                ]
            ]
        },
        "shapley value": {
            "translated_key": "valor de Shapley",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the <br>shapley value</br> and the core, under this representation.",
                "The <br>shapley value</br> can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the <br>shapley value</br> (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the <br>shapley value</br> of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the <br>shapley value</br> and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the <br>shapley value</br> and the core.",
                "The <br>shapley value</br> is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the <br>shapley value</br> of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The <br>shapley value</br> is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the <br>shapley value</br> under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the <br>shapley value</br> of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the <br>shapley value</br>, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE <br>shapley value</br> Given a MC-net, we have a simple algorithm to compute the <br>shapley value</br> of the game.",
                "Considering each rule as a separate game, we start by computing the <br>shapley value</br> of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the <br>shapley value</br> of the agents.",
                "Proposition 5.",
                "The <br>shapley value</br> of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the <br>shapley value</br> of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the <br>shapley value</br> of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the <br>shapley value</br>, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the <br>shapley value</br> of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the <br>shapley value</br> of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the <br>shapley value</br> of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "We also develop efficient algorithms for two of the most important solution concepts, the <br>shapley value</br> and the core, under this representation.",
                "The <br>shapley value</br> can be computed in time linear in the size of the input.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the <br>shapley value</br> (definition can be found in section 2).",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the <br>shapley value</br> of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the <br>shapley value</br> and the core.1 We will also review previous work on coalitional game representation in more detail."
            ],
            "translated_annotated_samples": [
                "También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el <br>valor de Shapley</br> y el núcleo, bajo esta representación.",
                "El <br>valor de Shapley</br> se puede calcular en tiempo lineal en función del tamaño de la entrada.",
                "Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del <br>valor de Shapley</br> (la definición se puede encontrar en la sección 2).",
                "Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el <br>valor de Shapley</br> de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo.",
                "PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el <br>valor de Shapley</br> y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el <br>valor de Shapley</br> y el núcleo, bajo esta representación. El <br>valor de Shapley</br> se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del <br>valor de Shapley</br> (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el <br>valor de Shapley</br> de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el <br>valor de Shapley</br> y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "treewidth": {
            "translated_key": "ancho del árbol",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the <br>treewidth</br> of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the <br>treewidth</br> of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded <br>treewidth</br>.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded <br>treewidth</br>. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the <br>treewidth</br> of the agent graph.",
                "Thus, for graphs of small <br>treewidth</br>, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded <br>treewidth</br>. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and <br>treewidth</br>3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The <br>treewidth</br> of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The <br>treewidth</br> of a graph is defined as the minimum <br>treewidth</br> over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same <br>treewidth</br>, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the <br>treewidth</br> of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the <br>treewidth</br> of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the <br>treewidth</br> of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "<br>treewidth</br>: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "The emptiness of the core can be determined in time exponential only in the <br>treewidth</br> of a graphical interpretation of our representation.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the <br>treewidth</br> of the graph. 2.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded <br>treewidth</br>.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded <br>treewidth</br>. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "For Core-Membership, our algorithm runs in time exponential only in the <br>treewidth</br> of the agent graph."
            ],
            "translated_annotated_samples": [
                "La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el <br>ancho del árbol</br> de una interpretación gráfica de nuestra representación.",
                "Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el <br>treewidth</br> del grafo.",
                "A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de <br>ancho de árbol</br> acotado.",
                "Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de <br>treewidth</br> acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197",
                "Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el <br>treewidth</br> del grafo de agentes."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el <br>ancho del árbol</br> de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el <br>treewidth</br> del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de <br>ancho de árbol</br> acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de <br>treewidth</br> acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el <br>treewidth</br> del grafo de agentes. ",
            "candidates": [],
            "error": [
                [
                    "ancho del árbol",
                    "treewidth",
                    "ancho de árbol",
                    "treewidth",
                    "treewidth"
                ]
            ]
        },
        "agent": {
            "translated_key": "agente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each <br>agent</br> should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to <br>agent</br> i is the average marginal contribution of <br>agent</br> i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If <br>agent</br> i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual <br>agent</br>, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first <br>agent</br>, value 1 for the second <br>agent</br> in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the <br>agent</br> graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the <br>agent</br> graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each <br>agent</br>, we then sum up the Shapley values of that <br>agent</br> over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an <br>agent</br> in a marginal contribution network is equal to the sum of the Shapley values of that <br>agent</br> over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any <br>agent</br> in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the <br>agent</br> graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the <br>agent</br> graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the <br>agent</br> graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the <br>agent</br> graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an <br>agent</br> i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include <br>agent</br> i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an <br>agent</br> m and a set S at node i now refers to the cut among <br>agent</br> m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an <br>agent</br> m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for <br>agent</br> i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the <br>agent</br> graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain <br>agent</br> represents a type of exhaustible resource, and therefore rules that depend on the presence of the <br>agent</br> should not apply simultaneously.",
                "For example, if <br>agent</br> i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced <br>agent</br> at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "These values can then be used to determine how much each <br>agent</br> should receive for participating in the system.",
                "The division of payoff to <br>agent</br> i is the average marginal contribution of <br>agent</br> i over all possible permutations of the agents.",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If <br>agent</br> i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual <br>agent</br>, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first <br>agent</br>, value 1 for the second <br>agent</br> in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc."
            ],
            "translated_annotated_samples": [
                "Estos valores pueden ser utilizados para determinar cuánto debe recibir cada <br>agente</br> por participar en el sistema.",
                "La división del pago al <br>agente</br> i es la contribución marginal promedio del <br>agente</br> i sobre todas las posibles permutaciones de los agentes.",
                "Simetría (SYM) Si los <br>agente</br>s i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el <br>agente</br> i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}).",
                "Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada <br>agente</br> individual, una regla de valor -1 para cada par de <br>agente</br>s para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión.",
                "Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer <br>agente</br>, valor 1 para el segundo <br>agente</br> en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada <br>agente</br> por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al <br>agente</br> i es la contribución marginal promedio del <br>agente</br> i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los <br>agente</br>s i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el <br>agente</br> i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada <br>agente</br> individual, una regla de valor -1 para cada par de <br>agente</br>s para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer <br>agente</br>, valor 1 para el segundo <br>agente</br> en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "interaction": {
            "translated_key": "interacciones",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the <br>interaction</br>s among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the <br>interaction</br>s among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent <br>interaction</br>s among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the <br>interaction</br>s among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all <br>interaction</br>s (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "This representation scheme captures characteristics of the <br>interaction</br>s among the agents in a natural and concise manner.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the <br>interaction</br>s among the agents.",
                "However, this representation is not general; it will not be able to represent <br>interaction</br>s among three or more agents.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the <br>interaction</br>s among the agents.",
                "By the running intersection property, all <br>interaction</br>s (the hyperedges) between m and U must be in node i."
            ],
            "translated_annotated_samples": [
                "Este esquema de representación captura las características de las <br>interacciones</br> entre los agentes de una manera natural y concisa.",
                "Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las <br>interacciones</br> entre los agentes.",
                "Sin embargo, esta representación no es general; no podrá representar <br>interacciones</br> entre tres o más agentes.",
                "CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las <br>interacciones</br> entre los agentes.",
                "Por la propiedad de intersección en ejecución, todas las <br>interacciones</br> (los hiperarcos) entre m y U deben estar en el nodo i."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las <br>interacciones</br> entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las <br>interacciones</br> entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar <br>interacciones</br> entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las <br>interacciones</br> entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las <br>interacciones</br> (los hiperarcos) entre m y U deben estar en el nodo i. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "core": {
            "translated_key": "núcleo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the <br>core</br>, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the <br>core</br> can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the <br>core</br> in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the <br>core</br> and the emptiness of the <br>core</br> in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the <br>core</br>1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the <br>core</br>.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The <br>core</br> is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under <br>core</br> means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the <br>core</br> if ∀S ⊆ N x(S) ≥ v(S) (2) The <br>core</br> was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the <br>core</br> is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty <br>core</br>, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the <br>core</br> of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the <br>core</br> of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the <br>core</br> is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of <br>core</br> that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the <br>core</br> is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the <br>core</br> is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the <br>core</br> is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the <br>core</br> is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for <br>core</br>-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING <br>core</br>-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the <br>core</br>.",
                "We will focus on the following two problems: Definition 1. (<br>core</br>-Membership) Given a coalitional game and a payoff vector x, determine if x is in the <br>core</br>.",
                "Definition 2. (<br>core</br>-Non-Emptiness) Given a coalitional game, determine if the <br>core</br> is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for <br>core</br>-Membership.",
                "Next, we will present the algorithm for <br>core</br>-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of <br>core</br>-Membership and <br>core</br>-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "<br>core</br>-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "<br>core</br>-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the <br>core</br>.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since <br>core</br>-Membership for games in graphical form is coNP-complete, <br>core</br>-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "<br>core</br>-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that <br>core</br>-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of <br>core</br>-Non-Emptiness via a combinatorial characterization, namely that the <br>core</br> is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the <br>core</br> to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the <br>core</br> is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For <br>core</br>-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the <br>core</br>.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to <br>core</br>-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for <br>core</br>-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for <br>core</br> Membership Our algorithm for <br>core</br>-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the <br>core</br>, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the <br>core</br> condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the <br>core</br> will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the <br>core</br>, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the <br>core</br>.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the <br>core</br> if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the <br>core</br>. (⇒) Suppose x is not in the <br>core</br>, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for <br>core</br> Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for <br>core</br> Non-emptiness We can extend the algorithm for <br>core</br>-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the <br>core</br> is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the <br>core</br> is empty.",
                "We can solve the dual program using the ellipsoid method with <br>core</br>-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the <br>core</br>-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, <br>core</br>-Non-Emptiness can run in time polynomial in the running time of <br>core</br>-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the <br>core</br> is not empty, this program will return an outcome in the <br>core</br>. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While <br>core</br>-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve <br>core</br>-Non-Emptiness.",
                "Other than the algorithm for <br>core</br>-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for <br>core</br>-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the <br>core</br>.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking <br>core</br> membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the <br>core</br>, under this representation.",
                "The emptiness of the <br>core</br> can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the <br>core</br> in superadditive games.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the <br>core</br> and the emptiness of the <br>core</br> in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the <br>core</br>1 We will also review previous work on coalitional game representation in more detail."
            ],
            "translated_annotated_samples": [
                "También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el <br>núcleo</br>, bajo esta representación.",
                "La vacuidad del <br>núcleo</br> puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación.",
                "En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del <br>núcleo</br> en juegos superaditivos.",
                "Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el <br>núcleo</br> y la vacuidad del <br>núcleo</br> en tiempo exponencial solo en el treewidth del grafo.",
                "PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el <br>núcleo</br>. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el <br>núcleo</br>, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del <br>núcleo</br> puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del <br>núcleo</br> en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el <br>núcleo</br> y la vacuidad del <br>núcleo</br> en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el <br>núcleo</br>. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "mc-net": {
            "translated_key": "MC-net",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a <br>mc-net</br>, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use <br>mc-net</br> to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a <br>mc-net</br>, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using <br>mc-net</br> due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "Given a game represented as a <br>mc-net</br>, we can interpret the set of rules that make up the game as a graph.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use <br>mc-net</br> to represent the recommendation game discussed in the introduction.",
                "COMPUTING THE SHAPLEY VALUE Given a <br>mc-net</br>, we have a simple algorithm to compute the Shapley value of the game.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using <br>mc-net</br> due to Proposition 4."
            ],
            "translated_annotated_samples": [
                "Dado un juego representado como una <br>red de MC</br>, podemos interpretar el conjunto de reglas que conforman el juego como un grafo.",
                "Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos <br>MC-net</br> para representar el juego de recomendación discutido en la introducción.",
                "CALCULANDO EL VALOR DE SHAPLEY Dado un <br>MC-net</br>, tenemos un algoritmo simple para calcular el valor de Shapley del juego.",
                "En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando <br>MC-net</br> debido a la Proposición 4."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una <br>red de MC</br>, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos <br>MC-net</br> para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un <br>MC-net</br>, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando <br>MC-net</br> debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202 ",
            "candidates": [],
            "error": [
                [
                    "red de MC",
                    "MC-net",
                    "MC-net",
                    "MC-net"
                ]
            ]
        },
        "coremembership": {
            "translated_key": "Membresía Central",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of <br>coremembership</br> for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for <br>coremembership</br> that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "As for its hardness, given any instance of <br>coremembership</br> for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for <br>coremembership</br> that runs in time exponential only in the treewidth of the agent graph."
            ],
            "translated_annotated_samples": [
                "En cuanto a su dureza, dado cualquier ejemplo de <br>CoreMembership</br> para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4.",
                "Si bien la <br>Membresía Central</br> para redes MC es coNP-completa, hemos desarrollado un algoritmo para la <br>Membresía Central</br> que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de <br>CoreMembership</br> para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la <br>Membresía Central</br> para redes MC es coNP-completa, hemos desarrollado un algoritmo para la <br>Membresía Central</br> que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202 ",
            "candidates": [],
            "error": [
                [
                    "CoreMembership",
                    "Membresía Central",
                    "Membresía Central"
                ]
            ]
        },
        "markov random field": {
            "translated_key": "campo aleatorio de Markov",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "marginal diminishing return": {
            "translated_key": "rendimientos marginales decrecientes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of <br>marginal diminishing return</br>s (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "The use of functions will allow concise description of <br>marginal diminishing return</br>s (MDRs)."
            ],
            "translated_annotated_samples": [
                "El uso de funciones permitirá una descripción concisa de los <br>rendimientos marginales decrecientes</br> (RMD)."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la teoría de juegos coalicionales y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los <br>rendimientos marginales decrecientes</br> (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "coalitional game theory": {
            "translated_key": "teoría de juegos coalicionales",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact Representation Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This representation scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this representation.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our representation.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using <br>coalitional game theory</br>, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game Representation To capture the coalitional games described above and perform computations on them, we must first find a representation for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good representation schemes for coalitional games.",
                "We believe that the quality of a representation scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the representation.",
                "Conciseness: the space requirement of the representation.",
                "Efficiency: the efficiency of the algorithms we can develop for the representation.",
                "Simplicity: the ease of use of the representation by users of the system.",
                "The ideal representation should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a representation scheme that has properties close to the ideal representation.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a representation scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact representation would be one that simply states which agents know of which products, and let the algorithms that operate on the representation to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general representation and efficient algorithms that go with it, the representation will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the representation is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact representation scheme for such games, but again the representation is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive representation scheme based on decomposition.",
                "Our work extends and generalizes the representation schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks representation, a fully expressive representation scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the representation is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this representation that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of <br>coalitional game theory</br> and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This representation is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our representation in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their representation, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this representation is concise since the space required to specify such a game is O(n2 ).",
                "However, this representation is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise representation scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the representation is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this representation can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this representation, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a representation that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this representation.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks representation scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the representation schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible representation scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of representation, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the representation scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our representation achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 Representation Power We will discuss the expressiveness and conciseness of our representation scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive representation scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form representation.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our representation scheme can simulate the multi-issue representation scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue representation for any game.",
                "Proof.",
                "Given a game in multi-issue representation, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our representation may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue representation.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue representation for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue representation.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical representation in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets representation, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive representation scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general representation is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this representation.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of representation by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a representation scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the representation power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our representation.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the representation by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "The resulting game can be analyzed using <br>coalitional game theory</br>, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "PRELIMINARIES In this section, we will briefly review the basics of <br>coalitional game theory</br> and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game representation in more detail."
            ],
            "translated_annotated_samples": [
                "El juego resultante puede ser analizado utilizando la <br>teoría de juegos coalicionales</br>, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes.",
                "PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la <br>teoría de juegos coalicionales</br> y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de representación compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este esquema de representación captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta representación. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de nuestra representación. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la <br>teoría de juegos coalicionales</br>, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la representación de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una representación para estos juegos. La solución ingenua es enumerar los pagos para cada conjunto de agentes, lo que requiere un espacio exponencial de 193 en el número de agentes en el juego. Para las dos aplicaciones descritas, el número de agentes en el sistema puede fácilmente superar los cien; este enfoque ingenuo no será escalable para tales problemas. Por lo tanto, es fundamental encontrar buenos esquemas de representación para juegos coalicionales. Creemos que la calidad de un esquema de representación debe ser evaluada por cuatro criterios. Expresividad: la amplitud de la clase de juegos coalicionales cubiertos por la representación. Concisión: el requisito de espacio de la representación. Eficiencia: la eficiencia de los algoritmos que podemos desarrollar para la representación. Simplicidad: la facilidad de uso de la representación por parte de los usuarios del sistema. La representación ideal debería ser completamente expresiva, es decir, debería ser capaz de representar cualquier juego coalicional, ocupar el menor espacio posible, tener algoritmos eficientes para su cálculo y ser fácil de usar. El objetivo de este documento es desarrollar un esquema de representación que tenga propiedades cercanas a la representación ideal. Desafortunadamente, dado que el número de grados de libertad de los juegos coalicionales es O(2n), no todos los juegos pueden ser representados de manera concisa utilizando un único esquema debido a restricciones de la teoría de la información. Para cualquier clase de juegos dada, uno puede ser capaz de desarrollar un esquema de representación que esté adaptado y sea más compacto que un esquema general. Por ejemplo, para el sistema de recomendación de juegos, una representación altamente compacta sería aquella que simplemente indica qué agentes conocen qué productos, y permite que los algoritmos que operan en la representación calculen los valores de las coaliciones de manera adecuada. Para algunos problemas, sin embargo, puede que no existan algoritmos eficientes para representaciones personalizadas. Al tener una representación general y algoritmos eficientes que la acompañen, la representación será útil como una herramienta de prototipado para estudiar nuevas situaciones económicas. 1.3 Trabajos Previos La cuestión de la representación de juegos coalicionales solo ha sido explorada de manera escasa en el pasado [2, 3, 4]. En [4], Deng y Papadimitriou se enfocaron en la complejidad de diferentes conceptos de solución en juegos coalicionales definidos en grafos. Si bien la representación es compacta, no es completamente expresiva. En [2], Conitzer y Sandholm investigaron el problema de determinar el vaciamiento del núcleo en juegos superaditivos. Desarrollaron un esquema de representación compacto para este tipo de juegos, pero nuevamente la representación tampoco es completamente expresiva. En [3], Conitzer y Sandholm desarrollaron un esquema de representación completamente expresivo basado en la descomposición. Nuestro trabajo extiende y generaliza los esquemas de representación en [3, 4] mediante la descomposición del juego en un conjunto de reglas que asignan contribuciones marginales a grupos de agentes. Realizaremos una revisión más detallada de estos documentos en la sección 2.2 después de cubrir el trasfondo técnico. Resumen de Nuestras Contribuciones: Desarrollamos la representación de redes de contribución marginal, un esquema de representación completamente expresivo cuyo tamaño escala de acuerdo con la complejidad de las interacciones entre los agentes. Creemos que la representación también es simple e intuitiva.\nDesarrollamos un algoritmo para calcular el valor de Shapley de juegos coalicionales bajo esta representación que se ejecuta en tiempo lineal en el tamaño de la entrada.\nBajo la interpretación gráfica de la representación, desarrollamos un algoritmo para determinar si un vector de pagos está en el núcleo y la vacuidad del núcleo en tiempo exponencial solo en el treewidth del grafo. PRELIMINARES En esta sección, revisaremos brevemente los conceptos básicos de la <br>teoría de juegos coalicionales</br> y sus dos principales conceptos de solución, el valor de Shapley y el núcleo. También revisaremos trabajos previos sobre la representación de juegos coalicionales con más detalle. A lo largo de este documento, asumiremos que la recompensa para un grupo de agentes puede ser distribuida libremente entre sus miembros. Esta suposición es frecuentemente conocida como la suposición de utilidad transferible. 2.1 Antecedentes técnicos Podemos representar un juego de coalición con utilidad transferible mediante el par N, v, donde • N es el conjunto de agentes; y • v: 2N → R es una función que asigna a cada grupo de agentes S ⊆ N un pago con valor real. Esta representación es conocida como la forma característica. Dado que hay un número exponencial de subconjuntos, se requerirá un espacio exponencial en el número de agentes para describir un juego coalicional. Un resultado en un juego coalicional especifica las utilidades que reciben los agentes. Un concepto de solución asigna a cada juego coalicional un conjunto de resultados razonables. Diferentes conceptos de solución intentan capturar de alguna manera resultados que son estables y/o justos. Dos de los conceptos de solución más conocidos son el valor de Shapley y el núcleo. El valor de Shapley es un concepto de solución normativa. Prescribe una forma justa de dividir las ganancias de la cooperación cuando se forma la gran coalición (es decir, N). La división del pago al agente i es la contribución marginal promedio del agente i sobre todas las posibles permutaciones de los agentes. Formalmente, sea φi(v) el valor de Shapley de i bajo la función característica v, entonces φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1). El valor de Shapley es un concepto de solución que satisface muchas propiedades interesantes, y ha sido estudiado extensamente en la literatura económica y de teoría de juegos. Tiene una caracterización axiomática muy útil. Eficiencia (EFF) Se distribuye un total de v(N) a los agentes, es decir, i∈N φi(v) = v(N). Simetría (SYM) Si los agentes i y j son intercambiables, entonces φi(v) = φj(v).\nLos materiales y la terminología se basan en los libros de texto de Mas-Colell et al. [9] y Osborne y Rubinstein [11].\nComo conveniencia notacional, usaremos la letra minúscula para representar la cardinalidad de un conjunto denotado por la letra mayúscula correspondiente.\nDummy (DUM) Si el agente i es un jugador ficticio, es decir, su contribución marginal a todos los grupos S es la misma, φi(v) = v({i}). Aditividad (ADD) Para cualquier par de juegos coalicionales v y w definidos sobre el mismo conjunto de agentes N, φi(v + w) = φi(v) + φi(w) para todo i ∈ N, donde el juego v + w se define como (v + w)(S) = v(S) + w(S) para todo S ⊆ N. Nos referiremos a estos axiomas más adelante en nuestra demostración de la corrección del algoritmo para calcular el valor de Shapley bajo nuestra representación en la sección 4. El núcleo es otro concepto importante de solución para los juegos coalicionales. Es un concepto de solución descriptivo que se centra en resultados que son estables. La estabilidad bajo el núcleo significa que ningún grupo de jugadores puede desviarse conjuntamente para mejorar sus ganancias. Formalmente, dejemos que x(S) denote i∈S xi. Un resultado x ∈ Rn está en el núcleo si ∀S ⊆ N x(S) ≥ v(S) (2). El núcleo fue uno de los primeros conceptos de solución propuestos para juegos coalicionales, y ha sido estudiado en detalle. Una pregunta importante para un juego coalicional dado es si el núcleo está vacío. En otras palabras, si hay algún resultado que sea estable en relación a la desviación del grupo. Para que un juego tenga un núcleo no vacío, debe cumplir con la propiedad de equilibrio, definida de la siguiente manera. Sea 1S ∈ Rn el vector característico de S dado por (1S)i = 1 si i ∈ S, 0 en caso contrario. Sea (λS)S⊆N un conjunto de pesos tal que cada λS está en el rango entre 0 y 1. Este conjunto de pesos, (λS)S⊆N, es una colección equilibrada si para todo i ∈ N, S⊆N λS(1S)i = 1. Un juego es equilibrado si para todas las colecciones equilibradas de pesos, S⊆N λSv(S) ≤ v(N). Según el teorema de Bondereva-Shapley, el núcleo de un juego coalicional es no vacío si y solo si el juego es equilibrado. Por lo tanto, podemos usar programación lineal para determinar si el núcleo de un juego está vacío. maximizar λ∈R2n S⊆N λSv(S) sujeto a S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) Si el valor óptimo de (4) es mayor que el valor de la gran coalición, entonces el núcleo está vacío. Desafortunadamente, este programa tiene un número exponencial de variables en la cantidad de jugadores en el juego, por lo tanto, un algoritmo que opere directamente en este programa sería inviable en la práctica. En la sección 5.4, describiremos un algoritmo que responde a la pregunta de vacío del núcleo que funciona en el dual de este programa en su lugar.\n2.2 Trabajo Previo Revisitado Deng y Papadimitriou investigaron la complejidad de varios conceptos de solución en juegos coalicionales jugados en grafos ponderados en [4]. En su representación, el conjunto de agentes son los nodos del grafo, y el valor de un conjunto de agentes S es la suma de los pesos de las aristas abarcadas por ellos. Ten en cuenta que esta representación es concisa ya que el espacio requerido para especificar dicho juego es O(n2). Sin embargo, esta representación no es general; no podrá representar interacciones entre tres o más agentes. Por ejemplo, no podrá representar el juego de mayoría, donde un grupo de agentes S tendrá un valor de 1 si y solo si s > n/2. Por otro lado, existe un algoritmo eficiente para calcular el valor de Shapley del juego y para determinar si el núcleo está vacío bajo la restricción de pesos de arista positivos. Sin embargo, en el caso no restringido, determinar si el núcleo está vacío es coNP-completo. Conitzer y Sandholm en [2] consideraron juegos coalicionales que son superaditivos. Describieron un esquema de representación conciso que solo indica el valor de una coalición si el valor es estrictamente superaditivo. Más precisamente, la semántica de la representación es que para un grupo de agentes S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) donde Π es el conjunto de todas las particiones posibles de S. El valor v(S) solo se especifica explícitamente para S si v(S) es mayor que todas las particiones de S que no sean la partición trivial ({S}). Si bien esta representación puede representar todos los juegos que son superaditivos, hay juegos coalicionales que no puede representar. Por ejemplo, no podrá representar juegos con sustituibilidad entre los agentes. Un ejemplo de un juego que no se puede representar es el juego de la unidad, donde v(S) = 1 siempre que S = ∅. Bajo esta representación, los autores demostraron que determinar si el núcleo está vacío es coNP-completo. De hecho, incluso determinar el valor de un grupo de agentes es NP-completo. En un artículo más reciente, Conitzer y Sandholm describieron una representación que descompone un juego coalicional en varios subjuegos cuya suma equivale al juego original [3]. Los pagos en estos subjuegos son representados por sus respectivas funciones características. Este esquema es completamente general ya que la forma característica es un caso especial de esta representación. Para cualquier juego dado, puede haber múltiples formas de descomponer el juego, y la descomposición puede influir en la complejidad computacional. Para calcular el valor de Shapley, los autores demostraron que la complejidad es lineal en la descripción de la entrada; en particular, si el subjuego más grande (medido por el número de agentes) tiene un tamaño de n y el número de subjuegos es m, entonces su algoritmo se ejecuta en tiempo O(m2n), donde el tamaño de la entrada también será O(m2n). Por otro lado, el problema de determinar si un cierto resultado está en el núcleo es coNP-completo. CONTRIBUCIÓN MARGINAL EN REDES En esta sección, describiremos el esquema de representación de Redes de Contribución Marginal. Mostraremos que la idea es flexible y que podemos extenderla fácilmente para aumentar su concisión. También mostraremos cómo podemos usar este esquema para representar el juego de recomendación de la introducción. Finalmente, demostraremos que este esquema es completamente expresivo y generaliza los esquemas de representación en [3, 4]. 3.1 Reglas y Redes de Contribución Marginal La idea básica detrás de las redes de contribución marginal (MC-nets) es representar juegos coalicionales utilizando conjuntos de reglas. Las reglas en las redes MC tienen la siguiente forma sintáctica: Patrón → valor. Se dice que una regla se aplica a un grupo de agentes S si S cumple con el requisito del Patrón. En el esquema básico, estos patrones son conjunciones de agentes, y S cumple con el requisito del patrón dado si S es un superconjunto de él. El valor de un grupo de agentes se define como la suma de los valores de todas las reglas que se aplican al grupo. Por ejemplo, si el conjunto de reglas es {a ∧ b} → 5 {b} → 2 entonces v({a}) = 0, v({b}) = 2, y v({a, b}) = 5 + 2 = 7. MC-nets es un esquema de representación muy flexible y puede ser extendido de diferentes formas. Una forma sencilla de ampliarlo y aumentar su concisión es permitir una clase más amplia de patrones en las reglas. Un patrón que utilizaremos a lo largo del resto del documento es uno que se aplica solo en ausencia de ciertos agentes. Esto es útil para expresar conceptos como la sustituibilidad o los valores predeterminados. Formalmente, expresamos tales patrones como {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn}, lo cual tiene la semántica de que dicha regla se aplicará a un grupo S solo si {pi}m i=1 ∈ S y {nj}n j=1 /∈ S. Llamaremos a {pi}m i=1 en el patrón anterior los literales positivos, y a {nj}n j=1 los literales negativos. Ten en cuenta que si el patrón de una regla consiste únicamente en literales negativos, consideraremos que el conjunto vacío de agentes también satisfará dicho patrón, y por lo tanto v(∅) puede ser distinto de cero en presencia de literales negativos. Para demostrar el aumento en la concisión de la representación, considere el juego de unidad descrito en la sección 2.2. Para representar un juego de este tipo sin usar literales negativos, necesitaremos 2n reglas para n jugadores: necesitamos una regla de valor 1 para cada agente individual, una regla de valor -1 para cada par de agentes para contrarrestar el doble conteo, una regla de valor 1 para cada trío de agentes, etc., similar al principio de inclusión-exclusión. Por otro lado, al usar literales negativos, solo necesitamos n reglas: valor 1 para el primer agente, valor 1 para el segundo agente en ausencia del primer agente, valor 1 para el tercer agente en ausencia de los dos primeros agentes, etc. Los ahorros representacionales pueden ser exponenciales en el número de agentes. Dado un juego representado como una red de MC, podemos interpretar el conjunto de reglas que conforman el juego como un grafo. Llamamos a este gráfico el gráfico de agentes. Los nodos en el grafo representarán a los agentes en el juego, y para cada regla en la MCnet, conectamos todos los agentes en la regla juntos y asignamos un valor al clique formado por el conjunto de agentes. Ten en cuenta que para acomodar literales negativos, necesitaremos anotar el clique apropiadamente. Esta vista alternativa de las redes MC será útil en nuestro algoritmo para la Membresía Central en la sección 5. Nos gustaría finalizar nuestra discusión sobre el esquema de representación mencionando un compromiso entre la expresividad de los patrones y el espacio necesario para representarlos. Para representar un juego coalicional en forma característica, se necesitaría especificar todos los 2n − 1 valores. No hay gastos adicionales además de eso, ya que hay un orden natural de los grupos. Para las redes MC-nets, sin embargo, la especificación de las reglas requiere especificar tanto los patrones como los valores. Los patrones, si no se representan de forma compacta, pueden terminar abrumando el ahorro de tener menos valores que especificar. El espacio requerido para los patrones también conlleva un compromiso entre la expresividad de los patrones permitidos y la simplicidad de representarlos. Sin embargo, creemos que para la mayoría de los juegos que surgen naturalmente, debería haber suficiente estructura en el problema para que nuestra representación logre un ahorro neto sobre la forma característica.  \n3.2 Ejemplo: Juego de Recomendación  \nComo ejemplo, utilizaremos MC-net para representar el juego de recomendación discutido en la introducción. Para cada producto, dado que el beneficio de conocer sobre el producto solo se contará una vez para cada grupo, necesitamos capturar la sustituibilidad entre los agentes. Esto se puede capturar mediante un juego de unidad escalado. Supongamos que el valor del conocimiento sobre el producto i es vi, y hay ni agentes, denotados por {xj i}, que conocen el producto, el juego para el producto i puede entonces representarse como las siguientes reglas: {x1 i} → vi {x2 i ∧ ¬x1 i} → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i} → vi El juego completo puede construirse a partir de los conjuntos de reglas de cada producto. El requisito de espacio será O(mn∗), donde m es el número de productos en el sistema, y n∗ es el número máximo de agentes que conocen el mismo producto.\n3.3 Poder de Representación Discutiremos la expresividad y concisión de nuestro esquema de representación y lo compararemos con los trabajos anteriores en esta subsección. Proposición 1. Las redes de contribución marginal constituyen un esquema de representación completamente expresivo. Prueba. Considera un juego de coalición arbitrario N, v en representación en forma característica. Podemos construir un conjunto de reglas para describir este juego comenzando desde los conjuntos unitarios y construyendo el conjunto de reglas. Para cualquier conjunto unitario {i}, creamos una regla {i} → v(i). Para cualquier par de agentes {i, j}, creamos una regla {i ∧ j} → v({i, j}) − v({i}) − v({j}). Podemos seguir construyendo reglas de manera similar al principio de inclusión-exclusión. Dado que el juego es arbitrario, las redes MC son completamente expresivas. Usando la construcción descrita en la prueba, podemos demostrar que nuestro esquema de representación puede simular el esquema de representación multi-tema de [3] en casi la misma cantidad de espacio. Proposición 2. Las redes de contribución marginal utilizan como máximo un factor lineal (en el número de agentes) más de espacio que la representación multi-tema para cualquier juego. Prueba. Dado un juego en representación de múltiples problemas, comenzamos describiendo cada uno de los subjuegos, que están representados en forma característica en [3], con un conjunto de reglas. Luego construimos el juego principal incluyendo todas las reglas de los subjuegos. Ten en cuenta que nuestra representación puede requerir un espacio mayor por un factor lineal debido a la necesidad de describir los patrones para cada regla. Por otro lado, nuestro enfoque puede tener menos reglas que un número exponencial para cada subjuego, dependiendo de la estructura de estos subjuegos, y por lo tanto puede ser más conciso que una representación de múltiples problemas. Por otro lado, hay juegos que requieren exponencialmente más espacio para representarse bajo el esquema de múltiples problemas en comparación con nuestro esquema. Proposición 3. Las redes de contribución marginal son exponencialmente más concisas que la representación multi-tema para ciertos juegos. Prueba. Considera un juego de unidad sobre todos los agentes N. Como se explica en 3.1, este juego puede ser representado en un espacio lineal utilizando redes de MC con literales negativos. Sin embargo, como no hay descomposición de este juego en subjuegos más pequeños, se requerirá un espacio O(2n) para representar este juego bajo la representación multi-issue. Bajo la interpretación del grafo de agentes de las redes MC, podemos ver que las redes MC son una generalización de la representación gráfica en [4], es decir, de grafos ponderados a hipergrafos ponderados. Proposición 4. Las redes de contribución marginal pueden representar cualquier juego en forma gráfica (bajo [4]) en la misma cantidad de espacio. Prueba. Dado un juego en forma gráfica, G, para cada borde (i, j) con peso wij en el grafo, creamos una regla {i, j} → wij. Claramente esto ocupa exactamente el mismo espacio que el tamaño de G, y por la semántica aditiva de las reglas, representa el mismo juego que G. 4. CALCULANDO EL VALOR DE SHAPLEY Dado un MC-net, tenemos un algoritmo simple para calcular el valor de Shapley del juego. Considerando cada regla como un juego separado, comenzamos calculando el valor de Shapley de los agentes para cada regla. Para cada agente, luego sumamos los valores de Shapley de ese agente sobre todas las reglas. Primero mostramos que este proceso final de sumar calcula correctamente el valor de Shapley de los agentes. Proposición 5. El valor de Shapley de un agente en una red de contribución marginal es igual a la suma de los valores de Shapley de ese agente sobre cada regla. Prueba. Para cualquier grupo S, bajo la representación de redes MC-nets, v(S) se define como la suma de los valores de todas las reglas que se aplican a S. Por lo tanto, considerando cada regla como un juego, según el axioma (ADD) discutido en la sección 2, el valor de Shapley del juego creado a partir de la agregación de todas las reglas es igual a la suma de los valores de Shapley sobre las reglas. La pregunta que queda es cómo calcular los valores de Shapley de las reglas. Podemos separar el análisis en dos casos, uno para reglas con solo literales positivos y otro para reglas con literales mixtos. Para reglas que solo tienen literales positivos, el valor de Shapley de los agentes es v/m, donde v es el valor de la regla y m es el número de agentes en la regla. Esto es una consecuencia directa del axioma (SYM) del valor de Shapley, ya que los agentes en una regla son indistinguibles entre sí. Para reglas que tienen literales tanto positivos como negativos, podemos considerar los literales positivos y negativos por separado. Para un literal positivo dado i, la regla se aplicará solo si i ocurre en una permutación dada después del resto de los literales positivos pero antes de cualquiera de los literales negativos. Formalmente, sea φi el valor de Shapley de i, p la cardinalidad del conjunto positivo y n la cardinalidad del conjunto negativo, entonces φi = (p − 1)!n! (p + n)! v = v p p+n n. Para una literal negativa dada j, j será responsable de cancelar la aplicación de la regla si todas las literales positivas vienen antes de las literales negativas en el orden y j es la primera entre las literales negativas. Por lo tanto, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p. Por el axioma (SYM), todas las literales positivas tendrán el valor de φi y todas las literales negativas tendrán el valor de φj. Ten en cuenta que la suma sobre todos los agentes en reglas con literales mixtos es 0. Esto es de esperarse ya que estas reglas contribuyen con 0 a la gran coalición. El hecho de que estas reglas no tengan efecto en la gran coalición puede parecer extraño al principio. Pero esto se debe a que la presencia de tales reglas es para definir los valores de coaliciones más pequeñas que la gran coalición. En términos de complejidad computacional, dado que el valor de Shapley de cualquier agente en una regla dada se puede calcular en tiempo lineal en el patrón de la regla, el tiempo de ejecución total del algoritmo para calcular el valor de Shapley del juego es lineal en el tamaño de la entrada. RESPONDIENDO A PREGUNTAS RELACIONADAS CON EL NÚCLEO Hay algunos problemas computacionales diferentes pero relacionados asociados con el concepto de solución del núcleo. Nos enfocaremos en los siguientes dos problemas: Definición 1. (Membresía del núcleo) Dado un juego coalicional y un vector de pagos x, determinar si x está en el núcleo. Definición 2. (Núcleo-No-Vacuidad) Dado un juego coalicional, determinar si el núcleo no está vacío. En el resto de la sección, primero demostraremos que estos dos problemas son coNP-completos y coNP-duros respectivamente, y discutiremos algunas consideraciones de complejidad sobre estos problemas. Luego revisaremos las ideas principales de la descomposición de árboles, ya que se utilizará ampliamente en nuestro algoritmo para la Membresía Central. A continuación, presentaremos el algoritmo para la Membresía del Núcleo, y demostraremos que el algoritmo se ejecuta en tiempo polinómico para grafos de ancho de árbol acotado. Terminamos extendiendo este algoritmo para responder la pregunta de No-Vaciabilidad del Núcleo en tiempo polinómico para grafos de treewidth acotada. 5.1 Complejidad Computacional La dificultad de la Membresía del Núcleo y la No-Vaciabilidad del Núcleo se sigue directamente de los resultados de dificultad de juegos sobre grafos ponderados en [4]. Proposición 6. 197 La pertenencia central para juegos representados como redes de contribución marginal es coNP-completa. Prueba. La pertenencia central en las redes de MC está en la clase de coNP, ya que cualquier conjunto de agentes S del cual v(S) > x(S) servirá como certificado para demostrar que x no pertenece al núcleo. En cuanto a su dureza, dado cualquier ejemplo de CoreMembership para un juego en forma gráfica de [4], podemos codificar el juego exactamente en el mismo espacio utilizando MC-net debido a la Proposición 4. Dado que la Membresía del Núcleo para juegos en forma gráfica es coNP-completa, la Membresía del Núcleo en redes de MC es coNP-difícil. Proposición 7. La no vacuidad del núcleo para juegos representados como redes de contribución marginal es coNP-difícil. Prueba. El mismo argumento de dificultad entre juegos en forma gráfica y redes de MC se aplica al problema de No-Vaciado del Núcleo. No conocemos un certificado que demuestre que Core-NonEmptiness está en la clase de coNP en este momento. Ten en cuenta que el certificado obvio de un conjunto equilibrado de pesos basado en el teorema de Bondereva-Shapley es de tamaño exponencial. En [4], Deng y Papadimitriou demostraron la coNP-completitud de la No-Vaciabilidad del Núcleo a través de una caracterización combinatoria, a saber, que el núcleo es no vacío si y solo si no hay un corte negativo en el grafo. En las redes MC-nets, sin embargo, no es necesario que haya un hiperconjunto negativo en el grafo para que el núcleo esté vacío, como se demuestra en el siguiente juego (N = {1, 2, 3, 4}): v(S) =    1 si S = {1, 2, 3, 4} 3/4 si S = {1, 2}, {1, 3}, {1, 4} o {2, 3, 4} 0 en otro caso (5) Aplicando el teorema de Bondareva-Shapley, si permitimos que λ12 = λ13 = λ14 = 1/3, y λ234 = 2/3, este conjunto de pesos demuestra que el juego no está equilibrado, por lo tanto, el núcleo está vacío. Por otro lado, este juego puede ser representado con redes de Markov de campo como sigue (pesos en hiperarcos): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No importa cómo se divida el conjunto, la suma de los pesos de los hiperarcos en el corte siempre es no negativa. Para superar la dificultad computacional de estos problemas, hemos desarrollado algoritmos basados en técnicas de descomposición de árboles. Para la Membresía Principal, nuestro algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. Por lo tanto, para grafos de pequeño ancho de árbol, como los árboles, tenemos una solución manejable para determinar si un vector de pagos está en el núcleo. Al utilizar este procedimiento como un oráculo de separación, es decir, un procedimiento para devolver la desigualdad violada por una solución candidata, para resolver un programa lineal relacionado con la No-Vaciabilidad del Núcleo utilizando el método de la elipsoide, podemos obtener un algoritmo de tiempo polinómico para la No-Vaciabilidad del Núcleo para grafos de treewidth acotada. 5.2 Revisión de la Descomposición de Árboles Dado que nuestro algoritmo para la Membresía del Núcleo depende en gran medida de la descomposición de árboles, primero revisaremos brevemente las ideas principales en la descomposición de árboles y la treewidth. Definición 3. Una descomposición de un árbol de un grafo G = (V, E) es un par (X, T), donde T = (I, F) es un árbol y X = {Xi | i ∈ I} es una familia de subconjuntos de V, uno para cada nodo de T, tal que • i∈I Xi = V; • Para todas las aristas (v, w) ∈ E, existe un i ∈ I con v ∈ Xi y w ∈ Xi; y • (Propiedad de Intersección en Ejecución) Para todo i, j, k ∈ I: si j está en el camino de i a k en T, entonces Xi ∩ Xk ⊆ Xj. El treewidth de una descomposición de un árbol se define como la cardinalidad máxima sobre todos los conjuntos en X, menos uno. El ancho de árbol de un grafo se define como el ancho de árbol mínimo sobre todas las descomposiciones en árbol del grafo. Dada una descomposición de un árbol, podemos convertirla en una descomposición de un árbol agradable con el mismo ancho de árbol y de tamaño lineal en el de T. Definición 4. Una descomposición de árbol T es buena si T está enraizado y tiene cuatro tipos de nodos: Los nodos hoja i son hojas de T con |Xi| = 1. Introduce nodos i tengo un hijo j tal que Xi = Xj ∪ {v} de algún v ∈ V. Olvida los nodos, tengo un hijo j tal que Xi = Xj \\ {v} para algún v ∈ Xj. Unir nodos i que tienen dos hijos j y k con Xi = Xj = Xk. Un ejemplo de una descomposición de árbol (parcial) junto con una clasificación de los diferentes tipos de nodos se muestra en la Figura 1. En la siguiente sección, nos referiremos a los nodos en la descomposición del árbol como nodos, y a los nodos en el grafo del agente como agentes. 5.3 Algoritmo para la Membresía del Núcleo Nuestro algoritmo para la Membresía del Núcleo toma como entrada una descomposición de árbol T del grafo del agente y un vector de pagos x. Por definición, si x pertenece al núcleo, entonces para todos los grupos S ⊆ N, x(S) ≥ v(S). Por lo tanto, la diferencia x(S)−v(S) mide qué tan cerca está el grupo S de violar la condición del núcleo. Llamamos a esta diferencia el exceso del grupo S. Definición 5. El exceso de una coalición S, e(S), se define como x(S) − v(S). Un enfoque de fuerza bruta para determinar si un vector de pagos pertenece al núcleo tendrá que verificar que los excesos de todos los grupos sean no negativos. Sin embargo, este enfoque ignora la estructura en el grafo del agente que permitirá a un algoritmo inferir que ciertos grupos tienen excesos no negativos debido a 3. Esto se basa en gran medida en los materiales de un artículo de revisión de Bodlaender [1]. 198 i j k l nm Introducir Nodo: Xj = {1, 4} Xk = {1, 4} Olvidar Nodo: Xl = {1, 4} Introducir Nodo: Xm = {1, 2, 4} Xn = {4} Nodo Hoja: Nodo de Unión: Xi = {1, 3, 4} Nodo de Unión: Figura 1: Ejemplo de una descomposición de árbol (parcial) agradable, los excesos se calculan en otro lugar en el grafo. La descomposición de árboles es la clave para aprovechar tales inferencias de manera estructurada. Por ahora, centrémonos en reglas con literales positivos. Supongamos que ya hemos verificado que los excesos de todos los conjuntos R ⊆ U son no negativos, y nos gustaría verificar si la adición de un agente i al conjunto U creará un grupo con exceso negativo. Una solución ingenua sería calcular los excesos de todos los conjuntos que incluyen i. El exceso del grupo (R ∪ {i}) para cualquier grupo R se puede calcular de la siguiente manera: e(R ∪ {i}) = e(R) + xi − v(c) (6) donde c es el corte entre R e i, y v(c) es la suma de los pesos de las aristas en el corte. Sin embargo, supongamos que a partir de la descomposición del árbol, sabemos que i solo está conectado a un subconjunto de U, digamos S, al que llamaremos el conjunto de entrada a U. Idealmente, dado que i no comparte aristas con los miembros de ¯U = (U \\ S), esperaríamos que un algoritmo pueda aprovechar esta estructura revisando solo conjuntos que son subconjuntos de (S ∪ {i}). Este ahorro computacional puede ser posible ya que (xi − v(c)) en la ecuación de actualización de (6) no depende de ¯U. Sin embargo, no podemos simplemente ignorar ¯U, ya que los miembros de ¯U aún pueden influir en los excesos de los grupos que incluyen al agente i a través del grupo S. Específicamente, si existe un grupo T ⊃ S tal que e(T) < e(S), entonces incluso cuando e(S ∪ {i}) tiene un exceso no negativo, e(T ∪ {i}) puede tener un exceso negativo. En otras palabras, el exceso disponible en S puede haberse agotado debido a T. Esto motiva la definición de la reserva de un grupo. Definición 6. La reserva de una coalición S con respecto a una coalición U es el exceso mínimo sobre todas las coaliciones entre S y U, es decir, todas las T: S ⊆ T ⊆ U. Denotamos este valor como r(S, U). Nos referiremos al grupo T que tiene el exceso mínimo como arg r(S, U). También llamaremos U al conjunto límite de la reserva y S al conjunto base de la reserva. Nuestro algoritmo funciona manteniendo un registro de las reservas de todos los subconjuntos no vacíos que pueden formarse por los agentes de un nodo en cada uno de los nodos de la descomposición del árbol. Comenzando desde las hojas del árbol y trabajando hacia la raíz, en cada nodo i, nuestro algoritmo calcula las reservas de todos los grupos S ⊆ Xi, limitados por el conjunto de agentes en el subárbol enraizado en i, Ti, excepto aquellos en (Xi\\S). Los agentes en (Xi\\S) están excluidos para asegurar que S sea un conjunto de entrada. Específicamente, S es el conjunto de entrada establecido como ((Ti \\ Xi) ∪ S). Para acomodar los literales negativos, necesitaremos hacer dos ajustes. En primer lugar, el corte entre un agente m y un conjunto S en el nodo i ahora se refiere al corte entre el agente m, el conjunto S y el conjunto ¬(Xi \\ S), y su valor debe ser calculado en consecuencia. Además, cuando se introduce un agente m a un grupo en un nodo de introducción, también necesitaremos considerar el cambio en las reservas de los grupos que no incluyen a m debido a un posible corte que involucre a ¬m y al grupo. Como ejemplo de los valores de reserva que seguimos en un nodo del árbol, considera el nodo i del árbol en la Figura 1. En el nodo i, haremos un seguimiento de lo siguiente: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .}) donde los puntos suspensivos . . . se refieren a los agentes enraizados bajo el nodo m. Para uso notacional, usaremos ri(S) para denotar r(S, U) en el nodo i donde U es el conjunto de agentes en el subárbol enraizado en el nodo i excluyendo agentes en (Xi \\ S). A veces nos referimos a estos valores como los valores r de un nodo. Los detalles de los cálculos del valor r están en el Algoritmo 1. Para determinar si el vector de pagos x está en el núcleo, durante el cálculo del valor r en cada nodo, podemos verificar si todos los valores de r son no negativos. Si esto es así para todos los nodos en el árbol, el vector de pagos x está en el núcleo. La corrección del algoritmo se debe a la siguiente proposición. Proposición 8. El vector de pagos x no está en el núcleo si y solo si los valores r en algún nodo i para algún grupo S son negativos. Prueba. (⇐) Si la reserva en algún nodo i para algún grupo S es negativa, entonces existe una coalición T para la cual e(T) = x(T) − v(T) < 0, por lo tanto, x no está en el núcleo. (⇒) Supongamos que x no está en el núcleo, entonces existe algún grupo R∗ tal que e(R∗) < 0. Sea Xroot el conjunto de nodos en la raíz. Considerando cualquier conjunto S ∈ Xroot, rroot(S) tendrá el conjunto base de S y el conjunto límite de ((N \\ Xroot) ∪ S). La unión sobre todos estos rangos incluye todos los conjuntos U para los cuales U ∩ Xroot = ∅. Por lo tanto, si R∗ no es disjunto de Xroot, el valor r para algún grupo en la raíz es negativo. Si R∗ es disjunto de U, considera el bosque {Ti} resultante de la eliminación de todos los nodos de árbol que incluyen agentes en Xroot. Algoritmo 1 Subprocedimientos para la Membresía del Núcleo Nodo-Hoja(i) 1: ri(Xi) ← e(Xi) Introducir-Nodo(i) 2: j ← hijo de i 3: m ← Xi \\ Xj {el nodo introducido} 4: para todo S ⊆ Xj, S = ∅ hacer 5: C ← todos los hiperarcos en el corte de m, S, y ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← todos los hiperarcos en el corte de ¬m, S, y ¬(Xi \\ S) 8: ri(S) ← rj(S) − v(C) 9: fin para 10: r({m}) ← e({m}) Olvidar-Nodo(i) 11: j ← hijo de i 12: m ← Xj \\ Xi {el nodo olvidado} 13: para todo S ⊆ Xi, S = ∅ hacer 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: fin para Unir-Nodo(i) 16: {j, k} ← {hijo izquierdo, hijo derecho} de i 17: para todo S ⊆ Xi, S = ∅ hacer 18: ri(S) ← rj(S) + rk(S) − e(S) 19: fin para Por la propiedad de intersección en ejecución, los conjuntos de nodos en los árboles Tis son disjuntos. Por lo tanto, si el conjunto R∗ = i Si para algún Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implica que algún grupo S∗ i también tiene exceso negativo. Por lo tanto, solo necesitamos verificar los valores de r de los nodos en los árboles individuales en el bosque. Pero para cada árbol en el bosque, podemos aplicar el mismo argumento restringido a los agentes en el árbol. En el caso base, tenemos los nodos hoja de la descomposición del árbol original, digamos, para el agente i. Si R∗ = {i}, entonces r({i}) = e({i}) < 0. Por lo tanto, por inducción, si e(R∗ ) < 0, alguna reserva en algún nodo sería negativa. A continuación, explicaremos la intuición detrás de la corrección de los cálculos para los valores de r en los nodos del árbol. Una prueba detallada de la corrección de estos cálculos se puede encontrar en el apéndice bajo los Lemas 1 y 2. Proposición 9. El procedimiento en el Algoritmo 1 calcula correctamente los valores r en cada uno de los nodos del árbol. Prueba. (Bosquejo) Podemos realizar un análisis de casos sobre los cuatro tipos de nodos de árbol en una descomposición de árbol agradable. Nodos hoja (i) El único valor de reserva a calcular es ri(Xi), que es igual a r(Xi, Xi), y por lo tanto es simplemente el exceso del grupo Xi. Olvida los nodos (i con hijo j). Sea m el nodo olvidado. Para cualquier subconjunto S ⊆ Xi, arg ri(S) debe ser elegido entre los grupos de S y S ∪ {m}, y por lo tanto elegimos entre el menor de los dos valores r en el nodo j. Introducir nodos (i con hijo j). Sea m el nodo introducido. Para cualquier subconjunto T ⊆ Xi que incluya a m, sea S el conjunto (T \\ {m}). Por la propiedad de intersección en ejecución, no hay reglas que involucren m y agentes del subárbol enraizado en el nodo i, excepto aquellas que involucren m y agentes en Xi. Dado que tanto el conjunto base como el conjunto límite de los valores r del nodo j y del nodo i difieren por {m}, para cualquier grupo V que se encuentre entre el conjunto base y el conjunto límite del nodo i, el exceso del grupo V diferirá por una cantidad constante del grupo correspondiente (V \\ {m}) en el nodo j. Por lo tanto, el conjunto arg ri(T) es igual al conjunto arg rj(S) ∪ {m}, y ri(T) = rj(S) + xm − v(cut), donde v(cut) es el valor de las reglas en el corte entre m y S. Para cualquier subconjunto S ⊂ Xi que no incluya a m, necesitamos considerar los valores de las reglas que incluyen ¬m como literal en el patrón. Además, al calcular la reserva, el pago xm no contribuirá al grupo S. Por lo tanto, junto con la propiedad de intersección en ejecución como se argumentó anteriormente, podemos mostrar que ri(S) = rj(S) − v(cut). Unir nodos (i con hijo izquierdo j y hijo derecho k). Para cualquier conjunto dado S ⊆ Xi, considera los valores r de ese conjunto en j y k. Si arg rj(S) o arg rk(S) incluye agentes que no están en S, entonces argrj(S) y argrk(S) serán disjuntos entre sí debido a la propiedad de intersección en ejecución. Por lo tanto, podemos descomponer arg ri(S) en tres conjuntos, (arg rj(S) \\ S) a la izquierda, S en el medio y (arg rk(S) \\ S) a la derecha. La reserva rj(S) cubrirá los excesos a la izquierda y en el medio, mientras que la reserva rk(S) cubrirá los de la derecha y en el medio, por lo que los excesos en el medio se cuentan dos veces. Ajustamos por la doble contabilización restando los excesos en el medio de la suma de las dos reservas rj(S) y rk(S). Finalmente, cabe destacar que cada paso en el cálculo de los valores r de cada nodo i toma tiempo como máximo exponencial en el tamaño de Xi, por lo tanto, el algoritmo se ejecuta en tiempo exponencial solo en el treewidth del grafo. 5.4 Algoritmo para la No Vacuidad del Núcleo Podemos extender el algoritmo para la Membresía del Núcleo en un algoritmo para la No Vacuidad del Núcleo. Como se describe en la sección 2, si el núcleo está vacío se puede verificar utilizando el programa de optimización basado en la condición de equilibrio (3). Desafortunadamente, ese programa tiene un número exponencial de variables. Por otro lado, el dual del programa tiene solo n variables y puede escribirse de la siguiente manera: minimizar x∈Rn n i=1 xi sujeto a x(S) ≥ v(S), ∀S ⊆ N (7). Por dualidad fuerte, el valor óptimo de (7) es igual al valor óptimo de (4), el programa primal descrito en la sección 2. Por lo tanto, según el teorema de Bondareva-Shapley, si el valor óptimo de (7) es mayor que v(N), el núcleo está vacío. Podemos resolver el programa dual utilizando el método del elipsoide con Core-Membership como un oráculo de separación, es decir, un procedimiento para devolver una restricción que está violada. Ten en cuenta que una simple extensión al algoritmo de Membresía-Principal nos permitirá hacer un seguimiento del conjunto T para el cual e(T) < 0 durante el cálculo de los valores r, y por lo tanto podemos devolver la desigualdad sobre T como la restricción violada. Por lo tanto, Core-Non-Emptiness puede ejecutarse en tiempo polinómico en el tiempo de ejecución de Core-Membership, que a su vez se ejecuta en 200 veces exponencial solo en el treewidth del grafo. Ten en cuenta que cuando el núcleo no está vacío, este programa devolverá un resultado en el núcleo. 6. CONCLUSIONES FINALES\nHemos desarrollado un esquema de representación completamente expresivo para juegos coalicionales cuyo tamaño depende de la complejidad de las interacciones entre los agentes. Nuestro enfoque en la representación general contrasta con el enfoque adoptado en [3, 4]. También hemos desarrollado un algoritmo eficiente para el cálculo de los valores de Shapley para esta representación. Si bien la Membresía Central para redes MC es coNP-completa, hemos desarrollado un algoritmo para la Membresía Central que se ejecuta en tiempo exponencial solo en el treewidth del grafo de agentes. También hemos extendido el algoritmo para resolver la Core-No-Vacuidad. Aparte del algoritmo para la Core-No-Vacío en [4] bajo la restricción de pesos de aristas no negativos, y el de [2] para juegos superaditivos cuando se conoce el valor de la gran coalición, no tenemos conocimiento de ninguna descripción explícita de algoritmos para problemas relacionados con el núcleo en la literatura. El trabajo en este documento está relacionado con varias áreas en informática, especialmente en inteligencia artificial. Por ejemplo, la interpretación gráfica de las redes MC está estrechamente relacionada con los campos aleatorios de Markov (MRFs) de la comunidad de redes Bayes. Ambos abordan el tema de la concisión de la representación utilizando la estructura combinatoria de hipergrafos ponderados. De hecho, Kearns et al. primero aplican estas ideas a la teoría de juegos al introducir un esquema de representación derivado de la red de Bayes para representar juegos no cooperativos [6]. Los problemas de representación enfrentados en juegos coalicionales están estrechamente relacionados con el problema de expresar valoraciones en subastas combinatorias [5, 10]. El lenguaje OR-bid, por ejemplo, está fuertemente relacionado con la superaditividad. La cuestión del poder de representación de diferentes patrones también está relacionada con la complejidad de las expresiones booleanas [12]. Creemos que con una mejor comprensión de las relaciones entre estas áreas relacionadas, podríamos desarrollar representaciones y algoritmos más eficientes para juegos coalicionales. Finalmente, nos gustaría concluir con algunas ideas para ampliar el trabajo en este artículo. Una dirección para aumentar la concisión de las redes MC es permitir la definición de clases equivalentes de agentes, similar a la idea de extender las redes Bayes a modelos relacionales probabilísticos. El concepto de simetría es prevalente en los juegos, y el uso de clases de agentes nos permitirá capturar la simetría de forma natural y concisa. Esto también abordará el problema de representaciones asimétricas desagradables de juegos simétricos en nuestra representación. Siguiendo la línea de explotar la simetría, dado que los agentes dentro de la misma clase son simétricos entre sí, podemos extender la idea anterior permitiendo la descripción funcional de las contribuciones marginales. Más concretamente, podemos especificar el valor de una regla como dependiente del número de agentes de cada clase relevante. El uso de funciones permitirá una descripción concisa de los rendimientos marginales decrecientes (RMD). Sin el uso de funciones, el espacio necesario para describir MDRs entre n agentes en redes MC es O(n). Con el uso de funciones, el espacio requerido se puede reducir a O(1). Otra idea para extender las redes MC es aumentar la semántica para permitir construcciones que especifiquen que ciertas reglas no pueden aplicarse simultáneamente. Esto es útil en situaciones donde un cierto agente representa un tipo de recurso agotable, y por lo tanto las reglas que dependen de la presencia del agente no deben aplicarse simultáneamente. Por ejemplo, si el agente i en el sistema representa al carbón, podemos usarlo como combustible para una central eléctrica o como insumo para una acería para fabricar acero, pero no para ambas cosas al mismo tiempo. Actualmente, para representar tales situaciones, tenemos que especificar reglas para cancelar los efectos de la aplicación de diferentes reglas. La semántica aumentada puede simplificar la representación al especificar cuándo las reglas no pueden aplicarse juntas. 7. AGRADECIMIENTO Los autores desean agradecer a Chris Luhrs, Bob McGrew, Eugene Nudelman y Qixiang Sun por las discusiones fructíferas, y a los revisores anónimos por sus comentarios útiles sobre el artículo. 8. REFERENCIAS [1] H. L. Bodlaender. Anchura de árbol: Técnicas algorítmicas y resultados. En Actas del 22º Simposio sobre Fundamentos Matemáticos de la Ciencia de la Computación, páginas 19-36. Springer-Verlag LNCS 1295, 1997.\n[2] V. Conitzer and T. Sandholm. Complejidad de determinar la no vacuidad del núcleo. En Proc. 18th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 613-618, 2003. [3] V. Conitzer y T. Sandholm. Calculando los valores de Shapley, manipulando esquemas de división de valor y verificando la membresía del núcleo en dominios de múltiples problemas. En Proc. 19º Nat. Conf. sobre Inteligencia Artificial, páginas 219-225, 2004. [4] X. Deng y C. H. Papadimitriou. Sobre la complejidad de los conceptos de solución cooperativa. Matemáticas. Operación. Res., 19:257-266, mayo de 1994. [5] Y. Fujishima, K. Leyton-Brown y Y. Shoham. Domando la complejidad computacional de las subastas combinatorias: Enfoques óptimos y aproximados. En Proc. 16th Int. Conferencia Conjunta sobre Inteligencia Artificial, páginas 548-553, 1999. [6] M. Kearns, M. L. Littman y S. Singh. Modelos gráficos para teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, páginas 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou y P. Raghavan. Sobre el valor de la información privada. En Proc. 8ª Conf. sobre Aspectos Teóricos de la Racionalidad y el Conocimiento, páginas 249-257, 2001. [8] C. Li y K. Sycara. Algoritmos para la formación de coaliciones combinatorias y la división de pagos en un mercado electrónico. Informe técnico, Instituto de Robótica, Universidad Carnegie Mellon, noviembre de 2001. [9] A. Mas-Colell, M. D. Whinston y J. R. Green. Teoría microeconómica. Oxford University Press, Nueva York, 1995. [10] N. Nisan. Subasta y asignación en subastas combinatorias. En Proc. 2da Conf. ACM sobre Comercio Electrónico, páginas 1-12, 2000. [11] M. J. Osborne y A. Rubinstein. Un curso de Teoría de Juegos. The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener. La complejidad de las funciones booleanas. John Wiley & Sons, Nueva York, octubre de 1987.\n201 APÉNDICE\nMostraremos formalmente la corrección del cálculo del valor r en el Algoritmo 1 de introducir nodos y unir nodos. Lema 1. El procedimiento para calcular los valores de r de los nodos introducidos en el Algoritmo 1 es correcto. Prueba. Que el nodo m sea el agente recién introducido en i. Que U denote el conjunto de agentes en el subárbol con raíz en i. Por la propiedad de intersección en ejecución, todas las interacciones (los hiperarcos) entre m y U deben estar en el nodo i. Para todo S ⊆ Xi : m ∈ S, sea R el conjunto (U \\ Xi) ∪ S), y Q sea el conjunto (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) El argumento para conjuntos S ⊆ Xi : m /∈ S es simétrico excepto que xm no contribuirá a la reserva debido a la ausencia de m. Lema 2. El procedimiento para calcular los valores de r de los nodos de unión en el Algoritmo 1 es correcto. Prueba. Considera cualquier conjunto S ⊆ Xi. Que Uj denote el subárbol enraizado en el hijo izquierdo, Rj denote ((Uj \\ Xj) ∪ S), y Qj denote (Uj \\ Xj). Dejen que Uk, Rk y Qk se definan de manera análoga para el hijo derecho. Que R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) donde (*) es verdadero ya que T ∩ Qj y T ∩ Qk son disjuntos debido a la propiedad de intersección en ejecución de la descomposición de árbol, y por lo tanto el mínimo de la suma puede descomponerse en la suma de los mínimos. 202 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "representation": {
            "translated_key": "representación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Marginal Contribution Nets: A Compact <br>representation</br> Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This <br>representation</br> scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this <br>representation</br>.",
                "The Shapley value can be computed in time linear in the size of the input.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our <br>representation</br>.",
                "Categories and Subject Descriptors I.2.11 [Distributed Artificial Intelligence]: Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.2 [Analysis of Algorithms and Problem Complexity] General Terms Algorithms, Economics 1.",
                "INTRODUCTION Agents can often benefit by coordinating their actions.",
                "Coalitional games capture these opportunities of coordination by explicitly modeling the ability of the agents to take joint actions as primitives.",
                "As an abstraction, coalitional games assign a payoff to each group of agents in the game.",
                "This payoff is intended to reflect the payoff the group of agents can secure for themselves regardless of the actions of the agents not in the group.",
                "These choices of primitives are in contrast to those of non-cooperative games, of which agents are modeled independently, and their payoffs depend critically on the actions chosen by the other agents. 1.1 Coalitional Games and E-Commerce Coalitional games have appeared in the context of e-commerce.",
                "In [7], Kleinberg et al. use coalitional games to study recommendation systems.",
                "In their model, each individual knows about a certain set of items, is interested in learning about all items, and benefits from finding out about them.",
                "The payoffs to groups of agents are the total number of distinct items known by its members.",
                "Given this coalitional game setting, Kleinberg et al. compute the value of the private information of the agents is worth to the system using the solution concept of the Shapley value (definition can be found in section 2).",
                "These values can then be used to determine how much each agent should receive for participating in the system.",
                "As another example, consider the economics behind supply chain formation.",
                "The increased use of the Internet as a medium for conducting business has decreased the costs for companies to coordinate their actions, and therefore coalitional game is a good model for studying the supply chain problem.",
                "Suppose that each manufacturer purchases his raw materials from some set of suppliers, and that the suppliers offer higher discount with more purchases.",
                "The decrease in communication costs will let manufacturers find others interested in the same set of suppliers cheaper, and facilitates formation of coalitions to bargain with the suppliers.",
                "Depending on the set of suppliers and how much from each supplier each coalition purchases, we can assign payoffs to the coalitions depending on the discount it receives.",
                "The resulting game can be analyzed using coalitional game theory, and we can answer questions such as the stability of coalitions, and how to fairly divide the benefits among the participating manufacturers.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game <br>representation</br> To capture the coalitional games described above and perform computations on them, we must first find a <br>representation</br> for these games.",
                "The na¨ıve solution is to enumerate the payoffs to each set of agents, therefore requiring space 193 exponential in the number of agents in the game.",
                "For the two applications described, the number of agents in the system can easily exceed a hundred; this na¨ıve approach will not be scalable to such problems.",
                "Therefore, it is critical to find good <br>representation</br> schemes for coalitional games.",
                "We believe that the quality of a <br>representation</br> scheme should be evaluated by four criteria.",
                "Expressivity: the breadth of the class of coalitional games covered by the <br>representation</br>.",
                "Conciseness: the space requirement of the <br>representation</br>.",
                "Efficiency: the efficiency of the algorithms we can develop for the <br>representation</br>.",
                "Simplicity: the ease of use of the <br>representation</br> by users of the system.",
                "The ideal <br>representation</br> should be fully expressive, i.e., it should be able to represent any coalitional games, use as little space as possible, have efficient algorithms for computation, and be easy to use.",
                "The goal of this paper is to develop a <br>representation</br> scheme that has properties close to the ideal <br>representation</br>.",
                "Unfortunately, given that the number of degrees of freedom of coalitional games is O(2n ), not all games can be represented concisely using a single scheme due to information theoretic constraints.",
                "For any given class of games, one may be able to develop a <br>representation</br> scheme that is tailored and more compact than a general scheme.",
                "For example, for the recommendation system game, a highly compact <br>representation</br> would be one that simply states which agents know of which products, and let the algorithms that operate on the <br>representation</br> to compute the values of coalitions appropriately.",
                "For some problems, however, there may not be efficient algorithms for customized representations.",
                "By having a general <br>representation</br> and efficient algorithms that go with it, the <br>representation</br> will be useful as a prototyping tool for studying new economic situations. 1.3 Previous Work The question of coalitional game representation has only been sparsely explored in the past [2, 3, 4].",
                "In [4], Deng and Papadimitriou focused on the complexity of different solution concepts on coalitional games defined on graphs.",
                "While the <br>representation</br> is compact, it is not fully expressive.",
                "In [2], Conitzer and Sandholm looked into the problem of determining the emptiness of the core in superadditive games.",
                "They developed a compact <br>representation</br> scheme for such games, but again the <br>representation</br> is not fully expressive either.",
                "In [3], Conitzer and Sandholm developed a fully expressive <br>representation</br> scheme based on decomposition.",
                "Our work extends and generalizes the <br>representation</br> schemes in [3, 4] through decomposing the game into a set of rules that assign marginal contributions to groups of agents.",
                "We will give a more detailed review of these papers in section 2.2 after covering the technical background. 1.4 Summary of Our Contributions • We develop the marginal contribution networks <br>representation</br>, a fully expressive <br>representation</br> scheme whose size scales according to the complexity of the interactions among the agents.",
                "We believe that the <br>representation</br> is also simple and intuitive. • We develop an algorithm for computing the Shapley value of coalitional games under this <br>representation</br> that runs in time linear in the size of the input. • Under the graphical interpretation of the representation, we develop an algorithm for determining the whether a payoff vector is in the core and the emptiness of the core in time exponential only in the treewidth of the graph. 2.",
                "PRELIMINARIES In this section, we will briefly review the basics of coalitional game theory and its two primary solution concepts, the Shapley value and the core.1 We will also review previous work on coalitional game <br>representation</br> in more detail.",
                "Throughout this paper, we will assume that the payoff to a group of agents can be freely distributed among its members.",
                "This assumption is often known as the transferable utility assumption. 2.1 Technical Background We can represent a coalition game with transferable utility by the pair N, v , where • N is the set of agents; and • v : 2N → R is a function that maps each group of agents S ⊆ N to a real-valued payoff.",
                "This <br>representation</br> is known as the characteristic form.",
                "As there are exponentially many subsets, it will take space exponential in the number of agents to describe a coalitional game.",
                "An outcome in a coalitional game specifies the utilities the agents receive.",
                "A solution concept assigns to each coalitional game a set of reasonable outcomes.",
                "Different solution concepts attempt to capture in some way outcomes that are stable and/or fair.",
                "Two of the best known solution concepts are the Shapley value and the core.",
                "The Shapley value is a normative solution concept.",
                "It prescribes a fair way to divide the gains from cooperation when the grand coalition (i.e., N) is formed.",
                "The division of payoff to agent i is the average marginal contribution of agent i over all possible permutations of the agents.",
                "Formally, let φi(v) denote the Shapley value of i under characteristic function v, then2 φi(v) = S⊂N s! (n − s − 1)! n! (v(S ∪ {i}) − v(S)) (1) The Shapley value is a solution concept that satisfies many nice properties, and has been studied extensively in the economic and game theoretic literature.",
                "It has a very useful axiomatic characterization.",
                "Efficiency (EFF) A total of v(N) is distributed to the agents, i.e., i∈N φi(v) = v(N).",
                "Symmetry (SYM) If agents i and j are interchangeable, then φi(v) = φj(v). 1 The materials and terminology are based on the textbooks by Mas-Colell et al. [9] and Osborne and Rubinstein [11]. 2 As a notational convenience, we will use the lower-case letter to represent the cardinality of a set denoted by the corresponding upper-case letter. 194 Dummy (DUM) If agent i is a dummy player, i.e., his marginal contribution to all groups S are the same, φi(v) = v({i}).",
                "Additivity (ADD) For any two coalitional games v and w defined over the same set of agents N, φi(v + w) = φi(v) + φi(w) for all i ∈ N, where the game v + w is defined as (v + w)(S) = v(S) + w(S) for all S ⊆ N. We will refer to these axioms later in our proof of correctness of the algorithm for computing the Shapley value under our <br>representation</br> in section 4.",
                "The core is another major solution concept for coalitional games.",
                "It is a descriptive solution concept that focuses on outcomes that are stable.",
                "Stability under core means that no set of players can jointly deviate to improve their payoffs.",
                "Formally, let x(S) denote i∈S xi.",
                "An outcome x ∈ Rn is in the core if ∀S ⊆ N x(S) ≥ v(S) (2) The core was one of the first proposed solution concepts for coalitional games, and had been studied in detail.",
                "An important question for a given coalitional game is whether the core is empty.",
                "In other words, whether there is any outcome that is stable relative to group deviation.",
                "For a game to have a non-empty core, it must satisfy the property of balancedness, defined as follows.",
                "Let 1S ∈ Rn denote the characteristic vector of S given by (1S)i = 1 if i ∈ S 0 otherwise Let (λS)S⊆N be a set of weights such that each λS is in the range between 0 and 1.",
                "This set of weights, (λS)S⊆N , is a balanced collection if for all i ∈ N, S⊆N λS(1S)i = 1 A game is balanced if for all balanced collections of weights, S⊆N λSv(S) ≤ v(N) (3) By the Bondereva-Shapley theorem, the core of a coalitional game is non-empty if and only if the game is balanced.",
                "Therefore, we can use linear programming to determine whether the core of a game is empty. maximize λ∈R2n S⊆N λSv(S) subject to S⊆N λS1S = 1 ∀i ∈ N λS ≥ 0 ∀S ⊆ N (4) If the optimal value of (4) is greater than the value of the grand coalition, then the core is empty.",
                "Unfortunately, this program has an exponential number of variables in the number of players in the game, and hence an algorithm that operates directly on this program would be infeasible in practice.",
                "In section 5.4, we will describe an algorithm that answers the question of emptiness of core that works on the dual of this program instead. 2.2 Previous Work Revisited Deng and Papadimitriou looked into the complexity of various solution concepts on coalitional games played on weighted graphs in [4].",
                "In their <br>representation</br>, the set of agents are the nodes of the graph, and the value of a set of agents S is the sum of the weights of the edges spanned by them.",
                "Notice that this <br>representation</br> is concise since the space required to specify such a game is O(n2 ).",
                "However, this <br>representation</br> is not general; it will not be able to represent interactions among three or more agents.",
                "For example, it will not be able to represent the majority game, where a group of agents S will have value of 1 if and only if s > n/2.",
                "On the other hand, there is an efficient algorithm for computing the Shapley value of the game, and for determining whether the core is empty under the restriction of positive edge weights.",
                "However, in the unrestricted case, determining whether the core is non-empty is coNP-complete.",
                "Conitzer and Sandholm in [2] considered coalitional games that are superadditive.",
                "They described a concise <br>representation</br> scheme that only states the value of a coalition if the value is strictly superadditive.",
                "More precisely, the semantics of the <br>representation</br> is that for a group of agents S, v(S) = max {T1,T2,...,Tn}∈Π i v(Ti) where Π is the set of all possible partitions of S. The value v(S) is only explicitly specified for S if v(S) is greater than all partitioning of S other than the trivial partition ({S}).",
                "While this <br>representation</br> can represent all games that are superadditive, there are coalitional games that it cannot represent.",
                "For example, it will not be able to represent any games with substitutability among the agents.",
                "An example of a game that cannot be represented is the unit game, where v(S) = 1 as long as S = ∅.",
                "Under this <br>representation</br>, the authors showed that determining whether the core is non-empty is coNP-complete.",
                "In fact, even determining the value of a group of agents is NP-complete.",
                "In a more recent paper, Conitzer and Sandholm described a <br>representation</br> that decomposes a coalitional game into a number of subgames whose sum add up to the original game [3].",
                "The payoffs in these subgames are then represented by their respective characteristic functions.",
                "This scheme is fully general as the characteristic form is a special case of this <br>representation</br>.",
                "For any given game, there may be multiple ways to decompose the game, and the decomposition may influence the computational complexity.",
                "For computing the Shapley value, the authors showed that the complexity is linear in the input description; in particular, if the largest subgame (as measured by number of agents) is of size n and the number of subgames is m, then their algorithm runs in O(m2n ) time, where the input size will also be O(m2n ).",
                "On the other hand, the problem of determining whether a certain outcome is in the core is coNP-complete. 3.",
                "MARGINAL CONTRIBUTION NETS In this section, we will describe the Marginal Contribution Networks <br>representation</br> scheme.",
                "We will show that the idea is flexible, and we can easily extend it to increase its conciseness.",
                "We will also show how we can use this scheme to represent the recommendation game from the introduction.",
                "Finally, we will show that this scheme is fully expressive, and generalizes the <br>representation</br> schemes in [3, 4]. 3.1 Rules and MarginalContributionNetworks The basic idea behind marginal contribution networks (MC-nets) is to represent coalitional games using sets of rules.",
                "The rules in MC-nets have the following syntactic 195 form: Pattern → value A rule is said to apply to a group of agents S if S meets the requirement of the Pattern.",
                "In the basic scheme, these patterns are conjunctions of agents, and S meets the requirement of the given pattern if S is a superset of it.",
                "The value of a group of agents is defined to be the sum over the values of all rules that apply to the group.",
                "For example, if the set of rules are {a ∧ b} → 5 {b} → 2 then v({a}) = 0, v({b}) = 2, and v({a, b}) = 5 + 2 = 7.",
                "MC-nets is a very flexible <br>representation</br> scheme, and can be extended in different ways.",
                "One simple way to extend it and increase its conciseness is to allow a wider class of patterns in the rules.",
                "A pattern that we will use throughout the remainder of the paper is one that applies only in the absence of certain agents.",
                "This is useful for expressing concepts such as substitutability or default values.",
                "Formally, we express such patterns by {p1 ∧ p2 ∧ . . . ∧ pm ∧ ¬n1 ∧ ¬n2 ∧ . . . ∧ ¬nn} which has the semantics that such rule will apply to a group S only if {pi}m i=1 ∈ S and {nj}n j=1 /∈ S. We will call the {pi}m i=1 in the above pattern the positive literals, and {nj}n j=1 the negative literals.",
                "Note that if the pattern of a rule consists solely of negative literals, we will consider that the empty set of agents will also satisfy such pattern, and hence v(∅) may be non-zero in the presence of negative literals.",
                "To demonstrate the increase in conciseness of <br>representation</br>, consider the unit game described in section 2.2.",
                "To represent such a game without using negative literals, we will need 2n rules for n players: we need a rule of value 1 for each individual agent, a rule of value −1 for each pair of agents to counter the double-counting, a rule of value 1 for each triplet of agents, etc., similar to the inclusion-exclusion principle.",
                "On the other hand, using negative literals, we only need n rules: value 1 for the first agent, value 1 for the second agent in the absence of the first agent, value 1 for the third agent in the absence of the first two agents, etc.",
                "The representational savings can be exponential in the number of agents.",
                "Given a game represented as a MC-net, we can interpret the set of rules that make up the game as a graph.",
                "We call this graph the agent graph.",
                "The nodes in the graph will represent the agents in the game, and for each rule in the MCnet, we connect all the agents in the rule together and assign a value to the clique formed by the set of agents.",
                "Notice that to accommodate negative literals, we will need to annotate the clique appropriately.",
                "This alternative view of MC-nets will be useful in our algorithm for Core-Membership in section 5.",
                "We would like to end our discussion of the <br>representation</br> scheme by mentioning a trade-off between the expressiveness of patterns and the space required to represent them.",
                "To represent a coalitional game in characteristic form, one would need to specify all 2n − 1 values.",
                "There is no overhead on top of that since there is a natural ordering of the groups.",
                "For MC-nets, however, specification of the rules requires specifying both the patterns and the values.",
                "The patterns, if not represented compactly, may end up overwhelming the savings from having fewer values to specify.",
                "The space required for the patterns also leads to a tradeoff between the expressiveness of the allowed patterns and the simplicity of representing them.",
                "However, we believe that for most naturally arising games, there should be sufficient structure in the problem such that our <br>representation</br> achieves a net saving over the characteristic form. 3.2 Example: Recommendation Game As an example, we will use MC-net to represent the recommendation game discussed in the introduction.",
                "For each product, as the benefit of knowing about the product will count only once for each group, we need to capture substitutability among the agents.",
                "This can be captured by a scaled unit game.",
                "Suppose the value of the knowledge about product i is vi, and there are ni agents, denoted by {xj i }, who know about the product, the game for product i can then be represented as the following rules: {x1 i } → vi {x2 i ∧ ¬x1 i } → vi ... {xni i ∧ ¬xni−1 i ∧ · · · ∧ ¬x1 i } → vi The entire game can then be built up from the sets of rules of each product.",
                "The space requirement will be O(mn∗ ), where m is the number of products in the system, and n∗ is the maximum number of agents who knows of the same product. 3.3 <br>representation</br> Power We will discuss the expressiveness and conciseness of our <br>representation</br> scheme and compare it with the previous works in this subsection.",
                "Proposition 1.",
                "Marginal contribution networks constitute a fully expressive <br>representation</br> scheme.",
                "Proof.",
                "Consider an arbitrary coalitional game N, v in characteristic form <br>representation</br>.",
                "We can construct a set of rules to describe this game by starting from the singleton sets and building up the set of rules.",
                "For any singleton set {i}, we create a rule {i} → v(i).",
                "For any pair of agents {i, j}, we create a rule {i ∧ j} → v({i, j}) − v({i}) − v({j}.",
                "We can continue to build up rules in a manner similar to the inclusion-exclusion principle.",
                "Since the game is arbitrary, MC-nets are fully expressive.",
                "Using the construction outlined in the proof, we can show that our <br>representation</br> scheme can simulate the multi-issue <br>representation</br> scheme of [3] in almost the same amount of space.",
                "Proposition 2.",
                "Marginal contribution networks use at most a linear factor (in the number of agents) more space than multi-issue <br>representation</br> for any game.",
                "Proof.",
                "Given a game in multi-issue <br>representation</br>, we start by describing each of the subgames, which are represented in characteristic form in [3], with a set of rules. 196 We then build up the grand game by including all the rules from the subgames.",
                "Note that our <br>representation</br> may require a space larger by a linear factor due to the need to describe the patterns for each rule.",
                "On the other hand, our approach may have fewer than exponential number of rules for each subgame, depending on the structure of these subgames, and therefore may be more concise than multi-issue <br>representation</br>.",
                "On the other hand, there are games that require exponentially more space to represent under the multi-issue scheme compared to our scheme.",
                "Proposition 3.",
                "Marginal contribution networks are exponentially more concise than multi-issue <br>representation</br> for certain games.",
                "Proof.",
                "Consider a unit game over all the agents N. As explained in 3.1, this game can be represented in linear space using MC-nets with negative literals.",
                "However, as there is no decomposition of this game into smaller subgames, it will require space O(2n ) to represent this game under the multiissue <br>representation</br>.",
                "Under the agent graph interpretation of MC-nets, we can see that MC-nets is a generalization of the graphical <br>representation</br> in [4], namely from weighted graphs to weighted hypergraphs.",
                "Proposition 4.",
                "Marginal contribution networks can represent any games in graphical form (under [4]) in the same amount of space.",
                "Proof.",
                "Given a game in graphical form, G, for each edge (i, j) with weight wij in the graph, we create a rule {i, j} → wij.",
                "Clearly this takes exactly the same space as the size of G, and by the additive semantics of the rules, it represents the same game as G. 4.",
                "COMPUTING THE SHAPLEY VALUE Given a MC-net, we have a simple algorithm to compute the Shapley value of the game.",
                "Considering each rule as a separate game, we start by computing the Shapley value of the agents for each rule.",
                "For each agent, we then sum up the Shapley values of that agent over all the rules.",
                "We first show that this final summing process correctly computes the Shapley value of the agents.",
                "Proposition 5.",
                "The Shapley value of an agent in a marginal contribution network is equal to the sum of the Shapley values of that agent over each rule.",
                "Proof.",
                "For any group S, under the MC-nets <br>representation</br>, v(S) is defined to be the sum over the values of all the rules that apply to S. Therefore, considering each rule as a game, by the (ADD) axiom discussed in section 2, the Shapley value of the game created from aggregating all the rules is equal to the sum of the Shapley values over the rules.",
                "The remaining question is how to compute the Shapley values of the rules.",
                "We can separate the analysis into two cases, one for rules with only positive literals and one for rules with mixed literals.",
                "For rules that have only positive literals, the Shapley value of the agents is v/m, where v is the value of the rule and m is the number of agents in the rule.",
                "This is a direct consequence of the (SYM) axiom of the Shapley value, as the agents in a rule are indistinguishable from each other.",
                "For rules that have both positive and negative literals, we can consider the positive and the negative literals separately.",
                "For a given positive literal i, the rule will apply only if i occurs in a given permutation after the rest of the positive literals but before any of the negative literals.",
                "Formally, let φi denote the Shapley value of i, p denote the cardinality of the positive set, and n denote the cardinality of the negative set, then φi = (p − 1)!n! (p + n)! v = v p p+n n For a given negative literal j, j will be responsible for cancelling the application of the rule if all positive literals come before the negative literals in the ordering, and j is the first among the negative literals.",
                "Therefore, φj = p! (n − 1)! (p + n)! (−v) = −v n p+n p By the (SYM) axiom, all positive literals will have the value of φi and all negative literals will have the value of φj.",
                "Note that the sum over all agents in rules with mixed literals is 0.",
                "This is to be expected as these rules contribute 0 to the grand coalition.",
                "The fact that these rules have no effect on the grand coalition may appear odd at first.",
                "But this is because the presence of such rules is to define the values of coalitions smaller than the grand coalition.",
                "In terms of computational complexity, given that the Shapley value of any agent in a given rule can be computed in time linear in the pattern of the rule, the total running time of the algorithm for computing the Shapley value of the game is linear in the size of the input. 5.",
                "ANSWERING CORE-RELATED QUESTIONS There are a few different but related computational problems associated with the solution concept of the core.",
                "We will focus on the following two problems: Definition 1. (Core-Membership) Given a coalitional game and a payoff vector x, determine if x is in the core.",
                "Definition 2. (Core-Non-Emptiness) Given a coalitional game, determine if the core is non-empty.",
                "In the rest of the section, we will first show that these two problems are coNP-complete and coNP-hard respectively, and discuss some complexity considerations about these problems.",
                "We will then review the main ideas of tree decomposition as it will be used extensively in our algorithm for Core-Membership.",
                "Next, we will present the algorithm for Core-Membership, and show that the algorithm runs in polynomial time for graphs of bounded treewidth.",
                "We end by extending this algorithm to answer the question of CoreNon-Emptiness in polynomial time for graphs of bounded treewidth. 5.1 Computational Complexity The hardness of Core-Membership and Core-NonEmptiness follows directly from the hardness results of games over weighted graphs in [4]. 197 Proposition 6.",
                "Core-Membership for games represented as marginal contribution networks is coNP-complete.",
                "Proof.",
                "Core-Membership in MC-nets is in the class of coNP since any set of agents S of which v(S) > x(S) will serve as a certificate to show that x does not belong to the core.",
                "As for its hardness, given any instance of CoreMembership for a game in graphical form of [4], we can encode the game in exactly the same space using MC-net due to Proposition 4.",
                "Since Core-Membership for games in graphical form is coNP-complete, Core-Membership in MC-nets is coNP-hard.",
                "Proposition 7.",
                "Core-Non-Emptiness for games represented as marginal contribution networks is coNP-hard.",
                "Proof.",
                "The same argument for hardness between games in graphical frm and MC-nets holds for the problem of CoreNon-Emptiness.",
                "We do not know of a certificate to show that Core-NonEmptiness is in the class of coNP as of now.",
                "Note that the obvious certificate of a balanced set of weights based on the Bondereva-Shapley theorem is exponential in size.",
                "In [4], Deng and Papadimitriou showed the coNP-completeness of Core-Non-Emptiness via a combinatorial characterization, namely that the core is non-empty if and only if there is no negative cut in the graph.",
                "In MC-nets, however, there need not be a negative hypercut in the graph for the core to be empty, as demonstrated by the following game (N = {1, 2, 3, 4}): v(S) =    1 if S = {1, 2, 3, 4} 3/4 if S = {1, 2}, {1, 3}, {1, 4}, or {2, 3, 4} 0 otherwise (5) Applying the Bondereva-Shapley theorem, if we let λ12 = λ13 = λ14 = 1/3, and λ234 = 2/3, this set of weights demonstrates that the game is not balanced, and hence the core is empty.",
                "On the other hand, this game can be represented with MC-nets as follows (weights on hyperedges): w({1, 2}) = w({1, 3}) = w({1, 4}) = 3/4 w({1, 2, 3}) = w({1, 2, 4}) = w({1, 3, 4}) = −6/4 w({2, 3, 4}) = 3/4 w({1, 2, 3, 4}) = 10/4 No matter how the set is partitioned, the sum over the weights of the hyperedges in the cut is always non-negative.",
                "To overcome the computational hardness of these problems, we have developed algorithms that are based on tree decomposition techniques.",
                "For Core-Membership, our algorithm runs in time exponential only in the treewidth of the agent graph.",
                "Thus, for graphs of small treewidth, such as trees, we have a tractable solution to determine if a payoff vector is in the core.",
                "By using this procedure as a separation oracle, i.e., a procedure for returning the inequality violated by a candidate solution, to solving a linear program that is related to Core-Non-Emptiness using the ellipsoid method, we can obtain a polynomial time algorithm for Core-Non-Emptiness for graphs of bounded treewidth. 5.2 Review of Tree Decomposition As our algorithm for Core-Membership relies heavily on tree decomposition, we will first briefly review the main ideas in tree decomposition and treewidth.3 Definition 3.",
                "A tree decomposition of a graph G = (V, E) is a pair (X, T), where T = (I, F) is a tree and X = {Xi | i ∈ I} is a family of subsets of V , one for each node of T, such that • i∈I Xi = V ; • For all edges (v, w) ∈ E, there exists an i ∈ I with v ∈ Xi and w ∈ Xi; and • (Running Intersection Property) For all i, j, k ∈ I: if j is on the path from i to k in T, then Xi ∩ Xk ⊆ Xj.",
                "The treewidth of a tree decomposition is defined as the maximum cardinality over all sets in X, less one.",
                "The treewidth of a graph is defined as the minimum treewidth over all tree decompositions of the graph.",
                "Given a tree decomposition, we can convert it into a nice tree decomposition of the same treewidth, and of size linear in that of T. Definition 4.",
                "A tree decomposition T is nice if T is rooted and has four types of nodes: Leaf nodes i are leaves of T with |Xi| = 1.",
                "Introduce nodes i have one child j such that Xi = Xj ∪ {v} of some v ∈ V .",
                "Forget nodes i have one child j such that Xi = Xj \\ {v} for some v ∈ Xj.",
                "Join nodes i have two children j and k with Xi = Xj = Xk.",
                "An example of a (partial) nice tree decomposition together with a classification of the different types of nodes is in Figure 1.",
                "In the following section, we will refer to nodes in the tree decomposition as nodes, and nodes in the agent graph as agents. 5.3 Algorithm for Core Membership Our algorithm for Core-Membership takes as an input a nice tree decomposition T of the agent graph and a payoff vector x.",
                "By definition, if x belongs to the core, then for all groups S ⊆ N, x(S) ≥ v(S).",
                "Therefore, the difference x(S)−v(S) measures how close the group S is to violating the core condition.",
                "We call this difference the excess of group S. Definition 5.",
                "The excess of a coalition S, e(S), is defined as x(S) − v(S).",
                "A brute-force approach to determine if a payoff vector belongs to the core will have to check that the excesses of all groups are non-negative.",
                "However, this approach ignores the structure in the agent graph that will allow an algorithm to infer that certain groups have non-negative excesses due to 3 This is based largely on the materials from a survey paper by Bodlaender [1]. 198 i j k l nm Introduce Node: Xj = {1, 4} Xk = {1, 4} Forget Node: Xl = {1, 4} Introduce Node: Xm = {1, 2, 4} Xn = {4} Leaf Node: Join Node: Xi = {1, 3, 4} Join Node: Figure 1: Example of a (partial) nice tree decomposition the excesses computed elsewhere in the graph.",
                "Tree decomposition is the key to take advantage of such inferences in a structured way.",
                "For now, let us focus on rules with positive literals.",
                "Suppose we have already checked that the excesses of all sets R ⊆ U are non-negative, and we would like to check if the addition of an agent i to the set U will create a group with negative excess.",
                "A na¨ıve solution will be to compute the excesses of all sets that include i.",
                "The excess of the group (R ∪ {i}) for any group R can be computed as follows e(R ∪ {i}) = e(R) + xi − v(c) (6) where c is the cut between R and i, and v(c) is the sum of the weights of the edges in the cut.",
                "However, suppose that from the tree decomposition, we know that i is only connected to a subset of U, say S, which we will call the entry set to U.",
                "Ideally, because i does not share any edges with members of ¯U = (U \\ S), we would hope that an algorithm can take advantage of this structure by checking only sets that are subsets of (S ∪ {i}).",
                "This computational saving may be possible since (xi −v(c)) in the update equation of (6) does not depend on ¯U.",
                "However, we cannot simply ignore ¯U as members of ¯U may still influence the excesses of groups that include agent i through group S. Specifically, if there exists a group T ⊃ S such that e(T) < e(S), then even when e(S ∪ {i}) has non-negative excess, e(T ∪{i}) may have negative excess.",
                "In other words, the excess available at S may have been drained away due to T. This motivates the definition of the reserve of a group.",
                "Definition 6.",
                "The reserve of a coalition S relative to a coalition U is the minimum excess over all coalitions between S and U, i.e., all T : S ⊆ T ⊆ U.",
                "We denote this value by r(S, U).",
                "We will refer to the group T that has the minimum excess as arg r(S, U).",
                "We will also call U the limiting set of the reserve and S the base set of the reserve.",
                "Our algorithm works by keeping track of the reserves of all non-empty subsets that can be formed by the agents of a node at each of the nodes of the tree decomposition.",
                "Starting from the leaves of the tree and working towards the root, at each node i, our algorithm computes the reserves of all groups S ⊆ Xi, limited by the set of agents in the subtree rooted at i, Ti, except those in (Xi\\S).",
                "The agents in (Xi\\S) are excluded to ensure that S is an entry set.",
                "Specifically, S is the entry set to ((Ti \\ Xi) ∪ S).",
                "To accomodate for negative literals, we will need to make two adjustments.",
                "Firstly, the cut between an agent m and a set S at node i now refers to the cut among agent m, set S, and set ¬(Xi \\ S), and its value must be computed accordingly.",
                "Also, when an agent m is introduced to a group at an introduce node, we will also need to consider the change in the reserves of groups that do not include m due to possible cut involving ¬m and the group.",
                "As an example of the reserve values we keep track of at a tree node, consider node i of the tree in Figure 1.",
                "At node i, we will keep track of the following: r({1}, {1, 2, . . .}) r({3}, {2, 3, . . .}) r({4}, {2, 4, . . .}) r({1, 3}, {1, 2, 3, . . .}) r({1, 4}, {1, 2, 4, . . .}) r({3, 4}, {2, 3, 4, . . .}) r({1, 3, 4}, {1, 2, 3, 4, . . .} where the dots . . . refer to the agents rooted under node m. For notational use, we will use ri(S) to denote r(S, U) at node i where U is the set of agents in the subtree rooted at node i excluding agents in (Xi \\ S).",
                "We sometimes refer to these values as the r-values of a node.",
                "The details of the r-value computations are in Algorithm 1.",
                "To determine if the payoff vector x is in the core, during the r-value computation at each node, we can check if all of the r-values are non-negative.",
                "If this is so for all nodes in the tree, the payoff vector x is in the core.",
                "The correctness of the algorithm is due to the following proposition.",
                "Proposition 8.",
                "The payoff vector x is not in the core if and only if the r-values at some node i for some group S is negative.",
                "Proof. (⇐) If the reserve at some node i for some group S is negative, then there exists a coalition T for which e(T) = x(T) − v(T) < 0, hence x is not in the core. (⇒) Suppose x is not in the core, then there exists some group R∗ such that e(R∗ ) < 0.",
                "Let Xroot be the set of nodes at the root.",
                "Consider any set S ∈ Xroot, rroot(S) will have the base set of S and the limiting set of ((N \\ Xroot) ∪ S).",
                "The union over all of these ranges includes all sets U for which U ∩ Xroot = ∅.",
                "Therefore, if R∗ is not disjoint from Xroot, the r-value for some group in the root is negative.",
                "If R∗ is disjoint from U, consider the forest {Ti} resulting from removal of all tree nodes that include agents in Xroot. 199 Algorithm 1 Subprocedures for Core Membership Leaf-Node(i) 1: ri(Xi) ← e(Xi) Introduce-Node(i) 2: j ← child of i 3: m ← Xi \\ Xj {the introduced node} 4: for all S ⊆ Xj, S = ∅ do 5: C ← all hyperedges in the cut of m, S, and ¬(Xi \\ S) 6: ri(S ∪ {x}) ← rj(S) + xm − v(C) 7: C ← all hyperedges in the cut of ¬m, S, and ¬(Xi \\S) 8: ri(S) ← rj(S) − v(C) 9: end for 10: r({m}) ← e({m}) Forget-Node(i) 11: j ← child of i 12: m ← Xj \\ Xi {the forgotten node} 13: for all S ⊆ Xi, S = ∅ do 14: ri(S) = min(rj(S), rj(S ∪ {m})) 15: end for Join-Node(i) 16: {j, k} ← {left, right} child of i 17: for all S ⊆ Xi, S = ∅ do 18: ri(S) ← rj(S) + rk(S) − e(S) 19: end for By the running intersection property, the sets of nodes in the trees Tis are disjoint.",
                "Thus, if the set R∗ = i Si for some Si ∈ Ti, e(R∗ ) = i e(Si) < 0 implies some group S∗ i has negative excess as well.",
                "Therefore, we only need to check the r-values of the nodes on the individual trees in the forest.",
                "But for each tree in the forest, we can apply the same argument restricted to the agents in the tree.",
                "In the base case, we have the leaf nodes of the original tree decomposition, say, for agent i.",
                "If R∗ = {i}, then r({i}) = e({i}) < 0.",
                "Therefore, by induction, if e(R∗ ) < 0, some reserve at some node would be negative.",
                "We will next explain the intuition behind the correctness of the computations for the r-values in the tree nodes.",
                "A detailed proof of correctness of these computations can be found in the appendix under Lemmas 1 and 2.",
                "Proposition 9.",
                "The procedure in Algorithm 1 correctly compute the r-values at each of the tree nodes.",
                "Proof. (Sketch) We can perform a case analysis over the four types of tree nodes in a nice tree decomposition.",
                "Leaf nodes (i) The only reserve value to be computed is ri(Xi), which equals r(Xi, Xi), and therefore it is just the excess of group Xi.",
                "Forget nodes (i with child j) Let m be the forgotten node.",
                "For any subset S ⊆ Xi, arg ri(S) must be chosen between the groups of S and S ∪ {m}, and hence we choose between the lower of the two from the r-values at node j.",
                "Introduce nodes (i with child j) Let m be the introduced node.",
                "For any subset T ⊆ Xi that includes m, let S denote (T \\ {m}).",
                "By the running intersection property, there are no rules that involve m and agents of the subtree rooted at node i except those involving m and agents in Xi.",
                "As both the base set and the limiting set of the r-values of node j and node i differ by {m}, for any group V that lies between the base set and the limiting set of node i, the excess of group V will differ by a constant amount from the corresponding group (V \\ {m}) at node j.",
                "Therefore, the set arg ri(T) equals the set arg rj(S) ∪ {m}, and ri(T) = rj(S) + xm − v(cut), where v(cut) is the value of the rules in the cut between m and S. For any subset S ⊂ Xi that does not include m, we need to consider the values of rules that include ¬m as a literal in the pattern.",
                "Also, when computing the reserve, the payoff xm will not contribute to group S. Therefore, together with the running intersection property as argued above, we can show that ri(S) = rj(S) − v(cut).",
                "Join nodes (i with left child j and right child k) For any given set S ⊆ Xi, consider the r-values of that set at j and k. If arg rj(S) or arg rk(S) includes agents not in S, then argrj(S) and argrk(S) will be disjoint from each other due to the running intersection property.",
                "Therefore, we can decompose arg ri(S) into three sets, (arg rj(S) \\ S) on the left, S in the middle, and (arg rk(S) \\ S) on the right.",
                "The reserve rj(S) will cover the excesses on the left and in the middle, whereas the reserve rk(S) will cover those on the right and in the middle, and so the excesses in the middle is double-counted.",
                "We adjust for the double-counting by subtracting the excesses in the middle from the sum of the two reserves rj(S) and rk(S).",
                "Finally, note that each step in the computation of the rvalues of each node i takes time at most exponential in the size of Xi, hence the algorithm runs in time exponential only in the treewidth of the graph. 5.4 Algorithm for Core Non-emptiness We can extend the algorithm for Core-Membership into an algorithm for Core-Non-Emptiness.",
                "As described in section 2, whether the core is empty can be checked using the optimization program based on the balancedness condition (3).",
                "Unfortunately, that program has an exponential number of variables.",
                "On the other hand, the dual of the program has only n variables, and can be written as follows: minimize x∈Rn n i=1 xi subject to x(S) ≥ v(S), ∀S ⊆ N (7) By strong duality, optimal value of (7) is equal to optimal value of (4), the primal program described in section 2.",
                "Therefore, by the Bondereva-Shapley theorem, if the optimal value of (7) is greater than v(N), the core is empty.",
                "We can solve the dual program using the ellipsoid method with Core-Membership as a separation oracle, i.e., a procedure for returning a constraint that is violated.",
                "Note that a simple extension to the Core-Membership algorithm will allow us to keep track of the set T for which e(T) < 0 during the r-values computation, and hence we can return the inequality about T as the constraint violated.",
                "Therefore, Core-Non-Emptiness can run in time polynomial in the running time of Core-Membership, which in turn runs in 200 time exponential only in the treewidth of the graph.",
                "Note that when the core is not empty, this program will return an outcome in the core. 6.",
                "CONCLUDING REMARKS We have developed a fully expressive <br>representation</br> scheme for coalitional games of which the size depends on the complexity of the interactions among the agents.",
                "Our focus on general <br>representation</br> is in contrast to the approach taken in [3, 4].",
                "We have also developed an efficient algorithm for the computation of the Shapley values for this <br>representation</br>.",
                "While Core-Membership for MC-nets is coNP-complete, we have developed an algorithm for CoreMembership that runs in time exponential only in the treewidth of the agent graph.",
                "We have also extended the algorithm to solve Core-Non-Emptiness.",
                "Other than the algorithm for Core-Non-Emptiness in [4] under the restriction of non-negative edge weights, and that in [2] for superadditive games when the value of the grand coalition is given, we are not aware of any explicit description of algorithms for core-related problems in the literature.",
                "The work in this paper is related to a number of areas in computer science, especially in artificial intelligence.",
                "For example, the graphical interpretation of MC-nets is closely related to Markov random fields (MRFs) of the Bayes nets community.",
                "They both address the issue of of conciseness of <br>representation</br> by using the combinatorial structure of weighted hypergraphs.",
                "In fact, Kearns et al. first apply these idea to games theory by introducing a <br>representation</br> scheme derived from Bayes net to represent non-cooperative games [6].",
                "The representational issues faced in coalitional games are closely related to the problem of expressing valuations in combinatorial auctions [5, 10].",
                "The OR-bid language, for example, is strongly related to superadditivity.",
                "The question of the <br>representation</br> power of different patterns is also related to Boolean expression complexity [12].",
                "We believe that with a better understanding of the relationships among these related areas, we may be able to develop more efficient representations and algorithms for coalitional games.",
                "Finally, we would like to end with some ideas for extending the work in this paper.",
                "One direction to increase the conciseness of MC-nets is to allow the definition of equivalent classes of agents, similar to the idea of extending Bayes nets to probabilistic relational models.",
                "The concept of symmetry is prevalent in games, and the use of classes of agents will allow us to capture symmetry naturally and concisely.",
                "This will also address the problem of unpleasing assymetric representations of symmetric games in our <br>representation</br>.",
                "Along the line of exploiting symmetry, as the agents within the same class are symmetric with respect to each other, we can extend the idea above by allowing functional description of marginal contributions.",
                "More concretely, we can specify the value of a rule as dependent on the number of agents of each relevant class.",
                "The use of functions will allow concise description of marginal diminishing returns (MDRs).",
                "Without the use of functions, the space needed to describe MDRs among n agents in MC-nets is O(n).",
                "With the use of functions, the space required can be reduced to O(1).",
                "Another idea to extend MC-nets is to augment the semantics to allow constructs that specify certain rules cannot be applied simultaneously.",
                "This is useful in situations where a certain agent represents a type of exhaustible resource, and therefore rules that depend on the presence of the agent should not apply simultaneously.",
                "For example, if agent i in the system stands for coal, we can either use it as fuel for a power plant or as input to a steel mill for making steel, but not for both at the same time.",
                "Currently, to represent such situations, we have to specify rules to cancel out the effects of applications of different rules.",
                "The augmented semantics can simplify the <br>representation</br> by specifying when rules cannot be applied together. 7.",
                "ACKNOWLEDGMENT The authors would like to thank Chris Luhrs, Bob McGrew, Eugene Nudelman, and Qixiang Sun for fruitful discussions, and the anonymous reviewers for their helpful comments on the paper. 8.",
                "REFERENCES [1] H. L. Bodlaender.",
                "Treewidth: Algorithmic techniques and results.",
                "In Proc. 22nd Symp. on Mathematical Foundation of Copmuter Science, pages 19-36.",
                "Springer-Verlag LNCS 1295, 1997. [2] V. Conitzer and T. Sandholm.",
                "Complexity of determining nonemptiness of the core.",
                "In Proc. 18th Int.",
                "Joint Conf. on Artificial Intelligence, pages 613-618, 2003. [3] V. Conitzer and T. Sandholm.",
                "Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains.",
                "In Proc. 19th Nat.",
                "Conf. on Artificial Intelligence, pages 219-225, 2004. [4] X. Deng and C. H. Papadimitriou.",
                "On the complexity of cooperative solution concepts.",
                "Math.",
                "Oper.",
                "Res., 19:257-266, May 1994. [5] Y. Fujishima, K. Leyton-Brown, and Y. Shoham.",
                "Taming the computational complexity of combinatorial auctions: Optimal and approximate approaches.",
                "In Proc. 16th Int.",
                "Joint Conf. on Artificial Intelligence, pages 548-553, 1999. [6] M. Kearns, M. L. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proc. 17th Conf. on Uncertainty in Artificial Intelligence, pages 253-260, 2001. [7] J. Kleinberg, C. H. Papadimitriou, and P. Raghavan.",
                "On the value of private information.",
                "In Proc. 8th Conf. on Theoretical Aspects of Rationality and Knowledge, pages 249-257, 2001. [8] C. Li and K. Sycara.",
                "Algoirthms for combinatorial coalition formation and payoff division in an electronic marketplace.",
                "Technical report, Robotics Insititute, Carnegie Mellon University, November 2001. [9] A. Mas-Colell, M. D. Whinston, and J. R. Green.",
                "Microeconomic Theory.",
                "Oxford University Press, New York, 1995. [10] N. Nisan.",
                "Bidding and allocation in combinatorial auctions.",
                "In Proc. 2nd ACM Conf. on Electronic Commerce, pages 1-12, 2000. [11] M. J. Osborne and A. Rubinstein.",
                "A Course in Game Theory.",
                "The MIT Press, Cambridge, Massachusetts, 1994. [12] I. Wegener.",
                "The Complexity of Boolean Functions.",
                "John Wiley & Sons, New York, October 1987. 201 APPENDIX We will formally show the correctness of the r-value computation in Algorithm 1 of introduce nodes and join nodes.",
                "Lemma 1.",
                "The procedure for computing the r-values of introduce nodes in Algorithm 1 is correct.",
                "Proof.",
                "Let node m be the newly introduced agent at i.",
                "Let U denote the set of agents in the subtree rooted at i.",
                "By the running intersection property, all interactions (the hyperedges) between m and U must be in node i.",
                "For all S ⊆ Xi : m ∈ S, let R denote (U \\ Xi) ∪ S), and Q denote (R \\ {m}). ri(S) = r(S, R) = min T :S⊆T ⊆R e(T) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(T \\ {m}) + xm − v(T \\ {m}) − v(cut) = min T :S\\{m}⊆T ⊆Q e(T ) + xm − v(cut) = rj(S) + xm − v(cut) The argument for sets S ⊆ Xi : m /∈ S is symmetric except xm will not contribute to the reserve due to the absence of m. Lemma 2.",
                "The procedure for computing the r-values of join nodes in Algorithm 1 is correct.",
                "Proof.",
                "Consider any set S ⊆ Xi.",
                "Let Uj denote the subtree rooted at the left child, Rj denote ((Uj \\ Xj) ∪ S), and Qj denote (Uj \\ Xj).",
                "Let Uk, Rk, and Qk be defined analogously for the right child.",
                "Let R denote (U \\ Xi) ∪ S). ri(S) = r(S, R) = min T :S⊆T ⊆R x(T) − v(T) = min T :S⊆T ⊆R x(S) + x(T ∩ Qj) + x(T ∩ Qk) − v(S) − v(cut(S, T ∩ Qj) − v(cut(S, T ∩ Qk) = min T :S⊆T ⊆R x(T ∩ Qj) − v(cut(S, T ∩ Qj)) + min T :S⊆T ⊆R x(T ∩ Qk) − v(cut(S, T ∩ Qk)) + (x(S) − v(S)) (*) = min T :S⊆T ⊆R x(T ∩ Qj) + x(S) − v(cut(S, T ∩ Qj)) − v(S) + min T :S⊆T ⊆R x(T ∩ Qk) + x(S) − v(cut(S, T ∩ Qk)) − v(S) − (x(S) − v(S)) = min T :S⊆T ⊆R e(T ∩ Rj) + min T :S⊆T ⊆R e(T ∩ Rk) − e(S) = min T :S⊆T ⊆Rj e(T ) + min T :S⊆T ⊆Rk e(T ) − e(S) = rj(S) + rk(S) − e(S) where (*) is true as T ∩ Qj and T ∩ Qk are disjoint due to the running intersection property of tree decomposition, and hence the minimum of the sum can be decomposed into the sum of the minima. 202"
            ],
            "original_annotated_samples": [
                "Marginal Contribution Nets: A Compact <br>representation</br> Scheme for Coalitional Games ∗ Samuel Ieong † Computer Science Department Stanford University Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Computer Science Department Stanford University Stanford, CA 94305 shoham@stanford.edu ABSTRACT We present a new approach to representing coalitional games based on rules that describe the marginal contributions of the agents.",
                "This <br>representation</br> scheme captures characteristics of the interactions among the agents in a natural and concise manner.",
                "We also develop efficient algorithms for two of the most important solution concepts, the Shapley value and the core, under this <br>representation</br>.",
                "The emptiness of the core can be determined in time exponential only in the treewidth of a graphical interpretation of our <br>representation</br>.",
                "A similar problem, combinatorial coalition formation, has previously been studied in [8]. 1.2 Evaluation Criteria for Coalitional Game <br>representation</br> To capture the coalitional games described above and perform computations on them, we must first find a <br>representation</br> for these games."
            ],
            "translated_annotated_samples": [
                "Contribuciones marginales netas: Un esquema de <br>representación</br> compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes.",
                "Este <br>esquema de representación</br> captura las características de las interacciones entre los agentes de una manera natural y concisa.",
                "También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta <br>representación</br>.",
                "La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de <br>nuestra representación</br>.",
                "Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la <br>representación</br> de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una <br>representación</br> para estos juegos."
            ],
            "translated_text": "Contribuciones marginales netas: Un esquema de <br>representación</br> compacto para juegos coalicionales ∗ Samuel Ieong † Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 sieong@stanford.edu Yoav Shoham Departamento de Ciencias de la Computación Universidad de Stanford Stanford, CA 94305 shoham@stanford.edu RESUMEN Presentamos un nuevo enfoque para representar juegos coalicionales basado en reglas que describen las contribuciones marginales de los agentes. Este <br>esquema de representación</br> captura las características de las interacciones entre los agentes de una manera natural y concisa. También desarrollamos algoritmos eficientes para dos de los conceptos de solución más importantes, el valor de Shapley y el núcleo, bajo esta <br>representación</br>. El valor de Shapley se puede calcular en tiempo lineal en función del tamaño de la entrada. La vacuidad del núcleo puede determinarse en tiempo exponencial solo en el ancho del árbol de una interpretación gráfica de <br>nuestra representación</br>. Categorías y Descriptores de Asignaturas I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.2 [Análisis de Algoritmos y Complejidad de Problemas] Términos Generales Algoritmos, Economía. INTRODUCCIÓN\nLos agentes a menudo pueden beneficiarse coordinando sus acciones. Los juegos coalicionales capturan estas oportunidades de coordinación al modelar explícitamente la capacidad de los agentes para tomar acciones conjuntas como primitivas. Como abstracción, los juegos coalicionales asignan un beneficio a cada grupo de agentes en el juego. Este pago está destinado a reflejar el pago que el grupo de agentes puede asegurar para sí mismos independientemente de las acciones de los agentes que no están en el grupo. Estas elecciones de primitivas contrastan con las de juegos no cooperativos, en los que los agentes se modelan de forma independiente y sus ganancias dependen críticamente de las acciones elegidas por los otros agentes. Juegos de Coalición y Comercio Electrónico Los juegos de coalición han aparecido en el contexto del comercio electrónico. En [7], Kleinberg et al. utilizan juegos coalicionales para estudiar sistemas de recomendación. En su modelo, cada individuo conoce un cierto conjunto de elementos, está interesado en aprender sobre todos los elementos y se beneficia al descubrirlos. Los beneficios para grupos de agentes son el número total de elementos distintos conocidos por sus miembros. Dado este escenario de juego coalicional, Kleinberg et al. calculan el valor de la información privada de los agentes para el sistema utilizando el concepto de solución del valor de Shapley (la definición se puede encontrar en la sección 2). Estos valores pueden ser utilizados para determinar cuánto debe recibir cada agente por participar en el sistema. Como otro ejemplo, considera la economía detrás de la formación de cadenas de suministro. El aumento en el uso de Internet como medio para llevar a cabo negocios ha disminuido los costos para las empresas al coordinar sus acciones, por lo tanto, el juego coalicional es un buen modelo para estudiar el problema de la cadena de suministro. Supongamos que cada fabricante compra sus materias primas de un conjunto de proveedores, y que los proveedores ofrecen mayores descuentos con más compras. La disminución en los costos de comunicación permitirá a los fabricantes encontrar a otros interesados en el mismo conjunto de proveedores de manera más económica, y facilita la formación de coaliciones para negociar con los proveedores. Dependiendo del conjunto de proveedores y cuánto compra cada coalición de cada proveedor, podemos asignar pagos a las coaliciones según el descuento que reciban. El juego resultante puede ser analizado utilizando la teoría de juegos coalicionales, y podemos responder preguntas como la estabilidad de las coaliciones y cómo dividir de manera justa los beneficios entre los fabricantes participantes. Un problema similar, la formación de coaliciones combinatorias, ha sido estudiado previamente en [8].\nCriterios de evaluación para la <br>representación</br> de juegos coalicionales. Para capturar los juegos coalicionales descritos anteriormente y realizar cálculos sobre ellos, primero debemos encontrar una <br>representación</br> para estos juegos. ",
            "candidates": [],
            "error": [
                [
                    "representación",
                    "esquema de representación",
                    "representación",
                    "nuestra representación",
                    "representación",
                    "representación"
                ]
            ]
        }
    }
}