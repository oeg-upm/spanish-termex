{
    "id": "I-76",
    "original_text": "Negotiation by Abduction and Relaxation Chiaki Sakama Dept. Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents. We suppose an agent who has a knowledge base represented by a logic program. Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent. To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases. These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation. We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals. Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1. INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance). Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round. An agent that received a proposal responds in two ways. One is a critique which is a remark as to whether or not (parts of) the proposal is accepted. The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13]. To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.) B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver. I want to get it at the price under 1200 USD. S1: We can provide a PC with the requested specification if you pay for it by cash. In this case, however, service points are not added for this special discount. B2: I cannot pay it by cash. S2: In a normal price, the requested PC costs 1300 USD. B3: I cannot accept the price. My budget is under 1200 USD. S3: We can provide another computer with the requested specification, except that it is made by the brand b2. The price is exactly 1200 USD. B4: I do not want a PC of the brand b2. Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal. S4: Ok, I accept your offer. In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned. In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals. Critiques are produced by evaluating a proposal in a knowledge base of an agent. In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one. It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal. According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X. B: I propose that I provide you with service X if you provide me with service Z. The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X. B: I propose that I provide you with service X if you provide me with service Z. A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement. In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives. The objective of the agent A in the above dialogues is to obtain service X. The agent B proposes conditions to provide the service. In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise. In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW. Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems. Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals. The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues. We suppose an agent who has a knowledge base represented by a logic program. We then introduce methods for generating three different types of proposals. First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one. Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one. Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal. We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques. We also provide procedures for computing proposals in logic programming. This paper is organized as follows. Section 2 introduces a logical framework used in this paper. Section 3 presents methods for constructing proposals, and provides a negotiation protocol. Section 4 provides methods for computing proposals in logic programming. Section 5 discusses related works, and Section 6 concludes the paper. 2. PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7]. An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal. The symbol ; represents disjunction. The left-hand side of the rule is the head, and the right-hand side is the body. For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively. Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}. A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals. A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r). A rule r is disjunctive if head(r) contains more than one literal. A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅. A program is NAF-free if no rule contains NAF-literals. Two rules/literals are identified with respect to variable renaming. A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi. Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable. A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way. The semantics of an EDP is defined by the answer set semantics [7]. Let Lit be the set of all ground literals in the language of a program. Suppose a program P and a set of literals S(⊆ Lit). Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅. Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit. Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ). A program has none, one, or multiple answer sets in general. An answer set is consistent if it is not Lit. A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent. Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming. An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15]. An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles. When a literal L ∈ H contains variables, any instance of L is also an abducible. An abductive program P, H is consistent if P is consistent. Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise. Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm. A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ. Let P, H be an abductive program and G a conjunction as above. A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3. E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)). Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅). Extended abduction introduces/removes hypotheses to/from a program to explain an observation. Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation. An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1. Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← . H : broken-wing(x) . The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15]. Skeptical explanations are used in [8]. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3. NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H . A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general. We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context. In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation. Definition 3.1. A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted. In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions. A counter-proposal is a proposal made in response to a proposal. Definition 3.2. A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable. Definition 3.3. Let P, H be an abductive program and G a proposal. If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }. Proposition 3.1. Let P, H be an abductive program and G a proposal. If G is a conditional proposal, there is a belief set S of P, H satisfying G . Proof. When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅. In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly. When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1. An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year. The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000. The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs. They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction. According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD. In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }. Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal. We use techniques of relaxation for this purpose. Relaxation is used as a technique of cooperative query answering in databases [4, 6]. When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query. This allows the database to return neighborhood answers which are related to the original query. We use the technique for producing proposals in the process of negotiation. Definition 3.4. Let P, H be an abductive program and G a proposal. Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ. Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2. Here, Lθ is called a replaced literal. In each case, every variable in G is existentially quantified at the front and range-restricted. Anti-instantiation replaces constants (or terms) with fresh variables. Dropping conditions eliminates some conditions in a proposal. Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1. All these operations generalize proposals in different ways. Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12]. The relaxed proposal can produce new offers which are neighbor to the original proposal. Definition 3.5. Let P, H be an abductive program and G a proposal. 1. Let G be a proposal obtained by anti-instantiation. If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2. Let G be a proposal obtained by dropping conditions. If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3. Let G be a proposal obtained by goal replacement. For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ. If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement. Example 3.2. (cont. Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000. As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced. As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement. Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals. Definition 3.6. Let P, H be an abductive program and G a proposal. 1. Let G be a proposal obtained by either anti-instantiation or dropping conditions. If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2. Let G be a proposal obtained by goal replacement. Suppose G as in Definition 3.5(3). If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement. A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation. This section presents a negotiation protocol in our framework. We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication. Definition 3.7. A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal. A negotiation proceeds in a series of rounds. Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2. Definition 3.8. Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round. A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2. CSi 2(P2, Gj 1) is defined in the same manner. Definition 3.9. Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round. A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk . A negotiation set represents the space of possible proposals made by an agent. Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6. Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals. An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅. Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively. Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts. In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1. If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2. Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅. Proceed to the step 4(b). 3. Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1. Negotiation ends in success. 4. Otherwise, Ag2 behaves as follows. Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}. If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn. If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure. This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1. In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set. This helps for Ag1 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal. In the step 4(b), Ag2 constructs a new proposal. In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy. Also, FP i 2 is used for removing proposals which have been rejected. Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x . For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅. That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round. Si c and Si cn are obtained as well. In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn. This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one. Another strategy, which prefers neighborhood proposals to conditional ones, is also considered. Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent. The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once. We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3). The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure. Formally, the above negotiation protocol has the following properties. Theorem 3.2. Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1. If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2. If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1. When an abductive program is function-free, abducibles and negotiation sets are both finite. Moreover, if a proposal is once rejected, it is not proposed again by the function μ. Thus, negotiation will terminate in finite steps. 2. When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 . Example 3.3. Suppose a buying-selling situation in the introduction. A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash. Here, (1) and (2) represent selection of products. The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB. Prices of products are represented as desire of the seller. The rules (3) - (5) are normal prices of products. A normal price is a selling price on the condition that service points are added (6). On the other hand, a discount price is applied if the paying method is cash and no service point is added (7). The fact (8) represents the addition of service points. This service would be withdrawn in case of discount prices, so add point is specified as an abducible. A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw. Rules (12) - (16) are the buyers desire. Among them, (15) and (16) impose constraints for buying a PC. A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200. As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal. The seller takes an action of making a counter-proposal and performs abduction. As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }. The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15). The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}. In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set. As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals. He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x). As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16). The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200. As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal. The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200. As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent. Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer. Thus, the negotiation ends in success. 4. COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs. We first introduce some definitions from [15]. Definition 4.1. Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms. By the definition, the atom L becomes true iff L is not true. The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not. When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a. In this case, the rule is shortly written as +p(x) ← p(x), x = a. Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances. The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true. In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true. Thus, update atoms represent the change of truth values of abducibles in a program. That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables. In this case, an update atom is semantically identified with its ground instances. The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp. UH− ) is the set of update atoms of the form +L (resp. −L). Definition 4.2. Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR . An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH. By the definition, U-minimal answer sets exist whenever UP has answer sets. Update programs are used for computing (minimal) explanations of an observation. Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation. With this replacement, an observation is assumed to be a ground literal without loss of generality. In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation. Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− . In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set. Example 4.1. To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . Next, consider the program UP ∪ { ← not flies(t) }. It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }. The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− . Proposition 4.2. Let P, H be an abductive program and G a ground literal representing an observation. If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals. First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals. If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program. Put G, E, not F in Sc. Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program. If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc. Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation. For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions. If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn. Else if G is a conjunction possibly containing variables, do the following. For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement. If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ. If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. Else if G is a conjunction possibly containing variables, do the following. For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ. For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. Theorem 4.3. The set Sc (resp. Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals). Proof. The result for Sc follows from Definition 3.3 and Proposition 4.1. The result for Sn follows from Definition 3.5 and Proposition 4.2. Conditional neighborhood proposals are computed by combining the above two procedures. Those proposals are computed at each round. Note that the procedure for computing Sn contains some nondeterministic choices. For instance, there are generally several candidates of literals to relax in a proposal. Also, there might be several rules in a program for the usage of goal replacement. In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5. RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation. Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents. Agents negotiate using common dialogue primitives, called dialogue moves. Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles. The behavior of agents is regulated by an observe-think-act cycle. Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure. Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different. First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals. Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems. This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent. Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents. They provide an operational model that completely specifies the behavior of agents in terms of agent cycle. We do not provide such a complete specification of the behavior of agents. Our primary interest is to mechanize construction of proposals. Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs. To explain an observation, two agents communicate by exchanging integrity constraints. In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent. A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC . For instance, IC : ← a, b, c relaxes IC : ← a, b. Thus, they use relaxation for weakening the constraints in an abductive logic program. In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered. Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals. Meyer et al. [11] introduce a logical framework for negotiating agents. They introduce two different modes of negotiation: concession and adaptation. They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes. They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols. Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework. Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs. An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets. Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent. Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set. The work is extended to repeated encounters in [3]. In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals. There are a number of proposals for negotiation based 1028 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation. An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1]. The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques. Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents. In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B. The proposal is evaluated by B which attempts to build arguments against it. If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument. In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection. If either type of argument can be found, A will submit it to B. If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success. Otherwise, the process is iterated. In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective. In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation. Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets. Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework. A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made. Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation. In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable. Our present approach differs from theirs in the following points. First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept. Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations. In our framework, counter-proposals are newly constructed using abduction and relaxation. The method of construction is independent of particular negotiation protocols. As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction. In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program. This is another important difference. Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6]. In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems. As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6. CONCLUSION In this paper we proposed a logical framework for negotiating agents. To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation. It was shown that these two operations are used for general inference rules in producing proposals. We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming. This enables us to realize automated negotiation on top of the existing answer set solvers. The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives. To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals. Further elaboration to maximize the utility of agents is left for future study. 7. REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet. Arguments, dialogue, and negotiation. In: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni. A new framework for knowledge revision of abductive agents through their interaction. In: Proc. CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo. Repeated negotiation of logic programs. In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee. Cooperative query answering via type abstraction hierarchy. In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang. Negotiating logic programs. In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker. Relaxation as a platform for cooperative answering. Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz. Classical negation in logic programs and disjunctive databases. New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama. Abductive framework for nonmonotonic theory change. In: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming. In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis. Adaptive agent negotiation via argumentation. In: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang. Logical foundation of negotiation: outcome, concession and adaptation. In: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. A theory and methodology of inductive learning. In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings. Agents that reason and negotiate by arguing. Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents. In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue. An abductive framework for computing knowledge base updates. Theory and Practice of Logic Programming 3(6):671-715, 2003. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029",
    "original_translation": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029",
    "original_sentences": [
        "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
        "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
        "We suppose an agent who has a knowledge base represented by a logic program.",
        "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
        "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
        "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
        "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
        "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
        "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
        "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
        "An agent that received a proposal responds in two ways.",
        "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
        "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
        "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
        "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
        "I want to get it at the price under 1200 USD.",
        "S1: We can provide a PC with the requested specification if you pay for it by cash.",
        "In this case, however, service points are not added for this special discount.",
        "B2: I cannot pay it by cash.",
        "S2: In a normal price, the requested PC costs 1300 USD.",
        "B3: I cannot accept the price.",
        "My budget is under 1200 USD.",
        "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
        "The price is exactly 1200 USD.",
        "B4: I do not want a PC of the brand b2.",
        "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
        "S4: Ok, I accept your offer.",
        "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
        "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
        "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
        "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
        "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
        "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
        "B: I propose that I provide you with service X if you provide me with service Z.",
        "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
        "B: I propose that I provide you with service X if you provide me with service Z.",
        "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
        "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
        "The objective of the agent A in the above dialogues is to obtain service X.",
        "The agent B proposes conditions to provide the service.",
        "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
        "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
        "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
        "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
        "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
        "We suppose an agent who has a knowledge base represented by a logic program.",
        "We then introduce methods for generating three different types of proposals.",
        "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
        "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
        "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
        "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
        "We also provide procedures for computing proposals in logic programming.",
        "This paper is organized as follows.",
        "Section 2 introduces a logical framework used in this paper.",
        "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
        "Section 4 provides methods for computing proposals in logic programming.",
        "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
        "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
        "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
        "The symbol ; represents disjunction.",
        "The left-hand side of the rule is the head, and the right-hand side is the body.",
        "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
        "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
        "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
        "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
        "A rule r is disjunctive if head(r) contains more than one literal.",
        "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
        "A program is NAF-free if no rule contains NAF-literals.",
        "Two rules/literals are identified with respect to variable renaming.",
        "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
        "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
        "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
        "The semantics of an EDP is defined by the answer set semantics [7].",
        "Let Lit be the set of all ground literals in the language of a program.",
        "Suppose a program P and a set of literals S(⊆ Lit).",
        "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
        "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
        "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
        "A program has none, one, or multiple answer sets in general.",
        "An answer set is consistent if it is not Lit.",
        "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
        "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
        "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
        "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
        "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
        "An abductive program P, H is consistent if P is consistent.",
        "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
        "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
        "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
        "Let P, H be an abductive program and G a conjunction as above.",
        "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
        "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
        "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
        "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
        "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
        "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
        "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
        "H : broken-wing(x) .",
        "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
        "Skeptical explanations are used in [8].",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
        "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
        "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
        "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
        "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
        "Definition 3.1.",
        "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
        "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
        "A counter-proposal is a proposal made in response to a proposal.",
        "Definition 3.2.",
        "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
        "Definition 3.3.",
        "Let P, H be an abductive program and G a proposal.",
        "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
        "Proposition 3.1.",
        "Let P, H be an abductive program and G a proposal.",
        "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
        "Proof.",
        "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
        "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
        "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
        "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
        "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
        "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
        "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
        "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
        "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
        "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
        "We use techniques of relaxation for this purpose.",
        "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
        "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
        "This allows the database to return neighborhood answers which are related to the original query.",
        "We use the technique for producing proposals in the process of negotiation.",
        "Definition 3.4.",
        "Let P, H be an abductive program and G a proposal.",
        "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
        "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
        "Here, Lθ is called a replaced literal.",
        "In each case, every variable in G is existentially quantified at the front and range-restricted.",
        "Anti-instantiation replaces constants (or terms) with fresh variables.",
        "Dropping conditions eliminates some conditions in a proposal.",
        "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
        "All these operations generalize proposals in different ways.",
        "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
        "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
        "Definition 3.5.",
        "Let P, H be an abductive program and G a proposal. 1.",
        "Let G be a proposal obtained by anti-instantiation.",
        "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
        "Let G be a proposal obtained by dropping conditions.",
        "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
        "Let G be a proposal obtained by goal replacement.",
        "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
        "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
        "Example 3.2. (cont.",
        "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
        "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
        "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
        "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
        "Definition 3.6.",
        "Let P, H be an abductive program and G a proposal. 1.",
        "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
        "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
        "Let G be a proposal obtained by goal replacement.",
        "Suppose G as in Definition 3.5(3).",
        "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
        "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
        "This section presents a negotiation protocol in our framework.",
        "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
        "Definition 3.7.",
        "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
        "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
        "A negotiation proceeds in a series of rounds.",
        "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
        "Definition 3.8.",
        "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
        "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
        "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
        "CSi 2(P2, Gj 1) is defined in the same manner.",
        "Definition 3.9.",
        "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
        "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
        "A negotiation set represents the space of possible proposals made by an agent.",
        "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
        "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
        "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
        "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
        "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
        "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
        "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
        "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
        "Proceed to the step 4(b). 3.",
        "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
        "Negotiation ends in success. 4.",
        "Otherwise, Ag2 behaves as follows.",
        "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
        "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
        "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
        "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
        "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
        "This helps for Ag1 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
        "In the step 4(b), Ag2 constructs a new proposal.",
        "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
        "Also, FP i 2 is used for removing proposals which have been rejected.",
        "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
        "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
        "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
        "Si c and Si cn are obtained as well.",
        "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
        "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
        "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
        "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
        "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
        "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
        "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
        "Formally, the above negotiation protocol has the following properties.",
        "Theorem 3.2.",
        "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
        "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
        "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
        "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
        "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
        "Thus, negotiation will terminate in finite steps. 2.",
        "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
        "Example 3.3.",
        "Suppose a buying-selling situation in the introduction.",
        "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
        "Here, (1) and (2) represent selection of products.",
        "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
        "Prices of products are represented as desire of the seller.",
        "The rules (3) - (5) are normal prices of products.",
        "A normal price is a selling price on the condition that service points are added (6).",
        "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
        "The fact (8) represents the addition of service points.",
        "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
        "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
        "Rules (12) - (16) are the buyers desire.",
        "Among them, (15) and (16) impose constraints for buying a PC.",
        "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
        "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
        "The seller takes an action of making a counter-proposal and performs abduction.",
        "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
        "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
        "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
        "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
        "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
        "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
        "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
        "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
        "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
        "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
        "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
        "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
        "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
        "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
        "Thus, the negotiation ends in success. 4.",
        "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
        "We first introduce some definitions from [15].",
        "Definition 4.1.",
        "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
        "By the definition, the atom L becomes true iff L is not true.",
        "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
        "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
        "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
        "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
        "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
        "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
        "Thus, update atoms represent the change of truth values of abducibles in a program.",
        "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
        "In this case, an update atom is semantically identified with its ground instances.",
        "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
        "UH− ) is the set of update atoms of the form +L (resp. −L).",
        "Definition 4.2.",
        "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
        "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
        "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
        "Update programs are used for computing (minimal) explanations of an observation.",
        "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
        "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
        "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
        "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
        "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
        "Example 4.1.",
        "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
        "Next, consider the program UP ∪ { ← not flies(t) }.",
        "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
        "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
        "Proposition 4.2.",
        "Let P, H be an abductive program and G a ground literal representing an observation.",
        "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
        "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
        "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
        "Put G, E, not F in Sc.",
        "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
        "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
        "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
        "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
        "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
        "Else if G is a conjunction possibly containing variables, do the following.",
        "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
        "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
        "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
        "Else if G is a conjunction possibly containing variables, do the following.",
        "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
        "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
        "Theorem 4.3.",
        "The set Sc (resp.",
        "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
        "Proof.",
        "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
        "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
        "Conditional neighborhood proposals are computed by combining the above two procedures.",
        "Those proposals are computed at each round.",
        "Note that the procedure for computing Sn contains some nondeterministic choices.",
        "For instance, there are generally several candidates of literals to relax in a proposal.",
        "Also, there might be several rules in a program for the usage of goal replacement.",
        "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
        "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
        "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
        "Agents negotiate using common dialogue primitives, called dialogue moves.",
        "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
        "The behavior of agents is regulated by an observe-think-act cycle.",
        "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
        "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
        "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
        "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
        "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
        "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
        "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
        "We do not provide such a complete specification of the behavior of agents.",
        "Our primary interest is to mechanize construction of proposals.",
        "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
        "To explain an observation, two agents communicate by exchanging integrity constraints.",
        "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
        "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
        "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
        "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
        "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
        "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
        "Meyer et al. [11] introduce a logical framework for negotiating agents.",
        "They introduce two different modes of negotiation: concession and adaptation.",
        "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
        "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
        "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
        "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
        "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
        "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
        "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
        "The work is extended to repeated encounters in [3].",
        "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
        "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
        "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
        "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
        "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
        "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
        "The proposal is evaluated by B which attempts to build arguments against it.",
        "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
        "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
        "If either type of argument can be found, A will submit it to B.",
        "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
        "Otherwise, the process is iterated.",
        "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
        "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
        "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
        "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
        "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
        "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
        "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
        "Our present approach differs from theirs in the following points.",
        "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
        "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
        "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
        "The method of construction is independent of particular negotiation protocols.",
        "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
        "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
        "This is another important difference.",
        "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
        "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
        "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
        "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
        "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
        "It was shown that these two operations are used for general inference rules in producing proposals.",
        "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
        "This enables us to realize automated negotiation on top of the existing answer set solvers.",
        "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
        "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
        "Further elaboration to maximize the utility of agents is left for future study. 7.",
        "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
        "Arguments, dialogue, and negotiation.",
        "In: Proc.",
        "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
        "A new framework for knowledge revision of abductive agents through their interaction.",
        "In: Proc.",
        "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
        "Repeated negotiation of logic programs.",
        "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
        "Cooperative query answering via type abstraction hierarchy.",
        "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
        "Negotiating logic programs.",
        "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
        "Relaxation as a platform for cooperative answering.",
        "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
        "Classical negation in logic programs and disjunctive databases.",
        "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
        "Abductive framework for nonmonotonic theory change.",
        "In: Proc.",
        "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
        "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
        "Adaptive agent negotiation via argumentation.",
        "In: Proc.",
        "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
        "Logical foundation of negotiation: outcome, concession and adaptation.",
        "In: Proc.",
        "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
        "A theory and methodology of inductive learning.",
        "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
        "Agents that reason and negotiate by arguing.",
        "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
        "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
        "An abductive framework for computing knowledge base updates.",
        "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
        "The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
    ],
    "translated_text_sentences": [
        "Negociación por Abducción y Relajación Chiaki Sakama Dept.",
        "Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes.",
        "Suponemos un agente que tiene una base de conocimiento representada por un programa lógico.",
        "Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente.",
        "Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos.",
        "Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación.",
        "Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas.",
        "Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1.",
        "INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo).",
        "La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda.",
        "Un agente que recibió una propuesta responde de dos maneras.",
        "Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no.",
        "La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13].",
        "Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda).",
        "Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW.",
        "Quiero conseguirlo a un precio por debajo de 1200 USD.",
        "Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo.",
        "En este caso, sin embargo, no se suman puntos de servicio para este descuento especial.",
        "B2: No puedo pagarlo en efectivo.",
        "En un precio normal, la PC solicitada cuesta 1300 USD.",
        "B3: No puedo aceptar el precio.",
        "Mi presupuesto es inferior a 1200 USD.",
        "S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2.",
        "El precio es exactamente de 1200 USD.",
        "B4: No quiero una PC de la marca b2.",
        "En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial.",
        "S4: Ok, acepto tu oferta.",
        "En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1.",
        "En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas.",
        "Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente.",
        "Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original.",
        "Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial.",
        "Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X.",
        "B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z.",
        "El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X.",
        "Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z.",
        "Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo.",
        "En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos.",
        "El objetivo del agente A en los diálogos anteriores es obtener el servicio X.",
        "El agente B propone condiciones para proporcionar el servicio.",
        "En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado.",
        "En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW.",
        "Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares.",
        "Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas.",
        "El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno.",
        "Suponemos un agente que tiene una base de conocimiento representada por un programa lógico.",
        "Luego introducimos métodos para generar tres tipos diferentes de propuestas.",
        "Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original.",
        "Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original.",
        "Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original.",
        "Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas.",
        "También ofrecemos procedimientos para calcular propuestas en programación lógica.",
        "Este documento está organizado de la siguiente manera.",
        "La sección 2 introduce un marco lógico utilizado en este artículo.",
        "La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación.",
        "La sección 4 proporciona métodos para calcular propuestas en programación lógica.",
        "La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo.",
        "PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7].",
        "Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF.",
        "El símbolo ; representa la disyunción.",
        "El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo.",
        "Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente.",
        "Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}.",
        "Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales.",
        "Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r).",
        "Una regla r es disyuntiva si head(r) contiene más de un literal.",
        "Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅.",
        "Un programa es libre de NAF si ninguna regla contiene literales NAF.",
        "Se identifican dos reglas/literales con respecto al cambio de nombre de variables.",
        "Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi.",
        "Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables.",
        "Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles.",
        "La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7].",
        "Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa.",
        "Supongamos un programa P y un conjunto de literales S(⊆ Lit).",
        "Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅.",
        "Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit.",
        "Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S).",
        "Un programa generalmente tiene cero, uno o varios conjuntos de respuestas.",
        "Un conjunto de respuestas es consistente si no es Lit.",
        "Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente.",
        "La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica.",
        "Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15].",
        "Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles.",
        "Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible.",
        "Un programa abductivo P, H es consistente si P es consistente.",
        "A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario.",
        "Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm.",
        "Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ.",
        "Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente.",
        "Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3.",
        "E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)).",
        "Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅).",
        "La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación.",
        "Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación.",
        "Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1.",
        "Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← .",
        "H : ala-rota(x) .",
        "La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15].",
        "Las explicaciones escépticas se utilizan en [8].",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3.",
        "NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H.",
        "Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general.",
        "Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto.",
        "Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación.",
        "Definición 3.1.",
        "Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango.",
        "En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas.",
        "Una contraoferta es una propuesta hecha en respuesta a una propuesta.",
        "Definición 3.2.",
        "Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable.",
        "Definición 3.3.",
        "Sean P, H un programa abductivo y G una propuesta.",
        "Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}.",
        "Proposición 3.1.",
        "Sean P, H un programa abductivo y G una propuesta.",
        "Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G.",
        "Prueba.",
        "Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅.",
        "En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia.",
        "Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1.",
        "Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año.",
        "El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000.",
        "La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas.",
        "Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción.",
        "Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD.",
        "En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }.",
        "Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial.",
        "Utilizamos técnicas de relajación para este propósito.",
        "La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6].",
        "Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma.",
        "Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original.",
        "Utilizamos la técnica para elaborar propuestas en el proceso de negociación.",
        "Definición 3.4.",
        "Sean P, H un programa abductivo y G una propuesta.",
        "Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ.",
        "Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2.",
        "Aquí, Lθ se llama un literal reemplazado.",
        "En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango.",
        "La anti-instantiación reemplaza constantes (o términos) con variables nuevas.",
        "La eliminación de condiciones elimina algunas condiciones en una propuesta.",
        "La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1.",
        "Todas estas operaciones generalizan propuestas de diferentes maneras.",
        "Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12].",
        "La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original.",
        "Definición 3.5.",
        "Sean P, H un programa abductivo y G una propuesta. 1.",
        "Sea G una propuesta obtenida por anti-instantiación.",
        "Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2.",
        "Sea G una propuesta obtenida al eliminar condiciones.",
        "Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3.",
        "Sea G una propuesta obtenida mediante la sustitución de objetivos.",
        "Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ.",
        "Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo.",
        "Ejemplo 3.2. (continuación)",
        "Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000.",
        "Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000.",
        "Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos.",
        "Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales.",
        "Definición 3.6.",
        "Sean P, H un programa abductivo y G una propuesta. 1.",
        "Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones.",
        "Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2.",
        "Sea G una propuesta obtenida mediante la sustitución de objetivos.",
        "Supongamos que G como en la Definición 3.5(3).",
        "Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo.",
        "Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación.",
        "Esta sección presenta un protocolo de negociación en nuestro marco de trabajo.",
        "Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa.",
        "Definición 3.7.",
        "Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
        "Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta.",
        "Una negociación avanza en una serie de rondas.",
        "Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2.",
        "Definición 3.8.",
        "Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda.",
        "Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
        "Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2.",
        "CSi 2(P2, Gj 1) se define de la misma manera.",
        "Definición 3.9.",
        "Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda.",
        "Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk.",
        "Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente.",
        "Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6.",
        "Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes.",
        "Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅.",
        "Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente.",
        "Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación.",
        "En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1.",
        "Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2.",
        "De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅.",
        "Continúa con el paso 4(b). 3.",
        "Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1.",
        "La negociación termina con éxito. 4.",
        "De lo contrario, Ag2 se comporta de la siguiente manera.",
        "Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}.",
        "Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn.",
        "Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso.",
        "Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1.",
        "En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas.",
        "Esto ayuda para Ag1 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta.",
        "En el paso 4(b), Ag2 construye una nueva propuesta.",
        "En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir.",
        "Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas.",
        "La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x.",
        "Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅.",
        "Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda.",
        "Si se obtienen c y Si cn también.",
        "En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn.",
        "Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original.",
        "Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada.",
        "Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible.",
        "El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez.",
        "Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3).",
        "El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso.",
        "Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades.",
        "Teorema 3.2.",
        "Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1.",
        "Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2.",
        "Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1.",
        "Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos.",
        "Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ.",
        "Por lo tanto, la negociación terminará en pasos finitos. 2.",
        "Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2.",
        "Ejemplo 3.3.",
        "Suponga una situación de compra-venta en la introducción.",
        "Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo.",
        "Aquí, (1) y (2) representan la selección de productos.",
        "El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB.",
        "Los precios de los productos se representan como el deseo del vendedor.",
        "Las reglas (3) - (5) son los precios normales de los productos.",
        "Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6).",
        "Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7).",
        "El hecho (8) representa la suma de puntos de servicio.",
        "Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible.",
        "Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw.",
        "Las reglas (12) - (16) son el deseo de los compradores.",
        "Entre ellos, (15) y (16) imponen restricciones para comprar una PC.",
        "Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200.",
        "Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta.",
        "El vendedor toma una acción de hacer una contraoferta y realiza un secuestro.",
        "Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}.",
        "El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15).",
        "El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}.",
        "En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas.",
        "Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario.",
        "Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x).",
        "Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
        "En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16).",
        "El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
        "El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200.",
        "Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original.",
        "El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
        "Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200.",
        "Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor.",
        "Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador.",
        "Por lo tanto, la negociación termina con éxito. 4.",
        "CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas.",
        "Primero introducimos algunas definiciones de [15].",
        "Definición 4.1.",
        "Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización.",
        "Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero.",
        "El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no.",
        "Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a.",
        "En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a.",
        "Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias.",
        "La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero.",
        "Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero.",
        "Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa.",
        "Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables.",
        "En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales.",
        "El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp.",
        "UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L).",
        "Definición 4.2.",
        "Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR.",
        "Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH.",
        "Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas.",
        "Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación.",
        "Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación.",
        "Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad.",
        "En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación.",
        "Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−.",
        "En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo.",
        "Ejemplo 4.1.",
        "Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
        "A continuación, considera el programa UP ∪ { ← no vuela(t) }.",
        "Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }.",
        "La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−.",
        "Proposición 4.2.",
        "Sean P, H un programa abductivo y G un literal concreto representando una observación.",
        "Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas.",
        "Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas.",
        "Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización.",
        "Coloca G, E, no F en Sc.",
        "Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización.",
        "Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc.",
        "A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación.",
        "Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones.",
        "Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn.",
        "Si G es una conjunción que posiblemente contiene variables, haz lo siguiente.",
        "Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo.",
        "Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ.",
        "Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn.",
        "Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente.",
        "Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ.",
        "Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn.",
        "Teorema 4.3.",
        "El conjunto Sc (resp.",
        "La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario).",
        "Prueba.",
        "El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1.",
        "El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2.",
        "Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores.",
        "Esas propuestas se calculan en cada ronda.",
        "Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas.",
        "Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta.",
        "Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos.",
        "En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5.",
        "TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación.",
        "Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores.",
        "Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo.",
        "Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles.",
        "El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar.",
        "Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba.",
        "Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente.",
        "Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales.",
        "Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos.",
        "Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente.",
        "Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales.",
        "Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente.",
        "No proporcionamos una especificación tan completa del comportamiento de los agentes.",
        "Nuestro interés principal es mecanizar la construcción de propuestas.",
        "Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos.",
        "Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad.",
        "En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente.",
        "Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC.",
        "Por ejemplo, IC : ← a, b, c relaja IC : ← a, b.",
        "Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo.",
        "Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos.",
        "Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas.",
        "Meyer et al. [11] presentan un marco lógico para agentes negociadores.",
        "Introducen dos modos diferentes de negociación: concesión y adaptación.",
        "Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados.",
        "Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación.",
        "Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva.",
        "Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos.",
        "Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas.",
        "Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente.",
        "Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos.",
        "El trabajo se extiende a encuentros repetidos en [3].",
        "En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas.",
        "Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación.",
        "Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1].",
        "La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas.",
        "Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI.",
        "En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B.",
        "La propuesta es evaluada por B, quien intenta construir argumentos en su contra.",
        "Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque.",
        "En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción.",
        "Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B.",
        "Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito.",
        "De lo contrario, el proceso se repite.",
        "En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original.",
        "En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación.",
        "Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta.",
        "Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación.",
        "Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta.",
        "La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación.",
        "En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable.",
        "Nuestro enfoque actual difiere del de ellos en los siguientes puntos.",
        "Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar.",
        "En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones.",
        "En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación.",
        "El método de construcción es independiente de protocolos de negociación particulares.",
        "Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal.",
        "Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa.",
        "Esta es otra diferencia importante.",
        "La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6].",
        "En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente.",
        "Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6.",
        "CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores.",
        "Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación.",
        "Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas.",
        "Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva.",
        "Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes.",
        "El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas.",
        "Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas.",
        "La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros.",
        "REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet.",
        "Argumentos, diálogo y negociación.",
        "En: Proc.",
        "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni.",
        "Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción.",
        "En: Proc.",
        "CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo.",
        "Negociación repetida de programas lógicos.",
        "En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee.",
        "Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos.",
        "En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang.",
        "Negociando programas lógicos.",
        "En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker.",
        "Relajación como plataforma para responder de manera cooperativa.",
        "Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz.",
        "Negación clásica en programas lógicos y bases de datos disyuntivas.",
        "Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama.",
        "Marco abductivo para el cambio de teoría no monótona.",
        "En: Proc.",
        "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica.",
        "En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis.",
        "Negociación de agentes adaptativos a través de argumentación.",
        "En: Proc.",
        "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang.",
        "Fundamento lógico de la negociación: resultado, concesión y adaptación.",
        "En: Proc.",
        "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
        "Una teoría y metodología de aprendizaje inductivo.",
        "En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings.",
        "Agentes que razonan y negocian mediante argumentos.",
        "Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores.",
        "En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue.",
        "Un marco abductivo para calcular actualizaciones de la base de conocimientos.",
        "Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003.",
        "El Sexto Internacional.",
        "Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029"
    ],
    "error_count": 1,
    "keys": {
        "automated negotiation": {
            "translated_key": "negociación automatizada",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for <br>automated negotiation</br> between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION <br>automated negotiation</br> has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for <br>automated negotiation</br> which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on <br>automated negotiation</br>, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize <br>automated negotiation</br> on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for <br>automated negotiation</br> between two agents.",
                "INTRODUCTION <br>automated negotiation</br> has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Currently, there is no computational logic for <br>automated negotiation</br> which has general inference rules for producing (counter-)proposals.",
                "RELATED WORK As there are a number of literature on <br>automated negotiation</br>, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "This enables us to realize <br>automated negotiation</br> on top of the existing answer set solvers."
            ],
            "translated_annotated_samples": [
                "Este artículo estudia un marco lógico para la <br>negociación automatizada</br> entre dos agentes.",
                "INTRODUCCIÓN La <br>negociación automatizada</br> ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo).",
                "Actualmente, no existe una lógica computacional para la <br>negociación automatizada</br> que tenga reglas de inferencia generales para producir propuestas (contra)propuestas.",
                "TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre <br>negociación automatizada</br>, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación.",
                "Esto nos permite realizar <br>negociaciones automatizadas</br> sobre los solucionadores de conjuntos de respuestas existentes."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la <br>negociación automatizada</br> entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La <br>negociación automatizada</br> ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la <br>negociación automatizada</br> que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre <br>negociación automatizada</br>, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar <br>negociaciones automatizadas</br> sobre los solucionadores de conjuntos de respuestas existentes. ",
            "candidates": [],
            "error": [
                [
                    "negociación automatizada",
                    "negociación automatizada",
                    "negociación automatizada",
                    "negociación automatizada",
                    "negociaciones automatizadas"
                ]
            ]
        },
        "multi-agent system": {
            "translated_key": "sistemas multiagente",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in <br>multi-agent system</br>s, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in <br>multi-agent system</br>s.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "INTRODUCTION Automated negotiation has been received increasing attention in <br>multi-agent system</br>s, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in <br>multi-agent system</br>s."
            ],
            "translated_annotated_samples": [
                "INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los <br>sistemas multiagente</br>, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo).",
                "En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en <br>sistemas multiagente</br>."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los <br>sistemas multiagente</br>, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en <br>sistemas multiagente</br>. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "one-to-one negotiation": {
            "translated_key": "negociación uno a uno",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in <br>one-to-one negotiation</br>, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in <br>one-to-one negotiation</br> dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose <br>one-to-one negotiation</br> between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model <br>one-to-one negotiation</br> as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In <br>one-to-one negotiation</br>, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "To see these proposals in <br>one-to-one negotiation</br>, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in <br>one-to-one negotiation</br> dialogues.",
                "We suppose <br>one-to-one negotiation</br> between two agents who have a common ontology and the same language for successful communication.",
                "Foo et al. [5] model <br>one-to-one negotiation</br> as a one-time encounter between two extended logic programs.",
                "In <br>one-to-one negotiation</br>, an agent A generates a proposal together with its arguments, and passes it to another agent B."
            ],
            "translated_annotated_samples": [
                "Para ver estas propuestas en <br>una negociación uno a uno</br>, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda).",
                "El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de <br>negociación uno a uno</br>.",
                "Suponemos una <br>negociación uno a uno</br> entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa.",
                "Foo et al. [5] modelan la <br>negociación uno a uno</br> como un encuentro único entre dos programas lógicos extendidos.",
                "En una <br>negociación uno a uno</br>, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en <br>una negociación uno a uno</br>, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de <br>negociación uno a uno</br>. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una <br>negociación uno a uno</br> entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la <br>negociación uno a uno</br> como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una <br>negociación uno a uno</br>, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. ",
            "candidates": [],
            "error": [
                [
                    "una negociación uno a uno",
                    "negociación uno a uno",
                    "negociación uno a uno",
                    "negociación uno a uno",
                    "negociación uno a uno"
                ]
            ]
        },
        "alternative proposal": {
            "translated_key": "propuesta alternativa",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an <br>alternative proposal</br> made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an <br>alternative proposal</br> which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "The other is a counter-proposal which is an <br>alternative proposal</br> made in response to a previous proposal [13].",
                "In contrast, making counter-proposals involves generating an <br>alternative proposal</br> which is more favorable to the responding agent than the original one."
            ],
            "translated_annotated_samples": [
                "La otra es una contraoferta que es una <br>propuesta alternativa</br> hecha en respuesta a una propuesta previa [13].",
                "Por el contrario, hacer contraofertas implica generar una <br>propuesta alternativa</br> que sea más favorable para el agente que responde que la original."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una <br>propuesta alternativa</br> hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una <br>propuesta alternativa</br> que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "specific meta-knowledge": {
            "translated_key": "metaconocimiento específico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as <br>specific meta-knowledge</br> of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Such behavior is usually represented as <br>specific meta-knowledge</br> of an agent or specified as negotiation protocols in particular problems."
            ],
            "translated_annotated_samples": [
                "Dicho comportamiento suele representarse como <br>metaconocimiento específico</br> de un agente o especificarse como protocolos de negociación en problemas particulares."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como <br>metaconocimiento específico</br> de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "conditional proposal": {
            "translated_key": "propuesta condicional",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a <br>conditional proposal</br> as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a <br>conditional proposal</br> (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a <br>conditional proposal</br>, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A <br>conditional proposal</br> G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a <br>conditional proposal</br> is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the <br>conditional proposal</br> made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the <br>conditional proposal</br>: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other <br>conditional proposal</br> satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a <br>conditional proposal</br> as an extension of the original one.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a <br>conditional proposal</br> (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "If G is a <br>conditional proposal</br>, there is a belief set S of P, H satisfying G .",
                "In this case, S satisfies Gθ, E, not F. A <br>conditional proposal</br> G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a <br>conditional proposal</br> is used as a new proposal made in response to the proposal G. Example 3.1."
            ],
            "translated_annotated_samples": [
                "Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una <br>propuesta condicional</br> como una extensión de la original.",
                "Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una <br>propuesta condicional</br> (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}.",
                "Si G es una <br>propuesta condicional</br>, existe un conjunto de creencias S de P, H que satisface G.",
                "En este caso, S satisface Gθ, E, no F. Una <br>propuesta condicional</br> G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia.",
                "Cuando (E, F) = (∅, ∅), se utiliza una <br>propuesta condicional</br> como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una <br>propuesta condicional</br> como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una <br>propuesta condicional</br> (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una <br>propuesta condicional</br>, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una <br>propuesta condicional</br> G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una <br>propuesta condicional</br> como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "abductive framework": {
            "translated_key": "Marco abductivo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An <br>abductive framework</br> used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "<br>abductive framework</br> for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An <br>abductive framework</br> for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "An <br>abductive framework</br> used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "<br>abductive framework</br> for nonmonotonic theory change.",
                "An <br>abductive framework</br> for computing knowledge base updates."
            ],
            "translated_annotated_samples": [
                "Un marco abductivo utilizado en este artículo es la <br>abducción extendida</br> introducida por Inoue y Sakama [8, 15].",
                "<br>Marco abductivo</br> para el cambio de teoría no monótona.",
                "Un <br>marco abductivo</br> para calcular actualizaciones de la base de conocimientos."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la <br>abducción extendida</br> introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. <br>Marco abductivo</br> para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un <br>marco abductivo</br> para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    "abducción extendida",
                    "Marco abductivo",
                    "marco abductivo"
                ]
            ]
        },
        "abductive program": {
            "translated_key": "programa abductivo",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An <br>abductive program</br> is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An <br>abductive program</br> P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an <br>abductive program</br> and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an <br>abductive program</br> P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the <br>abductive program</br> P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an <br>abductive program</br> P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an <br>abductive program</br> P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an <br>abductive program</br> and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an <br>abductive program</br> and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the <br>abductive program</br> P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an <br>abductive program</br> and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an <br>abductive program</br> and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an <br>abductive program</br> and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an <br>abductive program</br> of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an <br>abductive program</br> of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an <br>abductive program</br> is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the <br>abductive program</br> Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the <br>abductive program</br> Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an <br>abductive program</br> P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an <br>abductive program</br> P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an <br>abductive program</br>, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an <br>abductive program</br> and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an <br>abductive program</br> P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the <br>abductive program</br> 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an <br>abductive program</br> P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "An <br>abductive program</br> is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "An <br>abductive program</br> P, H is consistent if P is consistent.",
                "Let P, H be an <br>abductive program</br> and G a conjunction as above.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an <br>abductive program</br> P, H satisfying G (with respect to (E, F)).",
                "Consider the <br>abductive program</br> P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← ."
            ],
            "translated_annotated_samples": [
                "Un <br>programa abductivo</br> es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles.",
                "Un <br>programa abductivo</br> P, H es consistente si P es consistente.",
                "Que P, H sean un <br>programa abductivo</br> y G una conjunción como se mencionó anteriormente.",
                "E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un <br>programa abductivo</br> P, H que satisface G (con respecto a (E, F)).",
                "Considera el <br>programa abductivo</br> P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← ."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un <br>programa abductivo</br> es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un <br>programa abductivo</br> P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un <br>programa abductivo</br> y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un <br>programa abductivo</br> P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el <br>programa abductivo</br> P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "dropping condition": {
            "translated_key": "dropping condition",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by <br>dropping condition</br>s.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by <br>dropping condition</br>s. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by <br>dropping condition</br>s. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or <br>dropping condition</br>s.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/<br>dropping condition</br>s. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by <br>dropping condition</br>s; Construct G by <br>dropping condition</br>s.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, <br>dropping condition</br>s, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Let G be a proposal obtained by <br>dropping condition</br>s.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by <br>dropping condition</br>s. 1024 The Sixth Intl.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by <br>dropping condition</br>s. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "Let G be a proposal obtained by either anti-instantiation or <br>dropping condition</br>s.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/<br>dropping condition</br>s. 2."
            ],
            "translated_annotated_samples": [
                "Sea G una propuesta obtenida al eliminar <br>condiciones</br>.",
                "Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl.",
                "Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar <br>condiciones</br>. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000.",
                "Sea G una propuesta obtenida ya sea por anti-instantiación o <br>eliminación de condiciones</br>.",
                "Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/<br>eliminación de condiciones</br>. 2."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar <br>condiciones</br>. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar <br>condiciones</br>. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o <br>eliminación de condiciones</br>. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/<br>eliminación de condiciones</br>. 2. ",
            "candidates": [],
            "error": [
                [
                    "condiciones",
                    "condiciones",
                    "eliminación de condiciones",
                    "eliminación de condiciones"
                ]
            ]
        },
        "anti-instantiation": {
            "translated_key": "anti-instantiación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: <br>anti-instantiation</br>: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "<br>anti-instantiation</br> replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by <br>anti-instantiation</br>.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by <br>anti-instantiation</br>. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by <br>anti-instantiation</br>. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either <br>anti-instantiation</br> or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by <br>anti-instantiation</br>/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by <br>anti-instantiation</br>; Construct G by <br>anti-instantiation</br>.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, <br>anti-instantiation</br>, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Then, G is relaxed to G in the following three ways: <br>anti-instantiation</br>: Construct G such that G θ = G for some substitution θ.",
                "<br>anti-instantiation</br> replaces constants (or terms) with fresh variables.",
                "Let G be a proposal obtained by <br>anti-instantiation</br>.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by <br>anti-instantiation</br>. 2.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by <br>anti-instantiation</br>. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000."
            ],
            "translated_annotated_samples": [
                "Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ.",
                "La <br>anti-instantiación</br> reemplaza constantes (o términos) con variables nuevas.",
                "Sea G una propuesta obtenida por <br>anti-instantiación</br>.",
                "Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por <br>anti-instantiación</br>. 2.",
                "Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por <br>anti-instantiación</br>. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La <br>anti-instantiación</br> reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por <br>anti-instantiación</br>. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por <br>anti-instantiación</br>. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por <br>anti-instantiación</br>. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "inductive generalization": {
            "translated_key": "generalización inductiva",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of <br>inductive generalization</br> [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of <br>inductive generalization</br> [12]."
            ],
            "translated_annotated_samples": [
                "Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de <br>generalización inductiva</br> [12]."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de <br>generalización inductiva</br> [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "minimal explanation": {
            "translated_key": "explicación mínima",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the <br>minimal explanation</br> (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a <br>minimal explanation</br> of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the <br>minimal explanation</br> of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a <br>minimal explanation</br> of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a <br>minimal explanation</br> of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the <br>minimal explanation</br> (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a <br>minimal explanation</br> iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique <br>minimal explanation</br> (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the <br>minimal explanation</br> (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its <br>minimal explanation</br> (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a <br>minimal explanation</br> of O in P ∪ { O ← G }, H using its update program.",
                "If O has a <br>minimal explanation</br> (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "The observation G = flies(tweety) has the <br>minimal explanation</br> (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "If (E, F) is a <br>minimal explanation</br> of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the <br>minimal explanation</br> of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "If (E, F) is a <br>minimal explanation</br> of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "If (E, F) is a <br>minimal explanation</br> of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement."
            ],
            "translated_annotated_samples": [
                "La observación G = flies(tweety) tiene la <br>explicación mínima</br> (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15].",
                "Si (E, F) es una <br>explicación mínima</br> de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}.",
                "En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la <br>explicación mínima</br> de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }.",
                "Si (E, F) es una <br>explicación mínima</br> de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2.",
                "Si (E, F) es una <br>explicación mínima</br> de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la <br>explicación mínima</br> (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una <br>explicación mínima</br> de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la <br>explicación mínima</br> de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una <br>explicación mínima</br> de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una <br>explicación mínima</br> de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "integrity constraint": {
            "translated_key": "restricción de integridad",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an <br>integrity constraint</br> if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an <br>integrity constraint</br> ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an <br>integrity constraint</br> in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an <br>integrity constraint</br> in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "A rule r is an <br>integrity constraint</br> if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an <br>integrity constraint</br> ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an <br>integrity constraint</br> in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an <br>integrity constraint</br> in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}."
            ],
            "translated_annotated_samples": [
                "Una regla r es una <br>restricción de integridad</br> si head(r) = ∅; y r es un hecho si body(r) = ∅.",
                "Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una <br>restricción de integridad</br> ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una <br>restricción de integridad</br> en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una <br>restricción de integridad</br> en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una <br>restricción de integridad</br> si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una <br>restricción de integridad</br> ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una <br>restricción de integridad</br> en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una <br>restricción de integridad</br> en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un programa lógico abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un programa lógico abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "negotiation": {
            "translated_key": "negociación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>negotiation</br> by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated <br>negotiation</br> between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of <br>negotiation</br>.",
                "We provide a <br>negotiation</br> protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated <br>negotiation</br> has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "<br>negotiation</br> usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one <br>negotiation</br>, suppose the following <br>negotiation</br> dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A <br>negotiation</br> proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of <br>negotiation</br>, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as <br>negotiation</br> protocols in particular problems.",
                "Currently, there is no computational logic for automated <br>negotiation</br> which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one <br>negotiation</br> dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a <br>negotiation</br> protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a <br>negotiation</br> protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "<br>negotiation</br> 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of <br>negotiation</br>.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of <br>negotiation</br>.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 <br>negotiation</br> Protocol A <br>negotiation</br> protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a <br>negotiation</br> protocol in our framework.",
                "We suppose one-to-one <br>negotiation</br> between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A <br>negotiation</br> proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A <br>negotiation</br> set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A <br>negotiation</br> set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a <br>negotiation</br> starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and <br>negotiation</br> ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "<br>negotiation</br> ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, <br>negotiation</br> ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a <br>negotiation</br> ends in success/failure.",
                "Formally, the above <br>negotiation</br> protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any <br>negotiation</br> will terminate. 2.",
                "If a <br>negotiation</br> terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and <br>negotiation</br> sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, <br>negotiation</br> will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the <br>negotiation</br> ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated <br>negotiation</br>, this section focuses on comparison with <br>negotiation</br> frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a <br>negotiation</br> policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of <br>negotiation</br>: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of <br>negotiation</br> nor <br>negotiation</br> protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one <br>negotiation</br> as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for <br>negotiation</br> based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based <br>negotiation</br> is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based <br>negotiation</br> among BDI agents.",
                "In one-to-one <br>negotiation</br>, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the <br>negotiation</br> ends in success.",
                "Otherwise, the process is iterated.",
                "In this <br>negotiation</br> processes, the agent A never changes its original objective, so that <br>negotiation</br> ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a <br>negotiation</br> protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the <br>negotiation</br> object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of <br>negotiation</br>.",
                "In their <br>negotiation</br> protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their <br>negotiation</br> protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular <br>negotiation</br> protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in <br>negotiation</br> is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent <br>negotiation</br>. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of <br>negotiation</br>, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a <br>negotiation</br> protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated <br>negotiation</br> on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and <br>negotiation</br>.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated <br>negotiation</br> of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent <br>negotiation</br> via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of <br>negotiation</br>: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "<br>negotiation</br> by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated <br>negotiation</br> between two agents.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of <br>negotiation</br>.",
                "We provide a <br>negotiation</br> protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "INTRODUCTION Automated <br>negotiation</br> has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance)."
            ],
            "translated_annotated_samples": [
                "<br>Negociación por Abducción y Relajación</br> Chiaki Sakama Dept.",
                "Este artículo estudia un marco lógico para la <br>negociación</br> automatizada entre dos agentes.",
                "Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de <br>negociación</br>.",
                "Proporcionamos un protocolo de <br>negociación</br> basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas.",
                "INTRODUCCIÓN La <br>negociación automatizada</br> ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo)."
            ],
            "translated_text": "<br>Negociación por Abducción y Relajación</br> Chiaki Sakama Dept. Este artículo estudia un marco lógico para la <br>negociación</br> automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de <br>negociación</br>. Proporcionamos un protocolo de <br>negociación</br> basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La <br>negociación automatizada</br> ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). ",
            "candidates": [],
            "error": [
                [
                    "Negociación por Abducción y Relajación",
                    "negociación",
                    "negociación",
                    "negociación",
                    "negociación automatizada"
                ]
            ]
        },
        "extend abduction": {
            "translated_key": "extensión de la abducción",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive logic program.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": [
                []
            ]
        },
        "relaxation": {
            "translated_key": "relajación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and <br>relaxation</br> Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and <br>relaxation</br> in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a logic program.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of <br>relaxation</br> in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and <br>relaxation</br>, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by <br>relaxation</br> When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of <br>relaxation</br> for this purpose.",
                "<br>relaxation</br> is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, <br>relaxation</br> expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a <br>relaxation</br> of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and <br>relaxation</br> are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible <br>relaxation</br> or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive logic program in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use <br>relaxation</br> for weakening the constraints in an abductive logic program.",
                "In contrast, we use <br>relaxation</br> for weakening proposals and three different <br>relaxation</br> methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and <br>relaxation</br>.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and <br>relaxation</br>.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "<br>relaxation</br> and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and <br>relaxation</br>.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "<br>relaxation</br> as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "Negotiation by Abduction and <br>relaxation</br> Chiaki Sakama Dept.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and <br>relaxation</br> in cooperative query answering for databases.",
                "Second, we use the technique of <br>relaxation</br> in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and <br>relaxation</br>, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by <br>relaxation</br> When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal."
            ],
            "translated_annotated_samples": [
                "Negociación por Abducción y Relajación Chiaki Sakama Dept.",
                "Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y <br>relajación</br> en la respuesta cooperativa a consultas para bases de datos.",
                "Segundo, utilizamos la técnica de <br>relajación</br> en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original.",
                "Tercero, combinando la abducción extendida y la <br>relajación</br>, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original.",
                "Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y <br>relajación</br> en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un programa lógico. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de <br>relajación</br> en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la <br>relajación</br>, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        },
        "logic program": {
            "translated_key": "programa lógico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Negotiation by Abduction and Relaxation Chiaki Sakama Dept.",
                "Computer and Communication Sciences Wakayama University Sakaedani, Wakayama 640 8510, Japan sakama@sys.wakayama-u.ac.jp Katsumi Inoue National Institute of Informatics 2-1-2 Hitotsubashi, Chiyoda-ku Tokyo 101 8430, Japan ki@nii.ac.jp ABSTRACT This paper studies a logical framework for automated negotiation between two agents.",
                "We suppose an agent who has a knowledge base represented by a <br>logic program</br>.",
                "Then, we introduce methods of constructing counter-proposals in response to proposals made by an agent.",
                "To this end, we combine the techniques of extended abduction in artificial intelligence and relaxation in cooperative query answering for databases.",
                "These techniques are respectively used for producing conditional proposals and neighborhood proposals in the process of negotiation.",
                "We provide a negotiation protocol based on the exchange of these proposals and develop procedures for computing new proposals.",
                "Categories and Subject Descriptors F.4.1 [Mathematical Logic]: Logic and constraint programming;; I.2.11 [Distributed Artificial Intelligence]: Multiagent systems General Terms Theory 1.",
                "INTRODUCTION Automated negotiation has been received increasing attention in multi-agent systems, and a number of frameworks have been proposed in different contexts ([1, 2, 3, 5, 10, 11, 13, 14], for instance).",
                "Negotiation usually proceeds in a series of rounds and each agent makes a proposal at every round.",
                "An agent that received a proposal responds in two ways.",
                "One is a critique which is a remark as to whether or not (parts of) the proposal is accepted.",
                "The other is a counter-proposal which is an alternative proposal made in response to a previous proposal [13].",
                "To see these proposals in one-to-one negotiation, suppose the following negotiation dialogue between a buyer agent B and a seller agent S. (Bi (or Si) represents an utterance of B (or S) in the i-th round.)",
                "B1: I want to buy a personal computer of the brand b1, with the specification of CPU:1GHz, Memory:512MB, HDD: 80GB, and a DVD-RW driver.",
                "I want to get it at the price under 1200 USD.",
                "S1: We can provide a PC with the requested specification if you pay for it by cash.",
                "In this case, however, service points are not added for this special discount.",
                "B2: I cannot pay it by cash.",
                "S2: In a normal price, the requested PC costs 1300 USD.",
                "B3: I cannot accept the price.",
                "My budget is under 1200 USD.",
                "S3: We can provide another computer with the requested specification, except that it is made by the brand b2.",
                "The price is exactly 1200 USD.",
                "B4: I do not want a PC of the brand b2.",
                "Instead, I can downgrade a driver from DVD-RW to CD-RW in my initial proposal.",
                "S4: Ok, I accept your offer.",
                "In this dialogue, in response to the opening proposal B1, the counter-proposal S1 is returned.",
                "In the rest of the dialogue, B2, B3, S4 are critiques, while S2, S3, B4 are counterproposals.",
                "Critiques are produced by evaluating a proposal in a knowledge base of an agent.",
                "In contrast, making counter-proposals involves generating an alternative proposal which is more favorable to the responding agent than the original one.",
                "It is known that there are two ways of producing counterproposals: extending the initial proposal or amending part of the initial proposal.",
                "According to [13], the first type appears in the dialogue: A: I propose that you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "The second type is in the dialogue: A: I propose that I provide you with service Y if you provide me with service X.",
                "B: I propose that I provide you with service X if you provide me with service Z.",
                "A negotiation proceeds by iterating such give-andtake dialogues until it reaches an agreement/disagreement.",
                "In those dialogues, agents generate (counter-)proposals by reasoning on their own goals or objectives.",
                "The objective of the agent A in the above dialogues is to obtain service X.",
                "The agent B proposes conditions to provide the service.",
                "In the process of negotiation, however, it may happen that agents are obliged to weaken or change their initial goals to reach a negotiated compromise.",
                "In the dialogue of 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS a buyer agent and a seller agent presented above, a buyer agent changes its initial goal by downgrading a driver from DVD-RW to CD-RW.",
                "Such behavior is usually represented as specific meta-knowledge of an agent or specified as negotiation protocols in particular problems.",
                "Currently, there is no computational logic for automated negotiation which has general inference rules for producing (counter-)proposals.",
                "The purpose of this paper is to mechanize a process of building (counter-)proposals in one-to-one negotiation dialogues.",
                "We suppose an agent who has a knowledge base represented by a <br>logic program</br>.",
                "We then introduce methods for generating three different types of proposals.",
                "First, we use the technique of extended abduction in artificial intelligence [8, 15] to construct a conditional proposal as an extension of the original one.",
                "Second, we use the technique of relaxation in cooperative query answering for databases [4, 6] to construct a neighborhood proposal as an amendment of the original one.",
                "Third, combining extended abduction and relaxation, conditional neighborhood proposals are constructed as amended extensions of the original proposal.",
                "We develop a negotiation protocol between two agents based on the exchange of these counter-proposals and critiques.",
                "We also provide procedures for computing proposals in logic programming.",
                "This paper is organized as follows.",
                "Section 2 introduces a logical framework used in this paper.",
                "Section 3 presents methods for constructing proposals, and provides a negotiation protocol.",
                "Section 4 provides methods for computing proposals in logic programming.",
                "Section 5 discusses related works, and Section 6 concludes the paper. 2.",
                "PRELIMINARIES Logic programs considered in this paper are extended disjunctive programs (EDP) [7].",
                "An EDP (or simply a program) is a set of rules of the form: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) where each Li is a positive/negative literal, i.e., A or ¬A for an atom A, and not is negation as failure (NAF). not L is called an NAF-literal.",
                "The symbol ; represents disjunction.",
                "The left-hand side of the rule is the head, and the right-hand side is the body.",
                "For each rule r of the above form, head(r), body+ (r) and body− (r) denote the sets of literals {L1, . . . , Ll}, {Ll+1, . . . , Lm}, and {Lm+1, . . . , Ln}, respectively.",
                "Also, not body− (r) denotes the set of NAF-literals {not Lm+1, . . . , not Ln}.",
                "A disjunction of literals and a conjunction of (NAF-)literals in a rule are identified with its corresponding sets of literals.",
                "A rule r is often written as head(r) ← body+ (r), not body− (r) or head(r) ← body(r) where body(r) = body+ (r)∪not body− (r).",
                "A rule r is disjunctive if head(r) contains more than one literal.",
                "A rule r is an integrity constraint if head(r) = ∅; and r is a fact if body(r) = ∅.",
                "A program is NAF-free if no rule contains NAF-literals.",
                "Two rules/literals are identified with respect to variable renaming.",
                "A substitution is a mapping from variables to terms θ = {x1/t1, . . . , xn/tn}, where x1, . . . , xn are distinct variables and each ti is a term distinct from xi.",
                "Given a conjunction G of (NAF-)literals, Gθ denotes the conjunction obtained by applying θ to G. A program, rule, or literal is ground if it contains no variable.",
                "A program P with variables is a shorthand of its ground instantiation Ground(P), the set of ground rules obtained from P by substituting variables in P by elements of its Herbrand universe in every possible way.",
                "The semantics of an EDP is defined by the answer set semantics [7].",
                "Let Lit be the set of all ground literals in the language of a program.",
                "Suppose a program P and a set of literals S(⊆ Lit).",
                "Then, the reduct P S is the program which contains the ground rule head(r) ← body+ (r) iff there is a rule r in Ground(P) such that body− (r)∩S = ∅.",
                "Given an NAF-free EDP P, Cn(P) denotes the smallest set of ground literals which is (i) closed under P, i.e., for every ground rule r in Ground(P), body(r) ⊆ Cn(P) implies head(r) ∩ Cn(P) = ∅; and (ii) logically closed, i.e., it is either consistent or equal to Lit.",
                "Given an EDP P and a set S of literals, S is an answer set of P if S = Cn(P S ).",
                "A program has none, one, or multiple answer sets in general.",
                "An answer set is consistent if it is not Lit.",
                "A program P is consistent if it has a consistent answer set; otherwise, P is inconsistent.",
                "Abductive logic programming [9] introduces a mechanism of hypothetical reasoning to logic programming.",
                "An abductive framework used in this paper is the extended abduction introduced by Inoue and Sakama [8, 15].",
                "An abductive program is a pair P, H where P is an EDP and H is a set of literals called abducibles.",
                "When a literal L ∈ H contains variables, any instance of L is also an abducible.",
                "An abductive program P, H is consistent if P is consistent.",
                "Throughout the paper, abductive programs are assumed to be consistent unless stated otherwise.",
                "Let G = L1, . . . , Lm, not Lm+1, . . . , not Ln be a conjunction, where all variables in G are existentially quantified at the front and range-restricted, i.e., every variable in Lm+1, . . . , Ln appears in L1, . . . , Lm.",
                "A set S of ground literals satisfies the conjunction G if { L1θ, . . . , Lmθ } ⊆ S and { Lm+1θ, . . . , Lnθ }∩ S = ∅ for some ground instance Gθ with a substitution θ.",
                "Let P, H be an abductive program and G a conjunction as above.",
                "A pair (E, F) is an explanation of an observation G in P, H if1 1. (P \\ F) ∪ E has an answer set which satisfies G, 2. (P \\ F) ∪ E is consistent, 3.",
                "E and F are sets of ground literals such that E ⊆ H\\P and F ⊆ H ∩ P. When (P \\ F) ∪ E has an answer set S satisfying the above three conditions, S is called a belief set of an abductive program P, H satisfying G (with respect to (E, F)).",
                "Note that if P has a consistent answer set S satisfying G, S is also a belief set of P, H satisfying G with respect to (E, F) = (∅, ∅).",
                "Extended abduction introduces/removes hypotheses to/from a program to explain an observation.",
                "Note that normal abduction (as in [9]) considers only introducing hypotheses to explain an observation.",
                "An explanation (E, F) of an observation G is called minimal if for any explanation (E , F ) of G, E ⊆ E and F ⊆ F imply E = E and F = F. Example 2.1.",
                "Consider the abductive program P, H : P : flies(x) ← bird(x), not ab(x) , ab(x) ← broken-wing(x) , bird(tweety) ← , bird(opus) ← , broken-wing(tweety) ← .",
                "H : broken-wing(x) .",
                "The observation G = flies(tweety) has the minimal explanation (E, F) = (∅, {broken-wing(tweety)}). 1 This defines credulous explanations [15].",
                "Skeptical explanations are used in [8].",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1023 3.",
                "NEGOTIATION 3.1 Conditional Proposals by Abduction We suppose an agent who has a knowledge base represented by an abductive program P, H .",
                "A program P consists of two types of knowledge, belief B and desire D, where B represents objective knowledge of an agent, while D represents subjective knowledge in general.",
                "We define P = B ∪ D, but do not distinguish B and D if such distinction is not important in the context.",
                "In contrast, abducibles H are used for representing permissible conditions to make a compromise in the process of negotiation.",
                "Definition 3.1.",
                "A proposal G is a conjunction of literals and NAF-literals: L1, . . . , Lm, not Lm+1, . . . , not Ln where every variable in G is existentially quantified at the front and range-restricted.",
                "In particular, G is called a critique if G = accept or G = reject where accept and reject are the reserved propositions.",
                "A counter-proposal is a proposal made in response to a proposal.",
                "Definition 3.2.",
                "A proposal G is accepted in an abductive program P, H if P has an answer set satisfying G. When a proposal is not accepted, abduction is used for seeking conditions to make it acceptable.",
                "Definition 3.3.",
                "Let P, H be an abductive program and G a proposal.",
                "If (E, F) is a minimal explanation of Gθ for some substitution θ in P, H , the conjunction G : Gθ, E, not F is called a conditional proposal (for G), where E, not F represents the conjunction: A1, . . . , Ak, not Ak+1, . . . , not Al for E = {A1, . . . , Ak} and F = { Ak+1, . . . , Al }.",
                "Proposition 3.1.",
                "Let P, H be an abductive program and G a proposal.",
                "If G is a conditional proposal, there is a belief set S of P, H satisfying G .",
                "Proof.",
                "When G = Gθ, E, not F, (P \\ F) ∪ E has a consistent answer set S satisfying Gθ and E ∩ F = ∅.",
                "In this case, S satisfies Gθ, E, not F. A conditional proposal G provides a minimal requirement for accepting the proposal G. If Gθ has multiple minimal explanations, several conditional proposals exist accordingly.",
                "When (E, F) = (∅, ∅), a conditional proposal is used as a new proposal made in response to the proposal G. Example 3.1.",
                "An agent seeks a position of a research assistant at the computer department of a university with the condition that the salary is at least 50,000 USD per year.",
                "The agent makes his/her request as the proposal:2 G = assist(compt dept), salary(x), x ≥ 50, 000.",
                "The university has the abductive program P, H : P : salary(40, 000) ← assist(compt dept), not has PhD, salary(60, 000) ← assist(compt dept), has PhD, salary(50, 000) ← assist(math dept), salary(55, 000) ← system admin(compt dept), 2 For notational convenience, we often include mathematical (in)equations in proposals/programs.",
                "They are written by literals, for instance, x ≥ y by geq(x, y) with a suitable definition of the predicate geq. employee(x) ← assist(x), employee(x) ← system admin(x), assist(compt dept); assist(math dept) ; system admin(compt dept) ←, H : has PhD, where available positions are represented by disjunction.",
                "According to P, the base salary of a research assistant at the computer department is 40,000 USD, but if he/she has PhD, it is 60,000 USD.",
                "In this case, (E, F) = ({has PhD}, ∅) becomes the minimal explanation of Gθ = assist(compt dept), salary(60, 000) with θ = { x/60, 000 }.",
                "Then, the conditional proposal made by the university becomes assist(compt dept), salary(60, 000), has PhD . 3.2 Neighborhood Proposals by Relaxation When a proposal is unacceptable, an agent tries to construct a new counter-proposal by weakening constraints in the initial proposal.",
                "We use techniques of relaxation for this purpose.",
                "Relaxation is used as a technique of cooperative query answering in databases [4, 6].",
                "When an original query fails in a database, relaxation expands the scope of the query by relaxing the constraints in the query.",
                "This allows the database to return neighborhood answers which are related to the original query.",
                "We use the technique for producing proposals in the process of negotiation.",
                "Definition 3.4.",
                "Let P, H be an abductive program and G a proposal.",
                "Then, G is relaxed to G in the following three ways: Anti-instantiation: Construct G such that G θ = G for some substitution θ.",
                "Dropping conditions: Construct G such that G ⊂ G. Goal replacement: If G is a conjunction G1, G2, where G1 and G2 are conjunctions, and there is a rule L ← G1 in P such that G1θ = G1 for some substitution θ, then build G as Lθ, G2.",
                "Here, Lθ is called a replaced literal.",
                "In each case, every variable in G is existentially quantified at the front and range-restricted.",
                "Anti-instantiation replaces constants (or terms) with fresh variables.",
                "Dropping conditions eliminates some conditions in a proposal.",
                "Goal replacement replaces the condition G1 in G with a literal Lθ in the presence of a rule L ← G1 in P under the condition G1θ = G1.",
                "All these operations generalize proposals in different ways.",
                "Each G obtained by these operations is called a relaxation of G. It is worth noting that these operations are also used in the context of inductive generalization [12].",
                "The relaxed proposal can produce new offers which are neighbor to the original proposal.",
                "Definition 3.5.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by anti-instantiation.",
                "If P has an answer set S which satisfies G θ for some substitution θ and G θ = G, G θ is called a neighborhood proposal by anti-instantiation. 2.",
                "Let G be a proposal obtained by dropping conditions.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by dropping conditions. 1024 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 3.",
                "Let G be a proposal obtained by goal replacement.",
                "For a replaced literal L ∈ G and a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "If P has an answer set S which satisfies G θ for some substitution θ, G θ is called a neighborhood proposal by goal replacement.",
                "Example 3.2. (cont.",
                "Example 3.1) Given the proposal G = assist(compt dept), salary(x), x ≥ 50, 000, • G1 = assist(w), salary(x), x ≥ 50, 000 is produced by substituting compt dept with a variable w. As G1θ1 = assist(math dept), salary(50, 000) with θ1 = { w/math dept } is satisfied by an answer set of P, G1θ1 becomes a neighborhood proposal by anti-instantiation. • G2 = assist(compt dept), salary(x) is produced by dropping the salary condition x ≥ 50, 000.",
                "As G2θ2 = assist(compt dept), salary(40, 000) with θ2 = { x/40, 000 } is satisfied by an answer set of P, G2θ2 becomes a neighborhood proposal by dropping conditions. • G3 = employee(compt dept), salary(x), x ≥ 50, 000 is produced by replacing assist(compt dept) with employee(compt dept) using the rule employee(x) ← assist(x) in P. By G3 and the rule employee(x) ← system admin(x) in P, G3 = sys admin(compt dept), salary(x), x ≥ 50, 000 is produced.",
                "As G3 θ3 = sys admin(compt dept), salary(55, 000) with θ3 = { x/55, 000 } is satisfied by an answer set of P, G3 θ3 becomes a neighborhood proposal by goal replacement.",
                "Finally, extended abduction and relaxation are combined to produce conditional neighborhood proposals.",
                "Definition 3.6.",
                "Let P, H be an abductive program and G a proposal. 1.",
                "Let G be a proposal obtained by either anti-instantiation or dropping conditions.",
                "If (E, F) is a minimal explanation of G θ(= G) for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by anti-instantiation/dropping conditions. 2.",
                "Let G be a proposal obtained by goal replacement.",
                "Suppose G as in Definition 3.5(3).",
                "If (E, F) is a minimal explanation of G θ for some substitution θ, the conjunction G θ, E, not F is called a conditional neighborhood proposal by goal replacement.",
                "A conditional neighborhood proposal reduces to a neighborhood proposal when (E, F) = (∅, ∅). 3.3 Negotiation Protocol A negotiation protocol defines how to exchange proposals in the process of negotiation.",
                "This section presents a negotiation protocol in our framework.",
                "We suppose one-to-one negotiation between two agents who have a common ontology and the same language for successful communication.",
                "Definition 3.7.",
                "A proposal L1, ..., Lm, not Lm+1, ..., not Ln violates an integrity constraint ← body+ (r), not body− (r) if for any substitution θ, there is a substitution σ such that body+ (r)σ ⊆ { L1θ, . . . , Lmθ }, body− (r)σ∩{ L1θ, . . . , Lmθ } = ∅, and body− (r)σ ⊆ { Lm+1θ, . . . , Lnθ }.",
                "Integrity constraints are conditions which an agent should satisfy, so that they are used to explain why an agent does not accept a proposal.",
                "A negotiation proceeds in a series of rounds.",
                "Each i-th round (i ≥ 1) consists of a proposal Gi 1 made by one agent Ag1 and another proposal Gi 2 made by the other agent Ag2.",
                "Definition 3.8.",
                "Let P1, H1 be an abductive program of an agent Ag1 and Gi 2 a proposal made by Ag2 at the i-th round.",
                "A critique set of Ag1 (at the i-th round) is a set CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r is an integrity constraint in P1 and Gj 2 violates r } where j = i − 1 or i, and CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅.",
                "A critique set of an agent Ag1 accumulates integrity constraints which are violated by proposals made by another agent Ag2.",
                "CSi 2(P2, Gj 1) is defined in the same manner.",
                "Definition 3.9.",
                "Let Pk, Hk be an abductive program of an agent Agk and Gj a proposal, which is not a critique, made by any agent at the j(≤ i)-th round.",
                "A negotiation set of Agk (at the i-th round) is a triple NSi k = (Si c, Si n, Si cn), where Si c is the set of conditional proposals, Si n is the set of neighborhood proposals, and Si cn is the set of conditional neighborhood proposals, produced by Gj and Pk, Hk .",
                "A negotiation set represents the space of possible proposals made by an agent.",
                "Si x (x ∈ {c, n, cn}) accumulates proposals produced by Gj (1 ≤ j ≤ i) according to Definitions 3.3, 3.5, and 3.6.",
                "Note that an agent can construct counter-proposals by modifying its own previous proposals or another agents proposals.",
                "An agent Agk accumulates proposals that are made by Agk but are rejected by another agent, in the failed proposal set FP i k (at the i-th round), where FP 0 k = ∅.",
                "Suppose two agents Ag1 and Ag2 who have abductive programs P1, H1 and P2, H2 , respectively.",
                "Given a proposal G1 1 which is satisfied by an answer set of P1, a negotiation starts.",
                "In response to the proposal Gi 1 made by Ag1 at the i-th round, Ag2 behaves as follows. 1.",
                "If Gi 1 = accept, an agreement is reached and negotiation ends in success. 2.",
                "Else if Gi 1 = reject, put FP i 2 = FPi−1 2 ∪{Gi−1 2 } where {G0 2} = ∅.",
                "Proceed to the step 4(b). 3.",
                "Else if P2 has an answer set satisfying Gi 1, Ag2 returns Gi 2 = accept to Ag1.",
                "Negotiation ends in success. 4.",
                "Otherwise, Ag2 behaves as follows.",
                "Put FP i 2 = FPi−1 2 . (a) If Gi 1 violates an integrity constraint in P2, return the critique Gi 2 = reject to Ag1, together with the critique set CSi 2(P2, Gi 1). (b) Otherwise, construct NSi 2 as follows. (i) Produce Si c. Let μ(Si c) = { p | p ∈ Si c \\ FPi 2 and p satisfies the constraints in CSi 1(P1, Gi−1 2 )}.",
                "If μ(Si c) = ∅, select one from μ(Si c) and propose it as Gi 2 to Ag1; otherwise, go to (ii). (ii) Produce Si n. If μ(Si n) = ∅, select one from μ(Si n) and propose it as Gi 2 to Ag1; otherwise, go to (iii). (iii) Produce Si cn.",
                "If μ(Si cn) = ∅, select one from μ(Si cn) and propose it as Gi 2 to Ag1; otherwise, negotiation ends in failure.",
                "This means that Ag2 can make no counter-proposal or every counterproposal made by Ag2 is rejected by Ag1.",
                "In the step 4(a), Ag2 rejects the proposal Gi 1 and returns the reason of rejection as a critique set.",
                "This helps for Ag1 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1025 in preparing a next counter-proposal.",
                "In the step 4(b), Ag2 constructs a new proposal.",
                "In its construction, Ag2 should take care of the critique set CSi 1(P1, Gi−1 2 ), which represents integrity constraints, if any, accumulated in previous rounds, that Ag1 must satisfy.",
                "Also, FP i 2 is used for removing proposals which have been rejected.",
                "Construction of Si x (x ∈ {c, n, cn}) in NSi 2 is incrementally done by adding new counter-proposals produced by Gi 1 or Gi−1 2 to Si−1 x .",
                "For instance, Si n in NSi 2 is computed as Si n = Si−1 n ∪{ p | p is a neighborhood proposal made by Gi 1 } ∪ { p | p is a neighborhood proposal made by Gi−1 2 }, where S0 n = ∅.",
                "That is, Si n is constructed from Si−1 n by adding new proposals which are obtained by modifying the proposal Gi 1 made by Ag1 at the i-th round or modifying the proposal Gi−1 2 made by Ag2 at the (i − 1)-th round.",
                "Si c and Si cn are obtained as well.",
                "In the above protocol, an agent produces Si c at first, secondly Si n, and finally Si cn.",
                "This strategy seeks conditions which satisfy the given proposal, prior to neighborhood proposals which change the original one.",
                "Another strategy, which prefers neighborhood proposals to conditional ones, is also considered.",
                "Conditional neighborhood proposals are to be considered in the last place, since they differ from the original one to the maximal extent.",
                "The above protocol produces the candidate proposals in Si x for each x ∈ {c, n, cn} at once.",
                "We can consider a variant of the protocol in which each proposal in Si x is constructed one by one (see Example 3.3).",
                "The above protocol is repeatedly applied to each one of the two negotiating agents until a negotiation ends in success/failure.",
                "Formally, the above negotiation protocol has the following properties.",
                "Theorem 3.2.",
                "Let Ag1 and Ag2 be two agents having abductive programs P1, H1 and P2, H2 , respectively. 1.",
                "If P1, H1 and P2, H2 are function-free (i.e., both Pi and Hi contain no function symbol), any negotiation will terminate. 2.",
                "If a negotiation terminates with agreement on a proposal G, both P1, H1 and P2, H2 have belief sets satisfying G. Proof. 1.",
                "When an abductive program is function-free, abducibles and negotiation sets are both finite.",
                "Moreover, if a proposal is once rejected, it is not proposed again by the function μ.",
                "Thus, negotiation will terminate in finite steps. 2.",
                "When a proposal G is made by Ag1, P1, H1 has a belief set satisfying G. If the agent Ag2 accepts the proposal G, it is satisfied by an answer set of P2 which is also a belief set of P2, H2 .",
                "Example 3.3.",
                "Suppose a buying-selling situation in the introduction.",
                "A seller agent has the abductive program Ps, Hs in which Ps consists of belief Bs and desire Ds: Bs : pc(b1, 1G, 512M, 80G) ; pc(b2, 1G, 512M, 80G) ←,(1) dvd-rw ; cd-rw ←, (2) Ds : normal price(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) normal price(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) normal price(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) price(x) ← normal price(x), add point, (6) price(x ∗ 0.9) ← normal price(x), pay cash, not add point,(7) add point ←, (8) Hs : add point, pay cash.",
                "Here, (1) and (2) represent selection of products.",
                "The atom pc(b1, 1G, 512M, 80G) represents that the seller agent has a PC of the brand b1 such that CPU is 1GHz, memory is 512MB, and HDD is 80GB.",
                "Prices of products are represented as desire of the seller.",
                "The rules (3) - (5) are normal prices of products.",
                "A normal price is a selling price on the condition that service points are added (6).",
                "On the other hand, a discount price is applied if the paying method is cash and no service point is added (7).",
                "The fact (8) represents the addition of service points.",
                "This service would be withdrawn in case of discount prices, so add point is specified as an abducible.",
                "A buyer agent has the abductive program Pb, Hb in which Pb consists of belief Bb and desire Db: Bb : drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db : pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← not dvd-rw, (14) ← pay cash, (15) ← price(x), x > 1200, (16) Hb : dvd-rw.",
                "Rules (12) - (16) are the buyers desire.",
                "Among them, (15) and (16) impose constraints for buying a PC.",
                "A DVD-RW is specified as an abducible which is subject to concession. (1st round) First, the following proposal is given by the buyer agent: G1 b : pc(b1, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has no answer set which satisfies G1 b , the seller agent cannot accept the proposal.",
                "The seller takes an action of making a counter-proposal and performs abduction.",
                "As a result, the seller finds the minimal explanation (E, F) = ({ pay cash }, { add point }) which explains G1 b θ1 with θ1 = { x/1170 }.",
                "The seller constructs the conditional proposal: G1 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1170), pay cash, not add point and offers it to the buyer. (2nd round) The buyer does not accept G1 s because he/she cannot pay it by cash (15).",
                "The buyer then returns the critique G2 b = reject to the seller, together with the critique set CS2 b (Pb, G1 s) = {(15)}.",
                "In response to this, the seller tries to make another proposal which satisfies the constraint in this critique set.",
                "As G1 s is stored in FP 2 s and no other conditional proposal satisfying the buyers requirement exists, the seller produces neighborhood proposals.",
                "He/she relaxes G1 b by dropping x ≤ 1200 in the condition, and produces pc(b1, 1G, 512M, 80G), dvd-rw, price(x).",
                "As Ps has an answer set which satisfies G2 s : pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) the seller offers G2 s as a new counter-proposal. (3rd round) The buyer does not accept G2 s because he/she cannot pay more than 1200USD (16).",
                "The buyer again returns the critique G3 b = reject to the seller, together with the critique set CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}.",
                "The seller then considers another proposal by replacing b1 with a variable w, G1 b now becomes pc(w, 1G, 512M, 80G), dvd-rw, price(x), x ≤ 1200.",
                "As Ps has an answer set which satisfies G3 s : pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), the seller offers G3 s as a new counter-proposal. (4th round) The buyer does not accept G3 s because a PC of the brand b2 is out of his/her interest and Pb has no answer set satisfying G3 s. Then, the buyer makes a concession by changing his/her original goal.",
                "The buyer relaxes G1 b by goal replacement using the rule (9) in Pb, and produces pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200.",
                "Using (10), the following proposal is produced: pc(b1, 1G, 512M, 80G), cd-rw, price(x), x ≤ 1200.",
                "As Pb \\ { dvd-rw } has a consistent answer set satisfying the above proposal, the buyer proposes the conditional neighborhood proposal G4 b : pc(b1, 1G, 512M, 80G), cd-rw, not dvd-rw, price(x), x ≤ 1200 to the seller agent.",
                "Since Ps also has an answer set satisfying G4 b , the seller accepts it and sends the message G4 s = accept to the buyer.",
                "Thus, the negotiation ends in success. 4.",
                "COMPUTATION In this section, we provide methods of computing proposals in terms of answer sets of programs.",
                "We first introduce some definitions from [15].",
                "Definition 4.1.",
                "Given an abductive program P, H , the set UR of update rules is defined as: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P } , where L, +L, and −L are new atoms uniquely associated with every L ∈ H. The atoms +L and −L are called update atoms.",
                "By the definition, the atom L becomes true iff L is not true.",
                "The pair of rules L ← not L and L ← not L specify the situation that an abducible L is true or not.",
                "When p(x) ∈ H and p(a) ∈ P but p(t) ∈ P for t = a, the rule +L ← L precisely becomes +p(t) ← p(t) for any t = a.",
                "In this case, the rule is shortly written as +p(x) ← p(x), x = a.",
                "Generally, the rule becomes +p(x) ← p(x), x = t1, . . . , x = tn for n such instances.",
                "The rule +L ← L derives the atom +L if an abducible L which is not in P is to be true.",
                "In contrast, the rule −L ← not L derives the atom −L if an abducible L which is in P is not to be true.",
                "Thus, update atoms represent the change of truth values of abducibles in a program.",
                "That is, +L means the introduction of L, while −L means the deletion of L. When an abducible L contains variables, the associated update atom +L or −L is supposed to have exactly the same variables.",
                "In this case, an update atom is semantically identified with its ground instances.",
                "The set of all update atoms associated with the abducibles in H is denoted by UH, and UH = UH+ ∪ UH− where UH+ (resp.",
                "UH− ) is the set of update atoms of the form +L (resp. −L).",
                "Definition 4.2.",
                "Given an abductive program P, H , its update program UP is defined as the program UP = (P \\ H) ∪ UR .",
                "An answer set S of UP is called U-minimal if there is no answer set T of UP such that T ∩ UH ⊂ S ∩ UH.",
                "By the definition, U-minimal answer sets exist whenever UP has answer sets.",
                "Update programs are used for computing (minimal) explanations of an observation.",
                "Given an observation G as a conjunction of literals and NAF-literals possibly containing variables, we introduce a new ground literal O together with the rule O ← G. In this case, O has an explanation (E, F) iff G has the same explanation.",
                "With this replacement, an observation is assumed to be a ground literal without loss of generality.",
                "In what follows, E+ = { +L | L ∈ E } and F − = { −L | L ∈ F } for E ⊆ H and F ⊆ H. Proposition 4.1. ([15]) Let P, H be an abductive program, UP its update program, and G a ground literal representing an observation.",
                "Then, a pair (E, F) is an explanation of G iff UP ∪ { ← not G } has a consistent answer set S such that E+ = S ∩ UH+ and F− = S ∩ UH− .",
                "In particular, (E, F) is a minimal explanation iff S is a U-minimal answer set.",
                "Example 4.1.",
                "To explain the observation G = flies(t) in the program P of Example 2.1, first construct the update program UP of P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) .",
                "Next, consider the program UP ∪ { ← not flies(t) }.",
                "It has the single U-minimal answer set: S = { bird(t), bird(o), flies(t), flies(o), broken-wing(t), broken-wing(o), −broken-wing(t) }.",
                "The unique minimal explanation (E, F) = (∅, {broken-wing(t)}) of G is expressed by the update atom −broken-wing(t) in S ∩ UH− .",
                "Proposition 4.2.",
                "Let P, H be an abductive program and G a ground literal representing an observation.",
                "If P ∪ { ← not G } has a consistent answer set S, G has the minimal explanation (E, F) = (∅, ∅) and S satisfies G. Now we provide methods for computing (counter-)proposals.",
                "First, conditional proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sc of proposals.",
                "If G is a ground literal, compute its minimal explanation (E, F) in P, H using the update program.",
                "Put G, E, not F in Sc.",
                "Else if G is a conjunction possibly containing variables, consider the abductive program 3 t represents tweety and o represents opus.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1027 P ∪{ O ← G }, H with a ground literal O. Compute a minimal explanation of O in P ∪ { O ← G }, H using its update program.",
                "If O has a minimal explanation (E, F) with a substitution θ for variables in G, put Gθ, E, not F in Sc.",
                "Next, neighborhood proposals are computed as follows. input : an abductive program P, H , a proposal G; output : a set Sn of proposals. % neighborhood proposals by anti-instantiation; Construct G by anti-instantiation.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ and G θ = G, put G θ in Sn. % neighborhood proposals by dropping conditions; Construct G by dropping conditions.",
                "If G is a ground literal and the program P ∪ { ← not G } has a consistent answer set, put G in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a ground literal O, if P ∪{ O ← G }∪{ ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn. % neighborhood proposals by goal replacement; Construct G by goal replacement.",
                "If G is a ground literal and there is a rule H ← B in P such that G = Hσ and Bσ = G for some substitution σ, put G = Bσ.",
                "If P ∪ { ← not G } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Else if G is a conjunction possibly containing variables, do the following.",
                "For a replaced literal L ∈ G , if there is a rule H ← B in P such that L = Hσ and (G \\ {L}) ∪ Bσ = G for some substitution σ, put G = (G \\ {L}) ∪ Bσ.",
                "For a ground literal O, if P ∪ { O ← G } ∪ { ← not O } has a consistent answer set satisfying G θ with a substitution θ, put G θ in Sn.",
                "Theorem 4.3.",
                "The set Sc (resp.",
                "Sn) computed above coincides with the set of conditional proposals (resp. neighborhood proposals).",
                "Proof.",
                "The result for Sc follows from Definition 3.3 and Proposition 4.1.",
                "The result for Sn follows from Definition 3.5 and Proposition 4.2.",
                "Conditional neighborhood proposals are computed by combining the above two procedures.",
                "Those proposals are computed at each round.",
                "Note that the procedure for computing Sn contains some nondeterministic choices.",
                "For instance, there are generally several candidates of literals to relax in a proposal.",
                "Also, there might be several rules in a program for the usage of goal replacement.",
                "In practice, an agent can prespecify literals in a proposal for possible relaxation or rules in a program for the usage of goal replacement. 5.",
                "RELATED WORK As there are a number of literature on automated negotiation, this section focuses on comparison with negotiation frameworks based on logic and argumentation.",
                "Sadri et al. [14] use abductive logic programming as a representation language of negotiating agents.",
                "Agents negotiate using common dialogue primitives, called dialogue moves.",
                "Each agent has an abductive <br>logic program</br> in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "The behavior of agents is regulated by an observe-think-act cycle.",
                "Once a dialogue move is uttered by an agent, another agent that observed the utterance thinks and acts using a proof procedure.",
                "Their approach and ours both employ abductive logic programming as a platform of agent reasoning, but the use of it is quite different.",
                "First, they use abducibles to specify dialogue primitives of the form tell(utterer, receiver, subject, identifier, time), while we use abducibles to specify arbitrary permissible hypotheses to construct conditional proposals.",
                "Second, a program pre-specifies a plan to carry out in order to achieve a goal, together with available/missing resources in the context of resource-exchanging problems.",
                "This is in contrast with our method in which possible counter-proposals are newly constructed in response to a proposal made by an agent.",
                "Third, they specify a negotiation policy inside a program (as integrity constraints), while we give a protocol independent of individual agents.",
                "They provide an operational model that completely specifies the behavior of agents in terms of agent cycle.",
                "We do not provide such a complete specification of the behavior of agents.",
                "Our primary interest is to mechanize construction of proposals.",
                "Bracciali and Torroni [2] formulate abductive agents that have knowledge in abductive logic programs.",
                "To explain an observation, two agents communicate by exchanging integrity constraints.",
                "In the process of communication, an agent can revise its own integrity constraints according to the information provided by the other agent.",
                "A set IC of integrity constraints relaxes a set IC (or IC tightens IC ) if any observation that can be proved with respect to IC can also be proved with respect to IC .",
                "For instance, IC : ← a, b, c relaxes IC : ← a, b.",
                "Thus, they use relaxation for weakening the constraints in an abductive <br>logic program</br>.",
                "In contrast, we use relaxation for weakening proposals and three different relaxation methods, anti-instantiation, dropping conditions, and goal replacement, are considered.",
                "Their goal is to explain an observation by revising integrity constraints of an agent through communication, while we use integrity constraints for communication to explain critiques and help other agents in making counter-proposals.",
                "Meyer et al. [11] introduce a logical framework for negotiating agents.",
                "They introduce two different modes of negotiation: concession and adaptation.",
                "They provide rational postulates to characterize negotiated outcomes between two agents, and describe methods for constructing outcomes.",
                "They provide logical conditions for negotiated outcomes to satisfy, but they do not describe a process of negotiation nor negotiation protocols.",
                "Moreover, they represent agents by classical propositional theories, which is different from our abductive logic programming framework.",
                "Foo et al. [5] model one-to-one negotiation as a one-time encounter between two extended logic programs.",
                "An agent offers an answer set of its program, and their mutual deal is regarded as a trade on their answer sets.",
                "Starting from the initial agreement set S∩T for an answer set S of an agent and an answer set T of another agent, each agent extends this set to reflect its own demand while keeping consistency with demand of the other agent.",
                "Their algorithm returns new programs having answer sets which are consistent with each other and keep the agreement set.",
                "The work is extended to repeated encounters in [3].",
                "In their framework, two agents exchange answer sets to produce a common belief set, which is different from our framework of exchanging proposals.",
                "There are a number of proposals for negotiation based 1028 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) on argumentation.",
                "An advantage of argumentation-based negotiation is that it constructs a proposal with arguments supporting the proposal [1].",
                "The existence of arguments is useful to convince other agents of reasons why an agent offers (counter-)proposals or returns critiques.",
                "Parsons et al. [13] develop a logic of argumentation-based negotiation among BDI agents.",
                "In one-to-one negotiation, an agent A generates a proposal together with its arguments, and passes it to another agent B.",
                "The proposal is evaluated by B which attempts to build arguments against it.",
                "If it conflicts with Bs interest, B informs A of its objection by sending back its attacking argument.",
                "In response to this, A tries to find an alternative way of achieving its original objective, or a way of persuading B to drop its objection.",
                "If either type of argument can be found, A will submit it to B.",
                "If B finds no reason to reject the new proposal, it will be accepted and the negotiation ends in success.",
                "Otherwise, the process is iterated.",
                "In this negotiation processes, the agent A never changes its original objective, so that negotiation ends in failure if A fails to find an alternative way of achieving the original objective.",
                "In our framework, when a proposal is rejected by another agent, an agent can weaken or change its objective by abduction and relaxation.",
                "Our framework does not have a mechanism of argumentation, but reasons for critiques can be informed by responding critique sets.",
                "Kakas and Moraitis [10] propose a negotiation protocol which integrates abduction within an argumentation framework.",
                "A proposal contains an offer corresponding to the negotiation object, together with supporting information representing conditions under which this offer is made.",
                "Supporting information is computed by abduction and is used for constructing conditional arguments during the process of negotiation.",
                "In their negotiation protocol, when an agent cannot satisfy its own goal, the agent considers the other agents goal and searches for conditions under which the goal is acceptable.",
                "Our present approach differs from theirs in the following points.",
                "First, they use abduction to seek conditions to support arguments, while we use abduction to seek conditions for proposals to accept.",
                "Second, in their negotiation protocol, counter-proposals are chosen among candidates based on preference knowledge of an agent at meta-level, which represents policy under which an agent uses its object-level decision rules according to situations.",
                "In our framework, counter-proposals are newly constructed using abduction and relaxation.",
                "The method of construction is independent of particular negotiation protocols.",
                "As [2, 10, 14], abduction or abductive logic programming used in negotiation is mostly based on normal abduction.",
                "In contrast, our approach is based on extended abduction which can not only introduce hypotheses but remove them from a program.",
                "This is another important difference.",
                "Relaxation and neighborhood query answering are devised to make databases cooperative with their users [4, 6].",
                "In this sense, those techniques have the spirit similar to cooperative problem solving in multi-agent systems.",
                "As far as the authors know, however, there is no study which applies those technique to agent negotiation. 6.",
                "CONCLUSION In this paper we proposed a logical framework for negotiating agents.",
                "To construct proposals in the process of negotiation, we combined the techniques of extended abduction and relaxation.",
                "It was shown that these two operations are used for general inference rules in producing proposals.",
                "We developed a negotiation protocol between two agents based on exchange of proposals and critiques, and provided procedures for computing proposals in abductive logic programming.",
                "This enables us to realize automated negotiation on top of the existing answer set solvers.",
                "The present framework does not have a mechanism of selecting an optimal (counter-)proposal among different alternatives.",
                "To compare and evaluate proposals, an agent must have preference knowledge of candidate proposals.",
                "Further elaboration to maximize the utility of agents is left for future study. 7.",
                "REFERENCES [1] L. Amgoud, S. Parsons, and N. Maudet.",
                "Arguments, dialogue, and negotiation.",
                "In: Proc.",
                "ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali and P. Torroni.",
                "A new framework for knowledge revision of abductive agents through their interaction.",
                "In: Proc.",
                "CLIMA-IV, Computational Logic in Multi-Agent Systems, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang, and N. Foo.",
                "Repeated negotiation of logic programs.",
                "In: Proc. 7th Workshop on Nonmonotonic Reasoning, Action and Change, 2006. [4] W. W. Chu, Q. Chen, and R.-C. Lee.",
                "Cooperative query answering via type abstraction hierarchy.",
                "In: Cooperating Knowledge Based Systems, S. M. Deen ed., pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang, and D. Zhang.",
                "Negotiating logic programs.",
                "In: Proc. 6th Workshop on Nonmonotonic Reasoning, Action and Change, 2005. [6] T. Gaasterland, P. Godfrey, and J. Minker.",
                "Relaxation as a platform for cooperative answering.",
                "Journal of Intelligence Information Systems 1(3/4):293-321, 1992. [7] M. Gelfond and V. Lifschitz.",
                "Classical negation in logic programs and disjunctive databases.",
                "New Generation Computing 9:365-385, 1991. [8] K. Inoue and C. Sakama.",
                "Abductive framework for nonmonotonic theory change.",
                "In: Proc.",
                "IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, and F. Toni, The role of abduction in logic programming.",
                "In: Handbook of Logic in AI and Logic Programming, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas and P. Moraitis.",
                "Adaptive agent negotiation via argumentation.",
                "In: Proc.",
                "AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, and D. Zhang.",
                "Logical foundation of negotiation: outcome, concession and adaptation.",
                "In: Proc.",
                "AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski.",
                "A theory and methodology of inductive learning.",
                "In: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra and N. Jennings.",
                "Agents that reason and negotiate by arguing.",
                "Journal of Logic and Computation, 8(3):261-292, 1988. [14] F. Sadri, F. Toni, and P. Torroni, An abductive logic programming architecture for negotiating agents.",
                "In: Proc. 8th European Conf. on Logics in AI, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama and K. Inoue.",
                "An abductive framework for computing knowledge base updates.",
                "Theory and Practice of Logic Programming 3(6):671-715, 2003.",
                "The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 1029"
            ],
            "original_annotated_samples": [
                "We suppose an agent who has a knowledge base represented by a <br>logic program</br>.",
                "We suppose an agent who has a knowledge base represented by a <br>logic program</br>.",
                "Each agent has an abductive <br>logic program</br> in which a sequence of dialogues are specified by a program, a dialogue protocol is specified as constraints, and dialogue moves are specified as abducibles.",
                "Thus, they use relaxation for weakening the constraints in an abductive <br>logic program</br>."
            ],
            "translated_annotated_samples": [
                "Suponemos un agente que tiene una base de conocimiento representada por un <br>programa lógico</br>.",
                "Suponemos un agente que tiene una base de conocimiento representada por un <br>programa lógico</br>.",
                "Cada agente tiene un <br>programa lógico</br> abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles.",
                "Por lo tanto, utilizan la relajación para debilitar las restricciones en un <br>programa lógico</br> abductivo."
            ],
            "translated_text": "Negociación por Abducción y Relajación Chiaki Sakama Dept. Este artículo estudia un marco lógico para la negociación automatizada entre dos agentes. Suponemos un agente que tiene una base de conocimiento representada por un <br>programa lógico</br>. Luego, introducimos métodos para construir contraofertas en respuesta a propuestas hechas por un agente. Con este fin, combinamos las técnicas de abducción extendida en inteligencia artificial y relajación en la respuesta cooperativa a consultas para bases de datos. Estas técnicas se utilizan respectivamente para producir propuestas condicionales y propuestas de vecindario en el proceso de negociación. Proporcionamos un protocolo de negociación basado en el intercambio de estas propuestas y desarrollamos procedimientos para calcular nuevas propuestas. Categorías y Descriptores de Asignaturas F.4.1 [Lógica Matemática]: Lógica y programación de restricciones;; I.2.11 [Inteligencia Artificial Distribuida]: Sistemas multiagente Términos Generales Teoría 1. INTRODUCCIÓN La negociación automatizada ha recibido una atención creciente en los sistemas multiagente, y se han propuesto varios marcos en diferentes contextos ([1, 2, 3, 5, 10, 11, 13, 14], por ejemplo). La negociación suele avanzar en una serie de rondas y cada agente hace una propuesta en cada ronda. Un agente que recibió una propuesta responde de dos maneras. Una crítica es un comentario sobre si (partes de) la propuesta es aceptada o no. La otra es una contraoferta que es una propuesta alternativa hecha en respuesta a una propuesta previa [13]. Para ver estas propuestas en una negociación uno a uno, supongamos el siguiente diálogo de negociación entre un agente comprador B y un agente vendedor S. (Bi (o Si) representa una declaración de B (o S) en la i-ésima ronda). Quiero comprar una computadora personal de la marca b1, con las especificaciones de CPU: 1GHz, Memoria: 512MB, HDD: 80GB y una unidad de DVD-RW. Quiero conseguirlo a un precio por debajo de 1200 USD. Podemos proporcionar una PC con la especificación solicitada si la pagas en efectivo. En este caso, sin embargo, no se suman puntos de servicio para este descuento especial. B2: No puedo pagarlo en efectivo. En un precio normal, la PC solicitada cuesta 1300 USD. B3: No puedo aceptar el precio. Mi presupuesto es inferior a 1200 USD. S3: Podemos proporcionar otra computadora con la especificación solicitada, excepto que está hecha por la marca b2. El precio es exactamente de 1200 USD. B4: No quiero una PC de la marca b2. En cambio, puedo cambiar un controlador de DVD-RW a CD-RW en mi propuesta inicial. S4: Ok, acepto tu oferta. En este diálogo, en respuesta a la propuesta inicial B1, se devuelve la contraoferta S1. En el resto del diálogo, B2, B3, S4 son críticas, mientras que S2, S3, B4 son contrapropuestas. Las críticas se producen al evaluar una propuesta en una base de conocimiento de un agente. Por el contrario, hacer contraofertas implica generar una propuesta alternativa que sea más favorable para el agente que responde que la original. Se sabe que hay dos formas de producir contraofertas: ampliando la propuesta inicial o modificando parte de la propuesta inicial. Según [13], el primer tipo aparece en el diálogo: A: Te propongo que me proporciones el servicio X. B: Propongo que te proporcione el servicio X si tú me proporcionas el servicio Z. El segundo tipo está en el diálogo: A: Propongo que te proporcione el servicio Y si tú me proporcionas el servicio X. Te propongo que te ofrezca el servicio X si tú me proporcionas el servicio Z. Una negociación avanza mediante la iteración de diálogos de dar y recibir hasta llegar a un acuerdo o desacuerdo. En esos diálogos, los agentes generan (contra)propuestas razonando sobre sus propios objetivos. El objetivo del agente A en los diálogos anteriores es obtener el servicio X. El agente B propone condiciones para proporcionar el servicio. En el proceso de negociación, sin embargo, puede suceder que los agentes se vean obligados a debilitar o cambiar sus objetivos iniciales para llegar a un compromiso negociado. En el diálogo de 1022 978-81-904262-7-5 (RPS) c 2007 IFAAMAS presentado arriba, un agente comprador cambia su objetivo inicial al reducir un controlador de DVD-RW a CD-RW. Dicho comportamiento suele representarse como metaconocimiento específico de un agente o especificarse como protocolos de negociación en problemas particulares. Actualmente, no existe una lógica computacional para la negociación automatizada que tenga reglas de inferencia generales para producir propuestas (contra)propuestas. El propósito de este documento es mecanizar un proceso de construcción de (contra)propuestas en diálogos de negociación uno a uno. Suponemos un agente que tiene una base de conocimiento representada por un <br>programa lógico</br>. Luego introducimos métodos para generar tres tipos diferentes de propuestas. Primero, utilizamos la técnica de abducción extendida en inteligencia artificial [8, 15] para construir una propuesta condicional como una extensión de la original. Segundo, utilizamos la técnica de relajación en la respuesta cooperativa de consultas para bases de datos [4, 6] para construir una propuesta de vecindario como enmienda de la original. Tercero, combinando la abducción extendida y la relajación, se construyen propuestas de vecindario condicionales como extensiones modificadas de la propuesta original. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de estas contraofertas y críticas. También ofrecemos procedimientos para calcular propuestas en programación lógica. Este documento está organizado de la siguiente manera. La sección 2 introduce un marco lógico utilizado en este artículo. La sección 3 presenta métodos para construir propuestas y proporciona un protocolo de negociación. La sección 4 proporciona métodos para calcular propuestas en programación lógica. La sección 5 discute trabajos relacionados, y la sección 6 concluye el artículo. PRELIMINARES Los programas lógicos considerados en este documento son programas disyuntivos extendidos (EDP) [7]. Un EDP (o simplemente un programa) es un conjunto de reglas de la forma: L1 ; · · · ; Ll ← Ll+1 , . . . , Lm, not Lm+1 , . . . , not Ln (n ≥ m ≥ l ≥ 0) donde cada Li es un literal positivo/negativo, es decir, A o ¬A para un átomo A, y not es la negación como fallo (NAF). not L se llama un literal NAF. El símbolo ; representa la disyunción. El lado izquierdo de la regla es la cabeza, y el lado derecho es el cuerpo. Para cada regla r de la forma anterior, head(r), body+ (r) y body− (r) denotan los conjuntos de literales {L1, . . . , Ll}, {Ll+1, . . . , Lm}, y {Lm+1, . . . , Ln}, respectivamente. Además, not body− (r) denota el conjunto de literales NAF {not Lm+1, . . . , not Ln}. Una disyunción de literales y una conjunción de literales (NAF-) en una regla se identifican con sus respectivos conjuntos de literales. Una regla r se escribe a menudo como head(r) ← body+ (r), no body− (r) o head(r) ← body(r) donde body(r) = body+ (r)∪not body− (r). Una regla r es disyuntiva si head(r) contiene más de un literal. Una regla r es una restricción de integridad si head(r) = ∅; y r es un hecho si body(r) = ∅. Un programa es libre de NAF si ninguna regla contiene literales NAF. Se identifican dos reglas/literales con respecto al cambio de nombre de variables. Una sustitución es un mapeo de variables a términos θ = {x1/t1, . . . , xn/tn}, donde x1, . . . , xn son variables distintas y cada ti es un término distinto de xi. Dada una conjunción G de literales (NAF-), Gθ denota la conjunción obtenida al aplicar θ a G. Un programa, regla o literal es ground si no contiene variables. Un programa P con variables es una abreviatura de su instancia concreta Ground(P), el conjunto de reglas concretas obtenidas de P al sustituir las variables en P por elementos de su universo de Herbrand de todas las formas posibles. La semántica de un EDP está definida por la semántica de conjuntos de respuestas [7]. Sea Lit el conjunto de todas las literales fundamentales en el lenguaje de un programa. Supongamos un programa P y un conjunto de literales S(⊆ Lit). Entonces, el reducto P S es el programa que contiene la regla de cabeza ground head(r) ← body+ (r) si y solo si hay una regla r en Ground(P) tal que body− (r)∩S = ∅. Dado un EDP P libre de NAF, Cn(P) denota el conjunto más pequeño de literales en tierra que (i) es cerrado bajo P, es decir, para cada regla en tierra r en Ground(P), body(r) ⊆ Cn(P) implica que head(r) ∩ Cn(P) = ∅; y (ii) es lógicamente cerrado, es decir, es consistente o igual a Lit. Dado un EDP P y un conjunto S de literales, S es un conjunto respuesta de P si S = Cn(P ∪ S). Un programa generalmente tiene cero, uno o varios conjuntos de respuestas. Un conjunto de respuestas es consistente si no es Lit. Un programa P es consistente si tiene un conjunto de respuestas consistente; de lo contrario, P es inconsistente. La programación lógica abductiva [9] introduce un mecanismo de razonamiento hipotético a la programación lógica. Un marco abductivo utilizado en este artículo es la abducción extendida introducida por Inoue y Sakama [8, 15]. Un programa abductivo es un par P, H donde P es un EDP y H es un conjunto de literales llamados abducibles. Cuando una literal L ∈ H contiene variables, cualquier instancia de L también es un abducible. Un programa abductivo P, H es consistente si P es consistente. A lo largo del documento, se asume que los programas abductivos son consistentes a menos que se indique lo contrario. Sea G = L1, . . . , Lm, no Lm+1, . . . , no Ln una conjunción, donde todas las variables en G están cuantificadas existencialmente al principio y restringidas en su rango, es decir, cada variable en Lm+1, . . . , Ln aparece en L1, . . . , Lm. Un conjunto S de literales de base satisface la conjunción G si { L1θ, . . . , Lmθ } ⊆ S y { Lm+1θ, . . . , Lnθ }∩ S = ∅ para alguna instancia de base Gθ con una sustitución θ. Que P, H sean un programa abductivo y G una conjunción como se mencionó anteriormente. Un par (E, F) es una explicación de una observación G en P, H si 1. (P \\ F) ∪ E tiene un conjunto de respuestas que satisface G, 2. (P \\ F) ∪ E es consistente, 3. E y F son conjuntos de literales fundamentales tales que E ⊆ H\\P y F ⊆ H ∩ P. Cuando (P \\ F) ∪ E tiene un conjunto de respuestas S que satisface las tres condiciones anteriores, S se llama un conjunto de creencias de un programa abductivo P, H que satisface G (con respecto a (E, F)). Ten en cuenta que si P tiene un conjunto de respuestas coherente S que satisface G, S también es un conjunto de creencias de P, H que satisface G con respecto a (E, F) = (∅, ∅). La abducción extendida introduce/elimina hipótesis en/de un programa para explicar una observación. Ten en cuenta que la abducción normal (como en [9]) solo considera la introducción de hipótesis para explicar una observación. Una explicación (E, F) de una observación G se llama mínima si para cualquier explicación (E, F) de G, E ⊆ E y F ⊆ F implican E = E y F = F. Ejemplo 2.1. Considera el programa abductivo P, H : P : vuela(x) ← pájaro(x), no ab(x) , ab(x) ← ala-rota(x) , pájaro(tweety) ← , pájaro(opus) ← , ala-rota(tweety) ← . H : ala-rota(x) . La observación G = flies(tweety) tiene la explicación mínima (E, F) = (∅, {broken-wing(tweety)}). Esto define explicaciones crédulas [15]. Las explicaciones escépticas se utilizan en [8]. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1023 3. NEGOCIACIÓN 3.1 Propuestas Condicionales por Abducción Suponemos un agente que tiene una base de conocimiento representada por un programa abductivo P, H. Un programa P consta de dos tipos de conocimiento, creencia B y deseo D, donde B representa el conocimiento objetivo de un agente, mientras que D representa el conocimiento subjetivo en general. Definimos P = B ∪ D, pero no distinguimos entre B y D si dicha distinción no es importante en el contexto. Por el contrario, los abducibles H se utilizan para representar condiciones permisibles para llegar a un compromiso en el proceso de negociación. Definición 3.1. Una propuesta G es una conjunción de literales y literales NAF: L1, . . . , Lm, not Lm+1, . . . , not Ln donde cada variable en G está cuantificada existencialmente al principio y restringida al rango. En particular, G se llama una crítica si G = aceptar o G = rechazar donde aceptar y rechazar son las proposiciones reservadas. Una contraoferta es una propuesta hecha en respuesta a una propuesta. Definición 3.2. Una propuesta G es aceptada en un programa abductivo P, H si P tiene un conjunto de respuestas que satisfacen G. Cuando una propuesta no es aceptada, la abducción se utiliza para buscar condiciones que la hagan aceptable. Definición 3.3. Sean P, H un programa abductivo y G una propuesta. Si (E, F) es una explicación mínima de Gθ para alguna sustitución θ en P, H, la conjunción G: Gθ, E, no F se llama una propuesta condicional (para G), donde E, no F representa la conjunción: A1, . . . , Ak, no Ak+1, . . . , no Al para E = {A1, . . . , Ak} y F = {Ak+1, . . . , Al}. Proposición 3.1. Sean P, H un programa abductivo y G una propuesta. Si G es una propuesta condicional, existe un conjunto de creencias S de P, H que satisface G. Prueba. Cuando G = Gθ, E, no F, (P \\ F) ∪ E tiene un conjunto de respuestas coherente S que satisface Gθ y E ∩ F = ∅. En este caso, S satisface Gθ, E, no F. Una propuesta condicional G proporciona un requisito mínimo para aceptar la propuesta G. Si Gθ tiene múltiples explicaciones mínimas, existen varias propuestas condicionales en consecuencia. Cuando (E, F) = (∅, ∅), se utiliza una propuesta condicional como una nueva propuesta hecha en respuesta a la propuesta G. Ejemplo 3.1. Un agente busca un puesto de asistente de investigación en el departamento de informática de una universidad con la condición de que el salario sea de al menos 50,000 USD al año. El agente hace su solicitud como propuesta: 2 G = asistir (depto de contabilidad), salario(x), x ≥ 50,000. La universidad tiene el programa abductivo P, H: P: salario(40,000) ← asistente(dpto de informática), no tiene PhD, salario(60,000) ← asistente(dpto de informática), tiene PhD, salario(50,000) ← asistente(dpto de matemáticas), salario(55,000) ← administrador de sistemas(dpto de informática). Para mayor comodidad notacional, a menudo incluimos ecuaciones matemáticas en propuestas/programas. Están escritas por literales, por ejemplo, x ≥ y por geq(x, y) con una definición adecuada del predicado geq. empleado(x) ← asistir(x), empleado(x) ← administrador de sistema(x), asistir(depto de computación); asistir(depto de matemáticas); administrador de sistema(depto de computación) ←, H: tiene un doctorado, donde las posiciones disponibles están representadas por disyunción. Según P, el salario base de un asistente de investigación en el departamento de informática es de 40,000 USD, pero si tiene un doctorado, es de 60,000 USD. En este caso, (E, F) = ({tiene doctorado}, ∅) se convierte en la explicación mínima de Gθ = asistir(dpto de informática), salario(60,000) con θ = { x/60,000 }. Entonces, la propuesta condicional hecha por la universidad se convierte en asistente (depto de contabilidad), salario (60,000), tiene un doctorado. 3.2 Propuestas de Vecindario por Relajación Cuando una propuesta es inaceptable, un agente intenta construir una nueva contra-propuesta debilitando las restricciones en la propuesta inicial. Utilizamos técnicas de relajación para este propósito. La relajación se utiliza como técnica de respuesta cooperativa a consultas en bases de datos [4, 6]. Cuando una consulta original falla en una base de datos, la relajación amplía el alcance de la consulta al relajar las restricciones en la misma. Esto permite que la base de datos devuelva respuestas de vecindario que están relacionadas con la consulta original. Utilizamos la técnica para elaborar propuestas en el proceso de negociación. Definición 3.4. Sean P, H un programa abductivo y G una propuesta. Entonces, G se relaja a G de las siguientes tres maneras: Anti-instantiación: Construir G de tal manera que G θ = G para alguna sustitución θ. Condiciones de eliminación: Construir G de tal manera que G ⊂ G. Reemplazo de objetivo: Si G es una conjunción G1, G2, donde G1 y G2 son conjunciones, y hay una regla L ← G1 en P tal que G1θ = G1 para alguna sustitución θ, entonces construir G como Lθ, G2. Aquí, Lθ se llama un literal reemplazado. En cada caso, todas las variables en G están cuantificadas existencialmente al principio y restringidas al rango. La anti-instantiación reemplaza constantes (o términos) con variables nuevas. La eliminación de condiciones elimina algunas condiciones en una propuesta. La sustitución de objetivo reemplaza la condición G1 en G con un literal Lθ en presencia de una regla L ← G1 en P bajo la condición G1θ = G1. Todas estas operaciones generalizan propuestas de diferentes maneras. Cada G obtenido por estas operaciones se llama una relajación de G. Cabe destacar que estas operaciones también se utilizan en el contexto de generalización inductiva [12]. La propuesta relajada puede generar nuevas ofertas que estén cerca de la propuesta original. Definición 3.5. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida por anti-instantiación. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ y G θ = G, G θ se llama una propuesta de vecindario por anti-instantiación. 2. Sea G una propuesta obtenida al eliminar condiciones. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario al eliminar condiciones. 1024 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 3. Sea G una propuesta obtenida mediante la sustitución de objetivos. Para un literal reemplazado L ∈ G y una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, poner G = (G \\ {L}) ∪ Bσ. Si P tiene un conjunto de respuestas S que satisface G θ para alguna sustitución θ, G θ se llama una propuesta de vecindario por reemplazo de objetivo. Ejemplo 3.2. (continuación) Ejemplo 3.1) Dada la propuesta G = asistir(dpto. de contabilidad), salario(x), x ≥ 50,000, • G1 = asistir(w), salario(x), x ≥ 50,000 se produce al sustituir dpto. de contabilidad por una variable w. Dado que G1θ1 = asistir(dpto. de matemáticas), salario(50,000) con θ1 = { w/dpto. de matemáticas } es satisfecho por un conjunto de respuestas de P, G1θ1 se convierte en una propuesta de vecindario por anti-instantiación. • G2 = asistir(dpto. de contabilidad), salario(x) se produce al eliminar la condición salarial x ≥ 50,000. Dado que G2θ2 = assist(compt dept), salario(40,000) con θ2 = { x/40,000 } es satisfecho por un conjunto de respuestas de P, G2θ2 se convierte en una propuesta de vecindario al eliminar condiciones. • G3 = empleado(compt dept), salario(x), x ≥ 50,000 se produce reemplazando assist(compt dept) con empleado(compt dept) usando la regla empleado(x) ← assist(x) en P. Con G3 y la regla empleado(x) ← administrador de sistemas(x) en P, se produce G3 = admin. de sistemas(compt dept), salario(x), x ≥ 50,000. Como G3 θ3 = sys admin(compt dept), salario(55, 000) con θ3 = { x/55, 000 } es satisfecho por un conjunto de respuestas de P, G3 θ3 se convierte en una propuesta de vecindario mediante la sustitución de objetivos. Finalmente, la abducción extendida y la relajación se combinan para producir propuestas de vecindario condicionales. Definición 3.6. Sean P, H un programa abductivo y G una propuesta. 1. Sea G una propuesta obtenida ya sea por anti-instantiación o eliminación de condiciones. Si (E, F) es una explicación mínima de G θ(= G) para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por anti-instantiación/eliminación de condiciones. 2. Sea G una propuesta obtenida mediante la sustitución de objetivos. Supongamos que G como en la Definición 3.5(3). Si (E, F) es una explicación mínima de G θ para alguna sustitución θ, la conjunción G θ, E, no F se llama una propuesta de vecindario condicional por reemplazo de objetivo. Una propuesta de vecindario condicional se reduce a una propuesta de vecindario cuando (E, F) = (∅, ∅). 3.3 Protocolo de Negociación Un protocolo de negociación define cómo intercambiar propuestas en el proceso de negociación. Esta sección presenta un protocolo de negociación en nuestro marco de trabajo. Suponemos una negociación uno a uno entre dos agentes que comparten una ontología común y el mismo idioma para una comunicación exitosa. Definición 3.7. Una propuesta L1, ..., Lm, no Lm+1, ..., no Ln viola una restricción de integridad ← cuerpo+ (r), no cuerpo- (r) si para cualquier sustitución θ, existe una sustitución σ tal que cuerpo+ (r)σ ⊆ { L1θ, . . . , Lmθ }, cuerpo- (r)σ∩{ L1θ, . . . , Lmθ } = ∅, y cuerpo- (r)σ ⊆ { Lm+1θ, . . . , Lnθ }. Las restricciones de integridad son condiciones que un agente debe cumplir, de modo que se utilizan para explicar por qué un agente no acepta una propuesta. Una negociación avanza en una serie de rondas. Cada ronda i-ésima (i ≥ 1) consiste en una propuesta Gi 1 hecha por un agente Ag1 y otra propuesta Gi 2 hecha por el otro agente Ag2. Definición 3.8. Que P1, H1 sea un programa abductivo de un agente Ag1 y Gi 2 una propuesta hecha por Ag2 en la i-ésima ronda. Un conjunto de críticas Ag1 (en la ronda i-ésima) es un conjunto CSi 1(P1, Gj 2) = CSi−1 1 (P1, Gj−1 2 ) ∪ { r | r es una restricción de integridad en P1 y Gj 2 viola r } donde j = i − 1 o i, y CS0 1 (P1, G0 2) = CS1 1 (P1, G0 2) = ∅. Un conjunto de críticas de un agente Ag1 acumula restricciones de integridad que son violadas por propuestas hechas por otro agente Ag2. CSi 2(P2, Gj 1) se define de la misma manera. Definición 3.9. Sean Pk, Hk un programa abductivo de un agente Agk y Gj una propuesta, que no es una crítica, hecha por cualquier agente en la j(≤ i)-ésima ronda. Un conjunto de negociación de Agk (en la ronda i-ésima) es un triple NSi k = (Si c, Si n, Si cn), donde Si c es el conjunto de propuestas condicionales, Si n es el conjunto de propuestas de vecindario, y Si cn es el conjunto de propuestas de vecindario condicionales, producidas por Gj y Pk, Hk. Un conjunto de negociación representa el espacio de posibles propuestas realizadas por un agente. Si x (x ∈ {c, n, cn}) acumula propuestas producidas por Gj (1 ≤ j ≤ i) de acuerdo con las Definiciones 3.3, 3.5 y 3.6. Ten en cuenta que un agente puede elaborar contraofertas modificando sus propias propuestas anteriores o las propuestas de otros agentes. Un agente Agk acumula propuestas que son hechas por Agk pero son rechazadas por otro agente, en el conjunto de propuestas fallidas FP i k (en la i-ésima ronda), donde FP 0 k = ∅. Supongamos que dos agentes Ag1 y Ag2 que tienen programas abductivos P1, H1 y P2, H2, respectivamente. Dado un propuesta G1 que es satisfecha por un conjunto de respuestas de P1, comienza una negociación. En respuesta a la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda, Ag2 se comporta de la siguiente manera. 1. Si Gi 1 = aceptar, se llega a un acuerdo y la negociación termina con éxito. 2. De lo contrario, si Gi 1 = rechazar, poner FP i 2 = FPi−1 2 ∪{Gi−1 2 } donde {G0 2} = ∅. Continúa con el paso 4(b). 3. Si P2 tiene un conjunto de respuestas que satisface Gi 1, Ag2 devuelve Gi 2 = aceptar a Ag1. La negociación termina con éxito. 4. De lo contrario, Ag2 se comporta de la siguiente manera. Coloca FP i 2 = FPi−1 2 . (a) Si Gi 1 viola una restricción de integridad en P2, devuelve la crítica Gi 2 = rechazar a Ag1, junto con el conjunto de críticas CSi 2(P2, Gi 1). (b) De lo contrario, construye NSi 2 de la siguiente manera. (i) Produce Si c. Sea μ(Si c) = { p | p ∈ Si c \\ FPi 2 y p cumple con las restricciones en CSi 1(P1, Gi−1 2 )}. Si μ(Si c) = ∅, selecciona uno de μ(Si c) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (ii). (ii) Produce Si n. Si μ(Si n) = ∅, selecciona uno de μ(Si n) y propónlo como Gi 2 a Ag1; de lo contrario, ve a (iii). (iii) Produce Si cn. Si μ(Si cn) = ∅, selecciona uno de μ(Si cn) y propónlo como Gi 2 a Ag1; de lo contrario, la negociación termina en fracaso. Esto significa que Ag2 no puede hacer ninguna contraoferta o que todas las contraofertas hechas por Ag2 son rechazadas por Ag1. En el paso 4(a), Ag2 rechaza la propuesta Gi 1 y devuelve la razón del rechazo como un conjunto de críticas. Esto ayuda para Ag1 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1025 en la preparación de una próxima contraoferta. En el paso 4(b), Ag2 construye una nueva propuesta. En su construcción, Ag2 debe encargarse del conjunto de críticas CSi 1(P1, Gi−1 2), que representa las restricciones de integridad, si las hubiera, acumuladas en rondas anteriores, que Ag1 debe cumplir. Además, FP i 2 se utiliza para eliminar propuestas que han sido rechazadas. La construcción de Si x (x ∈ {c, n, cn}) en NSi 2 se realiza de forma incremental añadiendo nuevas contra-propuestas producidas por Gi 1 o Gi−1 2 a Si−1 x. Por ejemplo, Si n en NSi 2 se calcula como Si n = Si−1 n ∪{ p | p es una propuesta de vecindario hecha por Gi 1 } ∪ { p | p es una propuesta de vecindario hecha por Gi−1 2 }, donde S0 n = ∅. Es decir, Si n se construye a partir de Si−1 n añadiendo nuevas propuestas que se obtienen modificando la propuesta Gi 1 hecha por Ag1 en la i-ésima ronda o modificando la propuesta Gi−1 2 hecha por Ag2 en la (i − 1)-ésima ronda. Si se obtienen c y Si cn también. En el protocolo anterior, un agente produce Si c en primer lugar, luego Si n, y finalmente Si cn. Esta estrategia busca condiciones que satisfagan la propuesta dada, antes que las propuestas vecinas que cambian la original. Otra estrategia, que prefiere propuestas de vecindario a las condicionales, también es considerada. Las propuestas de vecindario condicional deben considerarse en último lugar, ya que difieren del original en la mayor medida posible. El protocolo anterior produce las propuestas de candidatos en Si x para cada x ∈ {c, n, cn} a la vez. Podemos considerar una variante del protocolo en el que cada propuesta en Si x se construye una por una (ver Ejemplo 3.3). El protocolo anterior se aplica repetidamente a cada uno de los dos agentes negociadores hasta que una negociación termine en éxito o fracaso. Formalmente, el protocolo de negociación anterior tiene las siguientes propiedades. Teorema 3.2. Que Ag1 y Ag2 sean dos agentes con programas abductivos P1, H1 y P2, H2, respectivamente. 1. Si P1, H1 y P2, H2 son libres de funciones (es decir, tanto Pi como Hi no contienen ningún símbolo de función), cualquier negociación terminará. 2. Si una negociación termina con un acuerdo sobre una propuesta G, tanto P1, H1 como P2, H2 tienen conjuntos de creencias que satisfacen G. Prueba. 1. Cuando un programa abductivo es libre de funciones, los abducibles y los conjuntos de negociación son finitos. Además, si una propuesta es rechazada una vez, no es propuesta nuevamente por la función μ. Por lo tanto, la negociación terminará en pasos finitos. 2. Cuando se hace una propuesta G por Ag1, P1, H1 tiene un conjunto de creencias que satisface G. Si el agente Ag2 acepta la propuesta G, esta es satisfecha por un conjunto de respuestas de P2 que también es un conjunto de creencias de P2, H2. Ejemplo 3.3. Suponga una situación de compra-venta en la introducción. Un agente vendedor tiene el programa abductivo Ps, Hs en el que Ps consiste en la creencia Bs y el deseo Ds: Bs: pc(b1, 1G, 512M, 80G); pc(b2, 1G, 512M, 80G) ←, (1) dvd-rw; cd-rw ←, (2) Ds: precio normal(1300) ← pc(b1, 1G, 512M, 80G), dvd-rw, (3) precio normal(1200) ← pc(b1, 1G, 512M, 80G), cd-rw, (4) precio normal(1200) ← pc(b2, 1G, 512M, 80G), dvd-rw, (5) precio(x) ← precio normal(x), agregar punto, (6) precio(x ∗ 0.9) ← precio normal(x), pagar en efectivo, no agregar punto, (7) agregar punto ←, (8) Hs: agregar punto, pagar en efectivo. Aquí, (1) y (2) representan la selección de productos. El átomo pc(b1, 1G, 512M, 80G) representa que el agente vendedor tiene una PC de la marca b1 con un CPU de 1GHz, memoria de 512MB y un disco duro de 80GB. Los precios de los productos se representan como el deseo del vendedor. Las reglas (3) - (5) son los precios normales de los productos. Un precio normal es un precio de venta bajo la condición de que se añadan puntos de servicio (6). Por otro lado, se aplica un precio con descuento si el método de pago es en efectivo y no se agrega ningún punto de servicio (7). El hecho (8) representa la suma de puntos de servicio. Este servicio sería retirado en caso de precios con descuento, por lo que se añade el punto especificado como abducible. Un agente comprador tiene el programa abductivo Pb, Hb en el que Pb consiste en la creencia Bb y el deseo Db: Bb: drive ← dvd-rw, (9) drive ← cd-rw, (10) price(x) ←, (11) Db: pc(b1, 1G, 512M, 80G) ←, (12) dvd-rw ←, (13) cd-rw ← no dvd-rw, (14) ← pagar en efectivo, (15) ← price(x), x > 1200, (16) Hb: dvd-rw. Las reglas (12) - (16) son el deseo de los compradores. Entre ellos, (15) y (16) imponen restricciones para comprar una PC. Un DVD-RW está especificado como un abducible que está sujeto a concesión. (1ª ronda) Primero, el agente comprador presenta la siguiente propuesta: G1 b: pc(b1, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps no tiene un conjunto de respuestas que satisfaga G1 b, el agente vendedor no puede aceptar la propuesta. El vendedor toma una acción de hacer una contraoferta y realiza un secuestro. Como resultado, el vendedor encuentra la explicación mínima (E, F) = ({pagar en efectivo}, {agregar puntos}) que explica G1 b θ1 con θ1 = {x/1170}. El vendedor construye la propuesta condicional: G1 s: pc(b1, 1G, 512M, 80G), dvd-rw, precio(1170), pagar en efectivo, no sumar puntos y la ofrece al comprador. (2da ronda) El comprador no acepta G1 s porque no puede pagarlo en efectivo (15). El comprador luego devuelve la crítica G2 b = rechazar al vendedor, junto con el conjunto de críticas CS2 b (Pb, G1 s) = {(15)}. En respuesta a esto, el vendedor intenta hacer otra propuesta que satisfaga la restricción en este conjunto de críticas. Como G1 s está almacenado en FP 2 s y no existe ninguna otra propuesta condicional que satisfaga los requisitos del comprador, el vendedor produce propuestas de vecindario. Él/ella relaja G1 b al dejar x ≤ 1200 en la condición, y produce pc(b1, 1G, 512M, 80G), dvd-rw, precio(x). Como Ps tiene un conjunto de respuestas que satisface G2 s: pc(b1, 1G, 512M, 80G), dvd-rw, price(1300), 1026 The Sixth Intl. En la Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07), el vendedor ofrece G2 s como una nueva contraoferta. (3ra ronda) El comprador no acepta G2 s porque no puede pagar más de 1200 USD (16). El comprador vuelve a devolver la crítica G3 b = rechazar al vendedor, junto con el conjunto de críticas CS3 b (Pb, G2 s) = CS2 b (Pb, G1 s) ∪ {(16)}. El vendedor luego considera otra propuesta al reemplazar b1 con una variable w, 1G b ahora se convierte en pc(w, 1G, 512M, 80G), dvd-rw, precio(x), x ≤ 1200. Como Ps tiene un conjunto de respuestas que satisface G3 s: pc(b2, 1G, 512M, 80G), dvd-rw, price(1200), el vendedor ofrece G3 s como una nueva contraoferta. (4ta ronda) El comprador no acepta G3 s porque una PC de la marca b2 no está en su interés y Pb no tiene un conjunto de respuestas que satisfaga G3 s. Entonces, el comprador hace una concesión cambiando su objetivo original. El comprador relaja G1 b mediante la sustitución de objetivos utilizando la regla (9) en Pb, y produce pc(b1, 1G, 512M, 80G), drive, price(x), x ≤ 1200. Usando (10), se produce la siguiente propuesta: pc(b1, 1G, 512M, 80G), cd-rw, precio(x), x ≤ 1200. Dado que Pb \\ {dvd-rw} tiene un conjunto de respuestas coherente que satisface la propuesta anterior, el comprador propone la propuesta de vecindario condicional G4 b: pc(b1, 1G, 512M, 80G), cd-rw, no dvd-rw, precio(x), x ≤ 1200 al agente vendedor. Dado que Ps también tiene un conjunto de respuestas que satisface G4 b, el vendedor lo acepta y envía el mensaje G4 s = aceptar al comprador. Por lo tanto, la negociación termina con éxito. 4. CÁLCULO En esta sección, proporcionamos métodos para calcular propuestas en términos de conjuntos de respuestas de programas. Primero introducimos algunas definiciones de [15]. Definición 4.1. Dado un programa abductivo P, H, el conjunto UR de reglas de actualización se define como: UR = { L ← not L, L ← not L | L ∈ H } ∪ { +L ← L | L ∈ H \\ P } ∪ { −L ← not L | L ∈ H ∩ P }, donde L, +L y −L son nuevos átomos asociados de manera única con cada L ∈ H. Los átomos +L y −L se llaman átomos de actualización. Por definición, el átomo L se vuelve verdadero si y solo si L no es verdadero. El par de reglas L ← no L y L ← no L especifican la situación en la que un abducible L es verdadero o no. Cuando p(x) ∈ H y p(a) ∈ P pero p(t) ∈ P para t = a, la regla +L ← L se convierte precisamente en +p(t) ← p(t) para cualquier t = a. En este caso, la regla se escribe brevemente como +p(x) ← p(x), x = a. Generalmente, la regla se convierte en +p(x) ← p(x), x = t1, . . . , x = tn para n tales instancias. La regla +L ← L deriva el átomo +L si un abducible L que no está en P debe ser verdadero. Por el contrario, la regla −L ← not L deriva el átomo −L si un abducible L que está en P no debe ser verdadero. Por lo tanto, los átomos de actualización representan el cambio de los valores de verdad de los abducibles en un programa. Es decir, +L significa la introducción de L, mientras que −L significa la eliminación de L. Cuando un abducible L contiene variables, se supone que el átomo de actualización asociado +L o −L debe tener exactamente las mismas variables. En este caso, un átomo de actualización se identifica semánticamente con sus instancias fundamentales. El conjunto de todos los átomos de actualización asociados con los abducibles en H se denota por UH, y UH = UH+ ∪ UH− donde UH+ (resp. UH− ) es el conjunto de átomos de actualización de la forma +L (resp. −L). Definición 4.2. Dado un programa abductivo P, H, su programa de actualización UP se define como el programa UP = (P \\ H) ∪ UR. Un conjunto de respuestas S de UP se llama U-minimal si no hay ningún conjunto de respuestas T de UP tal que T ∩ UH ⊂ S ∩ UH. Según la definición, los conjuntos de respuestas U-minimales existen siempre que UP tenga conjuntos de respuestas. Los programas de actualización se utilizan para calcular explicaciones (mínimas) de una observación. Dada una observación G como una conjunción de literales y NAF-literals posiblemente conteniendo variables, introducimos un nuevo literal en tierra O junto con la regla O ← G. En este caso, O tiene una explicación (E, F) si y solo si G tiene la misma explicación. Con esta sustitución, se asume que una observación es un literal de base sin pérdida de generalidad. En lo que sigue, E+ = { +L | L ∈ E } y F- = { -L | L ∈ F } para E ⊆ H y F ⊆ H. Proposición 4.1. ([15]) Sean P, H un programa abductivo, UP su programa de actualización, y G un literal concreto que representa una observación. Entonces, un par (E, F) es una explicación de G si y solo si UP ∪ { ← no G } tiene un conjunto de respuestas coherente S tal que E+ = S ∩ UH+ y F− = S ∩ UH−. En particular, (E, F) es una explicación mínima si y solo si S es un conjunto de respuestas U-mínimo. Ejemplo 4.1. Para explicar la observación G = flies(t) en el programa P del Ejemplo 2.1, primero construya el programa de actualización UP de P:3 UP : flies(x) ← bird(x), not ab(x), ab(x) ← broken-wing(x) , bird(t) ← , bird(o) ← , broken-wing(x) ← not broken-wing(x), broken-wing(x) ← not broken-wing(x), +broken-wing(x) ← broken-wing(x), x = t , −broken-wing(t) ← not broken-wing(t) . A continuación, considera el programa UP ∪ { ← no vuela(t) }. Tiene el único conjunto de respuestas U-minimal: S = { pájaro(t), pájaro(o), vuela(t), vuela(o), ala-rota(t), ala-rota(o), -ala-rota(t) }. La explicación mínima única (E, F) = (∅, {broken-wing(t)}) de G se expresa mediante el átomo de actualización −broken-wing(t) en S ∩ UH−. Proposición 4.2. Sean P, H un programa abductivo y G un literal concreto representando una observación. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente S, G tiene la explicación mínima (E, F) = (∅, ∅) y S satisface G. Ahora proporcionamos métodos para calcular (contra-)propuestas. Primero, las propuestas condicionales se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sc de propuestas. Si G es un literal de base, calcula su explicación mínima (E, F) en P, H utilizando el programa de actualización. Coloca G, E, no F en Sc. Si G es una conjunción posiblemente conteniendo variables, considera el programa abductivo 3 t representa a Tweety y o representa a Opus. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1027 P ∪{ O ← G }, H con un literal concreto O. Calcular una explicación mínima de O en P ∪ { O ← G }, H utilizando su programa de actualización. Si O tiene una explicación mínima (E, F) con una sustitución θ para variables en G, coloque Gθ, E, no F en Sc. A continuación, las propuestas de vecindario se calculan de la siguiente manera. entrada: un programa abductivo P, H, una propuesta G; salida: un conjunto Sn de propuestas. % propuestas de vecindario por anti-instantiación; Construir G por anti-instantiación. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ y G θ = G, coloque G θ en Sn. % propuestas de vecindario eliminando condiciones; Construya G eliminando condiciones. Si G es un literal de base y el programa P ∪ { ← not G } tiene un conjunto de respuestas consistente, coloque G en Sn. Si G es una conjunción que posiblemente contiene variables, haz lo siguiente. Para un literal de base O, si P ∪{ O ← G }∪{ ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. % propuestas de vecindario por reemplazo de objetivo; Construya G por reemplazo de objetivo. Si G es un literal de base y hay una regla H ← B en P tal que G = Hσ y Bσ = G para alguna sustitución σ, entonces se tiene que G = Bσ. Si P ∪ { ← not G } tiene un conjunto de respuestas coherente que satisface G θ con una sustitución θ, coloca G θ en Sn. Si G es una conjunción posiblemente conteniendo variables, haz lo siguiente. Para un literal reemplazado L ∈ G, si hay una regla H ← B en P tal que L = Hσ y (G \\ {L}) ∪ Bσ = G para alguna sustitución σ, entonces se coloca G = (G \\ {L}) ∪ Bσ. Para un literal de base O, si P ∪ { O ← G } ∪ { ← not O } tiene un conjunto de respuestas consistente que satisface G θ con una sustitución θ, coloque G θ en Sn. Teorema 4.3. El conjunto Sc (resp. La Sn) calculada arriba coincide con el conjunto de propuestas condicionales (respectivamente, propuestas de vecindario). Prueba. El resultado para Sc se sigue de la Definición 3.3 y la Proposición 4.1. El resultado para Sn se sigue de la Definición 3.5 y la Proposición 4.2. Las propuestas de vecindario condicionales se calculan combinando los dos procedimientos anteriores. Esas propuestas se calculan en cada ronda. Ten en cuenta que el procedimiento para calcular Sn contiene algunas elecciones no determinísticas. Por ejemplo, generalmente hay varios candidatos de literales para relajar en una propuesta. Además, puede haber varias reglas en un programa para el uso de la sustitución de objetivos. En la práctica, un agente puede preespecificar literales en una propuesta para posibles relajaciones o reglas en un programa para el uso de la sustitución de metas. 5. TRABAJOS RELACIONADOS Dado que existe una cantidad considerable de literatura sobre negociación automatizada, esta sección se centra en la comparación con marcos de negociación basados en lógica y argumentación. Sadri et al. [14] utilizan la programación lógica abductiva como lenguaje de representación de agentes negociadores. Los agentes negocian utilizando primitivas de diálogo comunes, llamadas movimientos de diálogo. Cada agente tiene un <br>programa lógico</br> abductivo en el que una secuencia de diálogos está especificada por un programa, un protocolo de diálogo está especificado como restricciones, y los movimientos de diálogo están especificados como abducibles. El comportamiento de los agentes está regulado por un ciclo de observar-pensar-actuar. Una vez que un agente emite un movimiento de diálogo, otro agente que observó la emisión piensa y actúa utilizando un procedimiento de prueba. Su enfoque y el nuestro emplean ambos la programación lógica abductiva como plataforma de razonamiento de agentes, pero su uso es bastante diferente. Primero, ellos utilizan abducibles para especificar primitivas de diálogo de la forma decir(emisor, receptor, sujeto, identificador, tiempo), mientras que nosotros utilizamos abducibles para especificar hipótesis arbitrarias permitidas para construir propuestas condicionales. Segundo, un programa preespecifica un plan a llevar a cabo para lograr un objetivo, junto con los recursos disponibles/faltantes en el contexto de problemas de intercambio de recursos. Esto contrasta con nuestro método en el cual posibles contra-propuestas son construidas nuevamente en respuesta a una propuesta hecha por un agente. Tercero, ellos especifican una política de negociación dentro de un programa (como restricciones de integridad), mientras que nosotros proporcionamos un protocolo independiente de agentes individuales. Proporcionan un modelo operativo que especifica completamente el comportamiento de los agentes en términos del ciclo del agente. No proporcionamos una especificación tan completa del comportamiento de los agentes. Nuestro interés principal es mecanizar la construcción de propuestas. Bracciali y Torroni [2] formulan agentes abductivos que poseen conocimiento en programas lógicos abductivos. Para explicar una observación, dos agentes se comunican intercambiando restricciones de integridad. En el proceso de comunicación, un agente puede revisar sus propias restricciones de integridad de acuerdo con la información proporcionada por el otro agente. Un conjunto IC de restricciones de integridad relaja un conjunto IC (o IC aprieta IC) si cualquier observación que pueda ser demostrada con respecto a IC también puede ser demostrada con respecto a IC. Por ejemplo, IC : ← a, b, c relaja IC : ← a, b. Por lo tanto, utilizan la relajación para debilitar las restricciones en un <br>programa lógico</br> abductivo. Por el contrario, utilizamos la relajación para debilitar propuestas y se consideran tres métodos diferentes de relajación: la anti-instantiación, la eliminación de condiciones y la sustitución de objetivos. Su objetivo es explicar una observación revisando las restricciones de integridad de un agente a través de la comunicación, mientras que nosotros utilizamos restricciones de integridad para comunicarnos y explicar críticas, ayudando a otros agentes a hacer contra-propuestas. Meyer et al. [11] presentan un marco lógico para agentes negociadores. Introducen dos modos diferentes de negociación: concesión y adaptación. Proporcionan postulados racionales para caracterizar los resultados negociados entre dos agentes, y describen métodos para construir los resultados. Proporcionan condiciones lógicas para que se cumplan los resultados negociados, pero no describen un proceso de negociación ni protocolos de negociación. Además, representan agentes mediante teorías proposicionales clásicas, lo cual es diferente de nuestro marco de programación lógica abductiva. Foo et al. [5] modelan la negociación uno a uno como un encuentro único entre dos programas lógicos extendidos. Un agente ofrece un conjunto de respuestas de su programa, y su acuerdo mutuo se considera como un intercambio en sus conjuntos de respuestas. Partiendo del conjunto de acuerdos inicial S∩T para un conjunto de respuestas S de un agente y un conjunto de respuestas T de otro agente, cada agente extiende este conjunto para reflejar su propia demanda manteniendo consistencia con la demanda del otro agente. Su algoritmo devuelve nuevos programas con conjuntos de respuestas que son consistentes entre sí y mantienen el conjunto de acuerdos. El trabajo se extiende a encuentros repetidos en [3]. En su marco de trabajo, dos agentes intercambian conjuntos de respuestas para producir un conjunto de creencias común, lo cual es diferente de nuestro marco de trabajo de intercambiar propuestas. Hay una serie de propuestas para negociación basadas en 1028 The Sixth Intl. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) sobre argumentación. Una ventaja de la negociación basada en argumentos es que construye una propuesta con argumentos que respaldan la propuesta [1]. La existencia de argumentos es útil para convencer a otros agentes de las razones por las cuales un agente ofrece (contra)propuestas o devuelve críticas. Parsons et al. [13] desarrollan una lógica de negociación basada en argumentación entre agentes BDI. En una negociación uno a uno, un agente A genera una propuesta junto con sus argumentos y se la pasa a otro agente B. La propuesta es evaluada por B, quien intenta construir argumentos en su contra. Si entra en conflicto con el interés de B, B informa a A de su objeción enviando de vuelta su argumento de ataque. En respuesta a esto, A intenta encontrar una forma alternativa de lograr su objetivo original, o una forma de persuadir a B para que retire su objeción. Si se encuentra alguno de los dos tipos de argumento, A lo presentará a B. Si B no encuentra ninguna razón para rechazar la nueva propuesta, será aceptada y la negociación terminará con éxito. De lo contrario, el proceso se repite. En este proceso de negociación, el agente A nunca cambia su objetivo original, por lo que la negociación termina en fracaso si A no logra encontrar una forma alternativa de alcanzar el objetivo original. En nuestro marco de trabajo, cuando una propuesta es rechazada por otro agente, un agente puede debilitar o cambiar su objetivo mediante abducción y relajación. Nuestro marco no tiene un mecanismo de argumentación, pero las razones de las críticas pueden ser informadas por conjuntos de críticas de respuesta. Kakas y Moraitis proponen un protocolo de negociación que integra la abducción dentro de un marco de argumentación. Una propuesta contiene una oferta correspondiente al objeto de negociación, junto con información de respaldo que representa las condiciones bajo las cuales se realiza esta oferta. La información de apoyo se calcula por abducción y se utiliza para construir argumentos condicionales durante el proceso de negociación. En su protocolo de negociación, cuando un agente no puede satisfacer su propio objetivo, el agente considera el objetivo de los otros agentes y busca condiciones bajo las cuales el objetivo sea aceptable. Nuestro enfoque actual difiere del de ellos en los siguientes puntos. Primero, ellos utilizan la abducción para buscar condiciones que respalden argumentos, mientras que nosotros utilizamos la abducción para buscar condiciones para propuestas que aceptar. En segundo lugar, en su protocolo de negociación, las contraofertas se eligen entre candidatos basados en el conocimiento de preferencias de un agente a nivel meta, que representa la política bajo la cual un agente utiliza sus reglas de decisión a nivel de objeto de acuerdo a las situaciones. En nuestro marco de trabajo, las contra-propuestas son construidas de nuevo utilizando la abducción y la relajación. El método de construcción es independiente de protocolos de negociación particulares. Como [2, 10, 14], la abducción o programación lógica abductiva utilizada en la negociación se basa principalmente en la abducción normal. Por el contrario, nuestro enfoque se basa en la abducción extendida que no solo puede introducir hipótesis, sino también eliminarlas de un programa. Esta es otra diferencia importante. La relajación y la respuesta a consultas de vecindario están diseñadas para hacer que las bases de datos sean cooperativas con sus usuarios [4, 6]. En este sentido, esas técnicas tienen un espíritu similar a la resolución cooperativa de problemas en sistemas multiagente. Hasta donde los autores saben, sin embargo, no hay ningún estudio que aplique esas técnicas a la negociación entre agentes. 6. CONCLUSIÓN En este documento propusimos un marco lógico para agentes negociadores. Para construir propuestas en el proceso de negociación, combinamos las técnicas de abducción extendida y relajación. Se demostró que estas dos operaciones se utilizan para reglas de inferencia generales en la elaboración de propuestas. Desarrollamos un protocolo de negociación entre dos agentes basado en el intercambio de propuestas y críticas, y proporcionamos procedimientos para calcular propuestas en programación lógica abductiva. Esto nos permite realizar negociaciones automatizadas sobre los solucionadores de conjuntos de respuestas existentes. El marco actual no tiene un mecanismo para seleccionar una propuesta óptima (contraria) entre diferentes alternativas. Para comparar y evaluar propuestas, un agente debe tener conocimiento de preferencias sobre las propuestas candidatas. La elaboración adicional para maximizar la utilidad de los agentes queda pendiente para estudios futuros. REFERENCIAS [1] L. Amgoud, S. Parsons y N. Maudet. Argumentos, diálogo y negociación. En: Proc. ECAI-00, pp. 338-342, IOS Press, 2000. [2] A. Bracciali y P. Torroni. Un nuevo marco para la revisión del conocimiento de agentes abductivos a través de su interacción. En: Proc. CLIMA-IV, Lógica Computacional en Sistemas Multiagente, LNAI 3259, pp. 159-177, 2004. [3] W. Chen, M. Zhang y N. Foo. Negociación repetida de programas lógicos. En: Actas del 7º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2006. [4] W. W. Chu, Q. Chen y R.-C. Lee. Respuesta cooperativa a consultas a través de una jerarquía de abstracción de tipos. En: Sistemas basados en el conocimiento cooperativo, editado por S. M. Deen, pp. 271-290, Springer, 1990. [5] N. Foo, T. Meyer, Y. Zhang y D. Zhang. Negociando programas lógicos. En: Actas del 6º Taller sobre Razonamiento No Monótono, Acción y Cambio, 2005. [6] T. Gaasterland, P. Godfrey y J. Minker. Relajación como plataforma para responder de manera cooperativa. Revista de Sistemas de Información de Inteligencia 1(3/4):293-321, 1992. [7] M. Gelfond y V. Lifschitz. Negación clásica en programas lógicos y bases de datos disyuntivas. Computación de Nueva Generación 9:365-385, 1991. [8] K. Inoue y C. Sakama. Marco abductivo para el cambio de teoría no monótona. En: Proc. IJCAI-95, pp. 204-210, Morgan Kaufmann. [9] A. C. Kakas, R. A. Kowalski, y F. Toni, El papel de la abducción en la programación lógica. En: Manual de Lógica en Inteligencia Artificial y Programación Lógica, D. M. Gabbay, et al. (eds), vol. 5, pp. 235-324, Oxford University Press, 1998. [10] A. C. Kakas y P. Moraitis. Negociación de agentes adaptativos a través de argumentación. En: Proc. AAMAS-06, pp. 384-391, ACM Press. [11] T. Meyer, N. Foo, R. Kwok, y D. Zhang. Fundamento lógico de la negociación: resultado, concesión y adaptación. En: Proc. AAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. \n\nAAAI-04, pp. 293-298, MIT Press. [12] R. S. Michalski. Una teoría y metodología de aprendizaje inductivo. En: Machine Learning: An Artificial Intelligence Approach, R. S. Michalski, et al. (eds), pp. 83-134, Morgan Kaufmann, 1983. [13] S. Parsons, C. Sierra y N. Jennings. Agentes que razonan y negocian mediante argumentos. Revista de Lógica y Computación, 8(3):261-292, 1988. [14] F. Sadri, F. Toni y P. Torroni, Una arquitectura de programación lógica abductiva para agentes negociadores. En: Actas de la 8ª Conferencia Europea sobre Lógica en Inteligencia Artificial, LNAI 2424, pp. 419-431, Springer, 2002. [15] C. Sakama y K. Inoue. Un marco abductivo para calcular actualizaciones de la base de conocimientos. Teoría y Práctica de la Programación Lógica 3(6):671-715, 2003. El Sexto Internacional. Conferencia Conjunta sobre Agentes Autónomos y Sistemas Multiagente (AAMAS 07) 1029 ",
            "candidates": [],
            "error": [
                [
                    ""
                ]
            ]
        }
    }
}