{
    "id": "I-46",
    "original_text": "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams. Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al.; however, they are also modular and compact in the way concurrent programs are. We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1. INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years. Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3]. Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled. Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance. Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model. However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other. In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems. The structure of the paper is as follows. First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies. More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information. We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case. The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system. However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems. Thus, we usually need representations that are more compact. Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation. This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate. In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis. We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered. Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture. We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information. Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2. LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL). Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ. The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St). A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i]. A q-path is a path that starts in q. Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7]. Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ. Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent). We assume that all ∼a are equivalences. The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q . Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial). This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular). The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt. Informally, A ϕ says that agents A have a collective strategy to enforce ϕ. It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively. The semantics of ATL is defined in so called concurrent game structures (CGSs). A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions. Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St. Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk). DEFINITION 1. A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A. Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}. The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system. ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall. Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations. It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ). ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ). A collective strategy is uniform if it contains only uniform individual strategies. Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q. The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game. While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3. MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking. We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world). Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems). We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics). On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g. Boolean variables, n-ary attributes etc.). Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15]. For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity. States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems. Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component. In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way. While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models). Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious. We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system. Unfortunately, ATL models are anything but open in this sense. Theoretical complexity results for explicit models are as follows. Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5]. Alternatively, it can be done in time O(n2 l), where n is the number of states. Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16]. Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways. An alternative is to represent the state/transition space in a symbolic way [17, 18]. Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models. Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems. An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π . St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment. The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St). While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi . It is easy to see that such a representation is modular and compact as far as we are concerned with states. Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states. Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models. This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here. But the bottom line is that the temporal dimension of an interpreted system has exponential representation. And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems. Here, we use the formulation from [15]. A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation. The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names. Concurrent programs have several advantages. First of all, they are modular and compact. They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here). Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization. On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes. For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous. Side effects of actions are also not easy to model. Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions. For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect. The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities. Now, particular actions are no less important than the resulting transitions. Actions may influence other agents local states without their consent, they may have side effects on other agents states etc. Passing messages and/or calling procedures is by no means the only way of interaction between agents. Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions! Finally, we would often like to assume that agents act synchronously. In particular, all agents play simultaneously in concurrent game structures. But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination. To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions. The first postulate is easy to satisfy, as we show in the following section. The second will be addressed in Section 4. We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players. A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all. DEFINITION 2. A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi. We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs. DEFINITION 3. A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π. Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π. It is required that ctr1, . . . ctrk partitions Π. The idea is that agent i controls the variables ctri. The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round. A guarded command is enabled if the guard φ is true in the current state of the system. In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj. Several guarded commands being enabled at the same time model non-deterministic choice. Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20]. That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi . Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20]. SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls. Concurrent epistemic programs are modular and have a grounded semantics. They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program). Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc. The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation. One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security). Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message. The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out. So, availability of actions must be independent of the actions chosen by the other agents under incomplete information. On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded. We have already mentioned a very limited variant of RML (i.e., SRML). The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates. However, the sets of variables controlled by different agents can overlap, they can change over time etc. Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML. Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system. Agents can act synchronously as well as asynchronously. To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony. However, we believe that there is still a need for a simpler and slightly more abstract class of representations. First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions. Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables. This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework. Third, the separation of the local complexity, and the complexity of interaction is not straightforward. Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point. The proposed framework is presented in Section 4. 4. MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components. Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill). Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity. DEFINITION 4. A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet. Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions. The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv. Within our framework, we assume that every action is executed by an actor, that is, an agent. As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS. The environment, on the other hand, represents the (passive) context of agents actions. In practice, it serves to capture the aspects of the global state that are not observable by any of the agents. The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In). However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly. DEFINITION 5. Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i. The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj. It is required that ϕn ≡ , so that the mapping is effective. REMARK 1. Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]). Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In. In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6. The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows. Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q). We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ . Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2. Note that MISs can be used as representations of CGSs too. In that case, epistemic relations ∼i are simply omitted in the unfolding. We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q). Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems. On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8. PROPOSITION 3. For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF. Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS. We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k . We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states. First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α). Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q . Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk . Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) . Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1). We now argue that St = Q. Clearly, Q ⊆ St . Let ˆq ∈ St ; we must show that ˆq ∈ Q. The argument is on induction on the length of the least o path from Q to ˆq. The base case, ˆq ∈ Q, is immediate. For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1). Thus, St = Q. Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St . It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof. COROLLARY 4. For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa. PROPOSITION 5. For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF. Let M = Agt, St, Act, d, o, Π, π be given. Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM. Let M be the CGS obtained by removing the accessibility relations from ˆM . Clearly, M is isomorphic to M. COROLLARY 6. For every CGS M, there is an ATL-equivalent MIS S with initial states Q. That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa. PROPOSITION 7. The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure. PROOF. Take a CEGS M in which agent i has always perfect information about the current global state of the system. When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage. The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents. PROPOSITION 8. The size of In in S is, in general, exponential with respect to the number of local states and local actions. This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS). PROOF. Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere. The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i. Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}. Still, the current actions of all agents are relevant to determine the resulting local transition of agent i. We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS. In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer. To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions. Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS. Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway. More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent. Moreover, we can control and measure the complexity of each layer in a finer way than before. First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds). Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs. Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems. First, we define our (quite strong) notion of equivalence of representations. DEFINITION 7. Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures. They are CGS-equivalent if they unfold to the same CGS. PROPOSITION 9. For any SRML there is a CGS-equivalent MIS. PROOF. Consider an SRML R with k modules and n variables. We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment). Let us assume without loss of generality that ctri = {x1, ..., xr}. Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥. Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} . To define local transitions, we consider three cases. If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α. If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise. Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise. Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi. The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states. In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations). Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ). Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML. We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way. Following the reviewers remarks, we state our complexity results only as conjectures. Preliminary proofs can be found in [14]. CONJECTURE 10. Model checking ATL for modular interpreted systems is EXPTIME-complete. CONJECTURE 11. Model checking ATLir for the class of modular interpreted systems is PSPACE-complete. A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below. The table presents completeness results for various models and settings of input parameters. Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system. The new results, conjectured in this paper, are printed in italics. Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern. When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems. Why can it be so? First, a MIS unfolds into CEGS and CGS in a different way. In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information). In the latter case, the epistemic The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently. Another crucial factor is the number of available strategies (relative to the size of input parameters). The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general. Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem. However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5. CONCLUSIONS We have presented a new class of representations for open multiagent systems. Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems. We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information. The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction. We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules. We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules. We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6. ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks. Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7. REFERENCES [1] R. Alur and T. A. Henzinger. Reactive modules. Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman. Alternating-time Temporal Logic. Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman. Alternating-time Temporal Logic. Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani, and S. Tasiran. MOCHA user manual. In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A. Emerson, and A.P. Sistla. Automatic verification of finite-state concurrent systems using temporal logic specifications. ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A. Emerson and J.Y. Halpern. sometimes and not never revisited: On branching versus linear time temporal logic. In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi. Reasoning about Knowledge. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke. Model checking for combined logics. In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga. Comparing semantics of logics for multi-agent systems. Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern. Reasoning about knowledge: a survey. In D. M. Gabbay, C. J. Hogger, and J. A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34. Oxford University Press, 1995. [11] J.Y. Halpern and R. Fagin. Modelling knowledge and action in distributed systems. Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix. Do agents make model checking explode (computationally)? In M. P˘echou˘cek, P. Petta, and L.Z. Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407. Springer Verlag, 2005. [13] W. Jamroga and J. Dix. Model checking abilities of agents: A closer look. Submitted, 2006. [14] W. Jamroga and T. Ågotnes. Modular interpreted systems: A preliminary report. Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y. Vardi, and P. Wolper. An automata-theoretic approach to branching-time model checking. Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby. Expressiveness and complexity of ATL. Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L. McMillan. Symbolic Model Checking: An Approach to the State Explosion Problem. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Applying SAT methods in unbounded symbolic model checking. In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio. Verifying epistemic properties of multi-agent systems via bounded model checking. In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003. ACM Press. [20] F. Raimondi and A. Lomuscio. The complexity of symbolic model checking temporal-epistemic logics. In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens. Alternating-time logic with imperfect recall. Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge. On the complexity of practical ATL model checking. In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Sistemas interpretados modulares Wojciech Jamroga Departamento de Informática de la Universidad de Claustral, Alemania wjamroga@in.tu-Clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Bergen University College, Noruega Tag@hib.No Resumen, proponemos una nueva clase de representaciones que pueden ser que pueden serUtilizado para modelar (y verificación de modelos) propiedades temporales, estratégicas y epistémicas de los agentes y sus equipos. Nuestras representaciones toman prestadas las ideas principales de los sistemas interpretados de Halpern, Fagin et al.;Sin embargo, también son modulares y compactos de la forma en que lo son los programas concurrentes. También mencionamos resultados preliminares sobre la comprobación de modelos de lógica temporal en tiempo alterno para esta clase natural de modelos. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: sistemas artificiales de inteligencia artificiales distribuidos;I.2.4 [Inteligencia artificial]: Formalismos de representación del conocimiento y métodos lógica modal Términos generales Teoría 1. Introducción Los fundamentos lógicos de los sistemas de múltiples agentes han recibido mucha atención en los últimos años. La lógica se ha utilizado para representar y razonar, por ejemplo, conocimiento [7], tiempo [6], cooperación y capacidad estratégica [3]. Últimamente, una cantidad cada vez mayor de investigación se ha centrado en los lenguajes de representación de nivel superior para modelos de tales lógicas, motivados principalmente por la necesidad de representaciones compactas y para representaciones que se corresponden más estrechamente a los sistemas reales que se modelan. Los sistemas de múltiples agentes son sistemas abiertos, en el sentido de que los agentes interactúan con un entorno solo parcialmente conocido de antemano. Por lo tanto, necesitamos representaciones de modelos de sistemas de múltiples agentes que sean modulares, en el sentido de que un componente, como un agente, puede ser reemplazado, eliminado o agregado, sin cambios importantes en la representación de todo el modelo. Sin embargo, como argumentamos en este documento, pocos lenguajes de representación existentes son modulares, compactos y computacionalmente basados por un lado, y permiten representar propiedades tanto del conocimiento como de la capacidad estratégica. En este artículo presentamos una nueva clase de representaciones para modelos de sistemas abiertos de múltiples agentes, que son modulares, compactos y vienen con una metodología implícita para modelar y diseñar sistemas reales. La estructura del documento es la siguiente. Primero, en la Sección 2, presentamos los antecedentes de nuestro trabajo, es decir, lógicas que combinan tiempo, conocimiento y estrategias. Más precisamente: lógicas modales que combinan el tiempo de ramificación, el conocimiento y las estrategias bajo información incompleta. Comenzamos con la lógica del árbol de cálculo CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de lógica temporal de tiempo alterno (ATL): una para el perfecto y otro para el caso de información imperfecta. La semántica de lógicas como las presentadas en la Sección 2 generalmente se definen sobre modelos explícitos (estructuras de Kripke) que enumeran todos los estados posibles (globales) del sistema. Sin embargo, enumerar estos estados es una de las cosas que uno quiere evitar, porque hay demasiados de ellos incluso para sistemas simples. Por lo tanto, generalmente necesitamos representaciones que sean más compactas. Otra razón para usar una clase de modelos más especializada es que las estructuras generales de Kripke no siempre brindan suficiente ayuda en términos de metodología, tanto en la etapa del diseño, ni en la implementación. Esto requiere una semántica que se basa más en el sentido de que la correspondencia entre los elementos del modelo y las entidades modeladas es más inmediata. En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y verificar modelos sistemas en los que son importantes el tiempo, la acción (y posiblemente el conocimiento);Mencionamos representaciones especialmente utilizadas para el análisis teórico. Señalamos que las representaciones compactas y/o fundamentadas de los modelos temporales no juegan su papel de manera satisfactoria cuando se consideran estrategias de agentes. Finalmente, en la Sección 4, presentamos nuestro marco de sistemas interpretados modulares (MIS) y mostramos dónde encaja en la imagen. Concluimos con una hipótesis algo sorprendente, que la capacidad de verificación de modelos bajo información imperfecta para MIS puede ser computacionalmente más barata que la verificación del modelo de información perfecta. Hasta ahora, casi todos los resultados de complejidad estaban claramente a favor de las estrategias de información perfectas (y los otros eran indiferentes).2. La lógica del tiempo, el conocimiento y la capacidad estratégica primero, presentamos las lógicas CTL, CTLK, ATL y ATLIR que son el punto de partida de nuestro estudio.2.1 Tiempo de ramificación: CTL Computation Tree Logic CTL [6] incluye operadores para propiedades temporales de los sistemas: es decir, cuantificador de ruta e (hay una ruta), junto con operadores temporales: F (en el siguiente estado), 2 (siempre a partir de ahoraOn) y U (hasta) .1 Cada aparición de un operador temporal está inmediatamente precedido por exactamente un cuantificador de ruta (esta variante del lenguaje a veces se llama CTL de vainilla). Sea π un conjunto de proposiciones atómicas con un elemento típico p.Las fórmulas CTL ϕ se definen de la siguiente manera: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |E fϕ |E2ϕ |Eϕ u ϕ. La semántica de CTL se basa en los modelos Kripke M = ST, R, π, que incluyen un conjunto no vacío de estados ST, una relación de transición de estado R ⊆ ST × ST y una valoración de las proposiciones π: π → P (ST). Una ruta λ en M se refiere a un posible comportamiento (o cálculo) del sistema M, y puede representarse como una secuencia infinita de estados Q0Q1Q2 ... tales que qirqi+1 por cada i = 0, 1, 2, .... Denotamos el estado ésano en λ por λ [i]. Un Q-Path es un camino que comienza en q. La interpretación de una fórmula en un estado q en el modelo M se define de la siguiente manera: m, q | = p iff q ∈ π (p);M, q | = ¬ϕ iff m, q | = ϕ;M, q | = ϕ ∧ ψ iff m, q | = ϕ y m, q | = ψ;M, q | = e fϕ iff hay una ruta q λ tal que m, λ [1] | = ϕ;M, q | = e2ϕ iff hay una ruta q λ tal que m, λ [i] | = ϕ por cada i ≥ 0;M, q | = eϕ u ψ iff hay un Q-Path λ e I ≥ 0 tal que m, λ [i] | = ψ y m, λ [j] | = ϕ para cada 0 ≤ j <i.2.2 Agregar conocimiento: CTLK CTLK [19] es una combinación directa de CTL y lógica epistémica estándar [10, 7]. Sea agt = {1, ..., k} un conjunto de agentes con un elemento típico a.La lógica epistémica utiliza operadores para representar el conocimiento de los agentes: Kaϕ se lee como agente A sabe que ϕ. Los modelos de CTLK extienden los modelos de CTL con relaciones epistémicas de indistingencia ∼A⊆ ST × ST (uno por agente). Suponemos que todas las ∼A son equivalencias. La semántica de los operadores epistémicos se define de la siguiente manera: m, q | = kaϕ iff m, q | = ϕ para cada q tal que q ∼A q. Tenga en cuenta que, al hablar sobre el conocimiento de los agentes, asumimos implícitamente que los agentes pueden tener información imperfecta sobre el estado actual real del mundo (de lo contrario, la noción de conocimiento sería trivial). Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una sola unidad, pero será importante cuando los agentes particulares y sus estrategias se destacen.2.3 Agentes y sus estrategias: la lógica temporal de tiempo alterno ATL ATL [3] es una lógica para razonar sobre las propiedades temporales y estratégicas de los sistemas computacionales abiertos (sistemas de múltiples agentes en particular). El lenguaje de ATL consiste en las siguientes fórmulas: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |A fϕ |A 2ϕ |A ϕ u ϕ.donde a ⊆ agt. Informalmente, un ϕ dice que los agentes A tienen una estrategia colectiva para hacer cumplir ϕ. Cabe señalar que los cuantificadores de la ruta CTL A, E se pueden expresar con ∅, AGT respectivamente. La semántica de ATL se define en las llamadas estructuras de juego concurrentes (CGSS). Un CGS es una tupla M = Agt, ST, Act, D, O, π, π, 1 operadores adicionales A (para cada ruta) y 3 (en algún momento en el futuro) se definen de la manera habitual.que consiste en: un conjunto agt = {1 ,..., k} de agentes;establecer el st de los estados;valoración de proposiciones π: π → p (st);Establecer acto de acciones atómicas. Función D: AGT × ST → P (ACT) indica las acciones disponibles para el agente A ∈ AGT en el estado q ∈ St. Finalmente, O es una función de transición determinista que mapea un estado q ∈ ST y un perfil de acción α1 ,..., αk ∈ Actk, αi ∈ D (i, Q), a otro estado q = O (Q, α1, ..., αk). Definición 1. Una estrategia (sin memoria) del agente A es una función SA: ST → ACT de tal manera que SA (Q) ∈ D (A, Q) .2 Una estrategia colectiva SA para un equipo A ⊆ AGT especifica una estrategia individual para cada agente a ∈A. Finalmente, el resultado de la estrategia SA en el estado q se define como el conjunto de todos los cálculos que pueden resultar de ejecutar SA de Q on: out (q, sa) = {λ = q0q1q2 ... |Q0 = Q y por cada i = 1, 2, ... existe αi - 1 1, ..., αi - 1 k tal que αi - 1 a = sa (a) (qi - 1) para cada una a ∈A, αi - 1 a ∈ D (A, Qi - 1) para cada A /∈ A y O (Qi - 1, αi - 1 1, ..., αi - 1 K) = Qi}. La semántica de las modalidades de cooperación es la siguiente: m, q | = a fϕ iff hay una estrategia colectiva sa tal que, por cada λ ∈ (q, sa), tenemos m, λ [1] | = ϕ;M, q | = a 2ϕ iff existe sa tal que, por cada λ ∈ Out (q, sa), tenemos m, λ [i] por cada i ≥ 0;M, q | = a ϕ u ψ si existe sa tal que por cada λ ∈ Out (q, sa) hay un i ≥ 0, para el cual m, λ [i] | = ψ y m, λ [j]| = ϕ por cada 0 ≤ j <i.2.4 Agentes con información imperfecta: ATLIR AS ATL no incluye información incompleta en su alcance, puede verse como una lógica para razonamiento sobre los agentes que siempre tienen conocimiento completo sobre el estado actual de todo el sistema. Atlir [21] incluye las mismas fórmulas que ATL, excepto que las modalidades de cooperación se presentan con un subíndice: un IR indica que abordan a los agentes con información imperfecta y un retiro imperfecto. Formalmente, la definición recursiva de las fórmulas Atlir es: ϕ :: = P |¬ϕ |ϕ ∧ ϕ |A IR fϕ |Un ir2ϕ |Los modelos Irϕ u ϕ de Atlir, estructuras de juegos epistémicos concurrentes (CEG), pueden definirse como tuplas m = agt, st, acto, d, o, ∼1, ..., ∼k, π, π, donde agt,ST, Act, D, O, π, π es un CGS, y ∼1, ..., ∼K son relaciones epistémicas (equivalencia). Se requiere que los agentes tengan las mismas opciones en estados indistinguibles: Q ∼A Q implica D (A, Q) = D (A, Q). Atlir restringe las estrategias que los agentes pueden usar para estrategias uniformes, es decir, funciones sa: st → actuar, de modo que: (1) sa (q) ∈ D (a, q) y (2) si q ∼A q entonces sa(q) = sa (q). Una estrategia colectiva es uniforme si contiene solo estrategias individuales uniformes. Nuevamente, la función (Q, SA) devuelve el conjunto de todas las rutas que pueden resultar de los agentes una estrategia colectiva de ejecución SA del estado q. La semántica de las fórmulas de Atlir se puede definir de la siguiente manera: m, q | = a ir fϕ iff hay una estrategia colectiva uniforme sa tal que, por cada a ∈ A, q tal que q ∼A q y λ ∈ Out (sa,,q), tenemos m, λ [1] | = ϕ;2 Esta es una desviación de la semántica original de ATL [3], donde las estrategias asignan opciones de agentes a secuencias de estados, lo que sugiere que los agentes pueden, por definición, recordar toda la historia de cada juego. Si bien la elección de una u otra noción de estrategia afecta la semántica del ATL ∗ completo ∗, y la mayoría de las extensiones de ATL (por ejemplo, para juegos con información imperfecta), debe señalarse que ambos tipos de estrategias producen semánticas equivalentes para ATL puro (CF. [21]).898 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (aamas 07) m, q | = a ir2ϕ si existe sa tal que, por cada a ∈ A, q tal que Q ∼A Q y λ ∈ Out (Sa, Q), nosotros, nosotros, nosotros, nosotrostener m, λ [i] por cada i ≥ 0;M, q | = a irϕ u ψ si existan sa tal que, por cada a ∈ A, q tal que q ∼A q, y λ ∈ Out (sa, q), hay i ≥ 0 para el cual m, λ [i] | = ψ, y m, λ [j] | = ϕ por cada 0 ≤ j <i. Es decir, un IRϕ se mantiene si tiene una estrategia colectiva uniforme, de modo que para cada ruta que pueda resultar de la ejecución de la estrategia de acuerdo con al menos un agente de A, ϕ es el caso.3. Modelos y verificación de modelos En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden usarse para modelar y verificación de modelos. Creemos que los dos puntos de referencia más importantes son en este caso: (1) el formalismo de modelado (es decir, la lógica y la semántica que usamos) y (2) el fenómeno, o más generalmente, el dominio que vamos amodelo (al que a menudo nos referiremos como el mundo real). Nuestro objetivo es una representación que está razonablemente cerca del mundo real (es decir, es suficientemente compacta y basada), y aún no muy lejos del formalismo (por lo que, por ejemplo, permite fácilmente un análisis teórico de problemas computacionales). Comenzamos con discutir los méritos de los modelos explícitos en nuestro caso, estos son sistemas de transición, estructuras de juegos concurrentes y CEGS, presentados en la sección anterior.3.1 Modelos explícitos Obviamente, una ventaja de modelos explícitos es que están muy cerca de la semántica de nuestras lógicas (simplemente porque son la semántica). Por otro lado, son, en muchos sentidos, difíciles de usar para describir un sistema real: • Tamaño exponencial: los modelos temporales generalmente tienen un número exponencial de estados con respecto a cualquier descripción de nivel superior (p. Ej. Variables booleanas, atributos N-ARY, etc.). Además, su tamaño es exponencial en el número de procesos (o agentes) si la evolución de un sistema resulta de acciones articulares (sincrónicas o asincrónicas) de varias entidades activas [15]. Para CGSS, la situación es aún peor: aquí, también el número de transiciones es exponencial, incluso si solucionamos el número de estados.3 En la práctica, esto significa que tales representaciones rara vez son muy escalables.• Los modelos explícitos no incluyen modularidad. Los estados en un modelo se refieren a los estados globales del sistema;Las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién y de qué manera.• Las lógicas como ATL a menudo se anuncian como marcos para modelar y razonar sobre sistemas computacionales abiertos. Idealmente, a uno le gustaría que los elementos de dicho sistema tengan la menor cantidad de interdependencias como sea posible, para que puedan enchufarlos sin mucha molestia, por ejemplo, cuando queremos probar varios diseños o implementaciones del componente activo. En el caso de un sistema de múltiples agentes, la 3 otra clase de modelos ATL, los sistemas de transición alternativos [2] representan transiciones de una manera más sucinta. Si bien todavía tenemos exponencialmente muchos estados en un ATS, el número de transiciones es simplemente WRT cuadrática.a estados (como para modelos CTL). Desafortunadamente, los AT son aún menos modulares y más difíciles de diseñar que las estructuras de juego concurrentes, y no pueden extenderse fácilmente para manejar información incompleta (cf. [9]).La necesidad es quizás aún más obvia. No solo necesitamos volver a aplicar varios diseños de un solo agente en la arquitectura general;Por lo general, también necesitamos cambiar (por ejemplo, aumentar) el número de agentes que actúan en un entorno determinado sin cambiar necesariamente el diseño de todo el sistema. Desafortunadamente, los modelos ATL son todo menos abiertos en este sentido. Los resultados de complejidad teórica para modelos explícitos son los siguientes. La comprobación de modelos CTL y CTLK se complete P, y se puede hacer en el tiempo O (ml), donde M es el número de transiciones en el modelo, y L es la longitud de la fórmula [5]. Alternativamente, se puede hacer en el tiempo O (N2 L), donde n es el número de estados. La verificación del modelo ATL es P-Complete WRT.M, L y ΔP 3 -complicado WRT.N, K, L (K es el número de agentes) [3, 12, 16]. La verificación del modelo ATLIR es ΔP 2Complete WRT.M, L y ΔP 3 -complicado WRT.N, K, L [21, 13].3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras. Una alternativa es representar el espacio de estado/transición de manera simbólica [17, 18]. Dichos modelos ofrecen alguna esperanza de propiedades de verificación de modelos factibles de los sistemas abiertos/múltiples agentes, aunque es bien sabido que son compactos solo en una fracción de todos los casos.4 Sin embargo, son insuficientes por otra razón: sonRepresentaciones simplemente optimizadas de modelos explícitos. Por lo tanto, no están más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar la metodología de diseño o modelado.3.3 Sistemas interpretados Los sistemas interpretados [11, 7] están en poder de muchos como un excelente ejemplo de modelos de sistemas distribuidos computacionalmente fundamentados. Un sistema interpretado se puede definir como una tupla IS = ST1, ..., stk, stenv, r, π. ST1, ..., STK son espacios de estado locales de los agentes 1, ..., K, y Stenv es el conjunto de estados del medio ambiente. El conjunto de estados globales se define como ST = ST1 × ... × STK × STENV;R ⊆ st × st es una relación de transición, y π: π → p (st). Mientras que la relación de transición encapsula la (posible) evolución del sistema a lo largo del tiempo, la dimensión epistémica se define por los componentes locales de cada estado global: Q1, ..., Qk, Qenv ∼i Q1, ..., QK, QenVIFF qi = qi. Es fácil ver que tal representación es modular y compacta en lo que a nosotros nos preocupa los estados. Además, ofrece un enfoque natural (fundamentado) del conocimiento, y sugiere una metodología intuitiva para modelar estados epistémicos. Desafortunadamente, la forma en que se representan las transiciones en los sistemas interpretados no es compacta, ni modular, ni fundamentada: el aspecto temporal del sistema está dado por una función de transición articular, exactamente como en modelos explícitos. Esto no es sin una razón: si separamos demasiado las actividades de los agentes, ya no podemos modelar la interacción en el marco, y la interacción es lo más interesante aquí. Pero la conclusión es que la dimensión temporal de un sistema interpretado tiene representación exponencial. Y es casi tan difícil enchufar los componentes dentro y fuera de un sistema interpretado, como para un modelo CTL o ATL ordinario, ya que la actividad local de un agente se fusiona por completo con su interacción con el resto del sistema.3.4 Programas concurrentes La idea de programas concurrentes ha sido conocida durante mucho tiempo en la literatura sobre sistemas distribuidos. Aquí, usamos la formulación de [15]. Un programa concurrente P está compuesto por k procesos concurrentes, cada uno descrito por un sistema de transición etiquetado PI = STI, ACTI, RI, πi, πi, donde la ITS es el conjunto de estados locales del proceso 4 representación r de un modelo explícito es compactoSi el tamaño de R es logarítmico con respecto al tamaño de M. el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 899 I, Acti es el conjunto de acciones locales, RI ⊆ STI × Acti × STI es una relación de transición, y πi, πi son el conjunto de proposiciones locales y su valoración. El comportamiento del programa P viene dado por el autómata del producto de P1, ..., PK bajo el supuesto de que los procesos funcionan de manera asincrónica, las acciones están entrelazadas y la sincronización se obtiene a través de nombres de acción comunes. Los programas concurrentes tienen varias ventajas. En primer lugar, son modulares y compactos. Permiten el modelado local de componentes, mucho más que los sistemas interpretados (no solo los estados, sino que también las acciones son locales aquí). Además, permiten representar una interacción explícita entre las transiciones locales de procesos reactivos, como la comunicación intencional y la sincronización. Por otro lado, no permiten representar una interacción implícita, incidental o no completamente benevolente entre los procesos. Por ejemplo, si queremos representar el acto de empujar a alguien, el objeto empujado debe ejecutar explícitamente una acción de ser empujado, lo que parece algo ridículo. Los efectos secundarios de las acciones tampoco son fáciles de modelar. Aún así, esta es una queja menor en el contexto de CTL, porque para las lógicas temporales solo estamos interesados en el flujo de transiciones, y no en las acciones subyacentes. Para el razonamiento temporal sobre los procesos asíncronos K sin interacción implícita, los programas concurrentes parecen casi perfectos. La situación es diferente cuando hablamos de componentes autónomos y proactivos (como agentes), actuando juntos (cooperativamente o adversamente) en un entorno común, y queremos abordar sus estrategias y habilidades. Ahora, las acciones particulares no son menos importantes que las transiciones resultantes. Las acciones pueden influir en los estados locales de otros agentes sin su consentimiento, pueden tener efectos secundarios en otros estados de agentes, etc. Pasar mensajes y/o los procedimientos de llamadas de ninguna manera es la única forma de interacción entre los agentes. Además, la disponibilidad de acciones (para un agente) no debe depender de las acciones que serán ejecutadas por otros agentes al mismo tiempo: ¡estos son los estados de resultado que pueden depender de estas acciones! Finalmente, a menudo nos gustaría suponer que los agentes actúan sincrónicamente. En particular, todos los agentes juegan simultáneamente en estructuras de juegos concurrentes. Pero, asumiendo la sincronía y la autonomía de las acciones, la sincronización ya no puede ser un medio de coordinación. En resumen, necesitamos una representación que se parezca mucho a los programas concurrentes, pero que permita modelar agentes que juegan sincrónicamente, y que permita el modelado de una interacción más sofisticada entre las acciones de los agentes. El primer postulado es fácil de satisfacer, como mostramos en la siguiente sección. El segundo se dirigirá en la Sección 4. Observamos que la comprobación de modelos de CTL contra programas concurrentes es completado con PSPACE en el número de estados locales y la longitud de la fórmula [15].3.5 CP sincrónico y módulos reactivos simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones que actualmente ejecutan los otros jugadores. Se puede definir una variante ligeramente diferente de los programas concurrentes a través del producto sincrónico de programas, de modo que todos los agentes juegan simultáneamente.5 Desafortunadamente, bajo dicha interpretación, no se puede modelar la interacción directa entre las acciones de los agentes. Definición 2. Un programa concurrente sincrónico consiste en k procesos concurrentes PI = STI, Acti, Ri, πi, πi con el siguiente 5 El concepto no es nuevo, por supuesto, y ya ha existido en el conocimiento popular, aunque no logramos encontrar una definición explícita en elliteratura.Inglocando a un CGS: Agt = {1, ..., k}, st = qk i = 1 sti, act = sk i = 1 acti, d (i, q1, ..., qk) = {αi |qi, αi, qi ∈ Ri para algunos qi ∈ STI}, o (Q1, ..., QK, α1, ..., αk) = Q1, ..., QK tal que Qi, αi, qi ∈ Ri paracada yo;Π = sk i = 1 πi, y π (p) = πi (p) para p ∈ πi. Observamos que los módulos reactivos simples (SRML) de [22] pueden verse como una implementación particular de programas concurrentes sincrónicos. Definición 3. Un sistema SRML es una tupla σ, π, m1 ,..., mk, donde σ = {1 ,..., k} es un conjunto de módulos (o agentes), π es un conjunto de variables booleanas y, para cada i ∈ σ, tenemos mi = ctri, initi, updatei, donde ctri ⊆ π. Establece Initi y UpdateI consisten en comandos guardados de la forma φ;V1: = ψ1;...;vk: = ψk, donde cada vj ∈ Ctri, y φ, ψ1 ,..., ψk son fórmulas proposicionales sobre π. Se requiere que CTR1 ,...Particiones CTRK π. La idea es que el agente I controla las variables CTRI. Los comandos Init Protector se utilizan para inicializar las variables controladas, mientras que los comandos de actualización de actualización pueden cambiar sus valores en cada ronda. Se habilita un comando guardado si la guardia φ es verdadera en el estado actual del sistema. En cada ronda se ejecuta un comando guardado de actualización habilitado: cada ψj se evalúa contra el estado actual del sistema, y su valor lógico se asigna a VJ. Varios comandos protegidos se habilitan al mismo tiempo de elección del modelo no determinista. La comprobación de modelos de ATL para SRML se ha demostrado que ExptimeMecompletía en el tamaño del modelo y la longitud de la fórmula [22].3.6 Programas epistémicas concurrentes Los programas concurrentes (tanto asíncronos como sincrónicos) pueden usarse para codificar las relaciones epistémicas también, exactamente de la misma manera que los sistemas interpretados [20]. Es decir, al desarrollar un programa concurrente a un modelo de CTLK o Atlir, definimos que Q1, ..., qk ∼i Q1, ..., qk iff qi = qi. Comprobación de modelos CTLK contra programas epistémicos concurrentes es PSPACE-COMPLETO [20]. SRML también se puede interpretar de la misma manera;Luego, asumiríamos que cada agente solo puede ver las variables que controla. Los programas epistémicos concurrentes son modulares y tienen una semántica fundamentada. Por lo general, son compactos (aunque no siempre: por ejemplo, un agente con información perfecta siempre explotará el tamaño de dicho programa). Aún así, heredan todos los problemas de los programas concurrentes con información perfecta, discutidas en la Sección 3.4: Interacción limitada entre componentes, disponibilidad de acciones locales que dependen de la transición real, etc. Los problemas ya eran importantes para los agentes con información perfecta, pero se vuelven aún más cruciales cuando los agentes solo tienen un conocimiento limitado de la situación actual. Una de las aplicaciones más importantes de las lógicas que combinan propiedades estratégicas y epistémicas es la verificación de los protocolos de comunicación (por ejemplo, en el contexto de la seguridad). Ahora, es posible que deseemos, por ejemplo, verificar la capacidad de los agentes para pasar una información entre ellos, sin dejar que nadie más intercepte el mensaje. El punto es que la acción de interceptar está habilitada por definición;Simplemente buscamos un protocolo en el que nunca se lleva a cabo la transición de una intercepción exitosa. Por lo tanto, la disponibilidad de acciones debe ser independiente de las acciones elegidas por los otros agentes bajo información incompleta. Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas de múltiples agentes, y es realmente difícil imaginar modelos de lógicas estratégicas epistémicas, en las que no es posible representar la comunicación.3.7 Módulos reactivos Los módulos reactivos [1] pueden verse como un refinamiento de programas epistémicos concurrentes (utilizados principalmente por el controlador del modelo Mocha [4]), pero son mucho más potentes, expresivos y 900 el sexto INTL. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) fundamentados. Ya hemos mencionado una variante muy limitada de RML (es decir, SRML). El vocabulario de RML está muy cerca de las implementaciones (en términos de sistemas computacionales generales): los módulos son esencialmente colecciones de variables, los estados son solo valoraciones de variables;Los eventos/acciones son actualizaciones variables. Sin embargo, los conjuntos de variables controladas por diferentes agentes pueden superponerse, pueden cambiar con el tiempo, etc. Además, los módulos reactivos admiten información incompleta (a través de la observabilidad de las variables), aunque no es el foco principal de RML. Nuevamente, la relación entre los conjuntos de variables observables (y a los conjuntos de variables controladas) se deja principalmente al diseñador de un sistema. Los agentes pueden actuar sincrónicamente e asincrónicamente. En resumen, RML define un marco poderoso para modelar sistemas distribuidos con varios tipos de sincronía y asincronía. Sin embargo, creemos que todavía existe la necesidad de una clase de representaciones más simple y ligeramente más abstracta. Primero, el marco de RML es técnicamente complicado, que implica un número de conceptos auxiliares y sus definiciones. En segundo lugar, no siempre es conveniente representar todo lo que está sucediendo en un sistema de múltiples agentes como lectura y/o escritura de/a las variables del programa. Esta visión de un sistema de múltiples agentes está posiblemente cerca de su implementación de computadora, pero generalmente bastante distante del dominio del mundo real, por lo tanto, la necesidad de un marco más abstracto y más flexible conceptualmente flexible. Tercero, la separación de la complejidad local y la complejidad de la interacción no es sencilla. Nuestra nueva propuesta, más en el espíritu de los sistemas interpretados, toma estas observaciones como el punto de partida. El marco propuesto se presenta en la Sección 4. 4. Sistemas interpretados modulares La idea detrás de los sistemas distribuidos (sistemas de múltiples agentes aún más) es que tratamos varios componentes libremente acoplados, donde la mayor parte del procesamiento continúa dentro de los componentes (es decir, localmente), y solo una pequeña fracción del procesamientoocurre entre los componentes. La interacción es crucial (lo que hace que los programas concurrentes sean una herramienta de modelado insuficiente), pero generalmente consume mucho menos recursos de los agentes que los cálculos locales (lo que hace que las tablas de transición explícitas de CGS, CEG y sistemas interpretados sean excesivos). Los sistemas interpretados modulares, propuestos aquí, extrapolan la idea de modelado detrás de los sistemas interpretados de una manera que permite un control estricto de la complejidad de interacción. Definición 4. Un sistema modular interpretado (MIS) se define como una tupla s = agt, env, actuar, en, donde agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, el acto es un conjunto deAcciones, y en un conjunto de símbolos llamados alfabeto de interacción. Cada agente tiene la siguiente estructura interna: ai = sti, di, outi, ini, oi, πi, πi, donde: • STI es un conjunto de estados locales, • DI: STI → P (ACT) define la disponibilidad local de acciones;Para conveniencia de la notación, también definimos el conjunto de acciones situadas como di = {qi, α |qi ∈ STI, α ∈ Di (qi)}, • outi, ini son funciones de interacción;Outi: Di → In se refiere a la influencia que una acción situada dada (del Agente AI) posiblemente puede tener en el mundo externo, e ini: STI × Ink → en traduce manifestaciones externas de los otros agentes (y el entorno) en la impresiónque realizan en la función de transición AIS dependiendo del estado local de Ai, • Oi: Di × in → STI es una función de transición local (determinista), • πi es un conjunto de proposiciones locales de agente ai donde requerimos que πi y πjestán disyuntados cuando i = j, y • πi: πi → P (ITS) es una valoración de estas proposiciones. El entorno env = stenv, outenv, inenv, oenv, πenv, πenv tiene la misma estructura que un agente, excepto que no realiza acciones, y que, por lo tanto, outenv: stenv → in y oenv: stenv × in → stenv. Dentro de nuestro marco, suponemos que cada acción es ejecutada por un actor, es decir, un agente. Como consecuencia, cada actor está explícitamente representado en un MIS como agente, al igual que en el caso de CGS y CEG. El entorno, por otro lado, representa el contexto (pasivo) de las acciones de los agentes. En la práctica, sirve para capturar los aspectos del estado global que no son observables por ninguno de los agentes. Las funciones de entrada no parecen ser los puntos frágiles aquí: cuando se dan explícitamente como tablas, tienen WRT exponencial de tamaño.El número de agentes (y WRT lineal del tamaño de In). Sin embargo, podemos usar, por ejemplo, una construcción similar a la de [16] para representar funciones de interacción de manera más compacta. Definición 5. La función de entrada implícita para el estado q ∈ STI viene dada por una secuencia ϕ1, η1, ..., ϕn, ηn, donde cada ηj ∈ en es un símbolo de interacción, y cada ϕJ es una combinación booleana de proposiciones ˆηi, con η ∈ In;ˆΗi significa η es el símbolo actualmente generado por el agente i. La función de entrada ahora se define de la siguiente manera: ini (q, 1, ..., k, env) = ηj iff j es el índice más bajo tal que {ˆ1 1, ..., ˆk k, ˆenv env} | = ϕJ. Se requiere que ϕn ≡, de modo que el mapeo sea efectivo. Observación 1. Cada INI puede codificarse como una función de entrada implícita, con cada ϕj de tamaño polinomial con respecto al número de símbolos de interacción (cf. [16]). Tenga en cuenta que, para algunos dominios, la representación MIS de un sistema requiere exponencialmente muchos símbolos en el alfabeto de interacción. En tal caso, el problema es inherente al dominio, e INI tendrá un tamaño exponencial de WRT el número de agentes.4.1 Representar los sistemas de agentes con MIS STG = (QK I = 1 STI) × StenV es el conjunto de todos los estados globales posibles generados por un sistema modular interpretado S. Definición 6. El desarrollo de un mis s para los estados iniciales q ⊆ stg a un cegs cegs (s, q) = agt, st, π, π, act, d, o, ∼1, ..., ∼K se define de la siguiente manera:• AGT = {1, ..., k} y act = Act, • St es el conjunto de estados globales de STG que se pueden accesibles de algún estado en Q a través de la relación de transición definida por O (abajo), • π = SKi = 1 πi ∪ πenv, • para cada q = q1 ,..., qk, qenv ∈ ST e i = 1, ..., k, env, definimos q ∈ π (p) iff p ∈ πi y qi ∈ πi (p), • d (i, q) = di (qi) para el estado global q = q1, ..., qk, qenv, • La función de transición se construye de la siguiente manera. Deje Q = Q1, ..., Qk, Qenv ∈ ST, y α = α1, ..., αK ser un perfil de acción S.T.αi ∈ D (i, Q). Definimos inputi (q, α) = ini `qi, out1 (q1, α1) ,..., outi - 1 (qi - 1, αi - 1), outi+1 (qi+1, αi+1) ,..., Outk (QK, αK), outenv (Qenv) ´ para cada agente i = 1 ,..., k, y inputenv (q, α) = inenv `qenv, out1 (q1, α1) ,..., Outk (QK, αK) ´. Entonces, O (Q, α) = O1 (Q1, α1, Input1 (Q, α)) ,..., OK (QK, αK, InputK (Q, α)), OenV (QENV, InputEnv (Q, α));El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 901 • Para cada i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi.6 Observación 2. Tenga en cuenta que Miss puede usarse como representaciones de CGSS también. En ese caso, las relaciones epistémicas ∼i simplemente se omiten en el desarrollo. Denotamos el desarrollo de un error para los estados iniciales Q en un CGS por CGS (S, Q). Las proposiciones 3 y 5 establecen que los sistemas interpretados modulares pueden usarse como representaciones para modelos explícitos de sistemas de agentes múltiples. Por otro lado, estas representaciones no siempre son compactas, como lo demuestran las proposiciones 7 y 8. Proposición 3. Para cada CEGS M, hay un MIS SM y un conjunto de estados globales Q de SM, tal que CEGS (SM, Q) es isomórfico a M.7 Prueba. Sea M = {1 ,..., k}, st, act, d, o, π, π, ∼1 ,..., ∼K ser un CEGS. Construimos un mis sm = {a1 ,..., ak}, env, actúa, con agentes ai = sti, di, outi, ini, oi, πi, πi y ambiente env = stenv, outenv, inenv, oenv, πenv, πenv, más un conjunto Q ⊆ stg de globalEstados, como sigue.• In = Act ∪ st ∪ (actk - 1 × st), • sti = {[q] ∼i |q ∈ ST} para 1 ≤ i ≤ k (es decir, la ITS es el conjunto de clases de indistinguabilidad IS en m), • stenv = st, • di ([q] ∼i) = d (i, q) para 1 ≤ i≤ k (esto está bien definido ya que d (i, q) = d (i, q) siempre que q ∼i q), • outi ([q] ∼i, αi) = αi para 1 ≤ i ≤ k;outV (q) = q, • ini ([q] ∼i, α1, ..., αi - 1, αi+1, ..., αk, qenv) = α1 ,..., αi - 1, αi+1 ,..., αk, qenv para i ∈ {1 ,..., k};Inenv (Q, α1 ..., αk) = α1 ,..., αk;ini (x) e inenv (x) son arbitrarios para otros argumentos x, • oi ([q] ∼i, αi, α1, ..., αi - 1, αi+1, ..., αk, qenv) =[O (QenV, α1, ..., αk)] ∼i para 1 ≤ i ≤ k y αi ∈ Di ([Q] ∼i);Oenv (Q, α1, ..., αk) = O (Q, α1, ..., αk);OI y OENV son arbitrarios para otros argumentos, • πi = ∅ para 1 ≤ i ≤ k, y πenv = π, • πenv (p) = π (p) • q = {[q] ∼1 ,..., [Q] ∼K, Q: Q ∈ ST} Sea M = Cegs (Sm, Q) = Agt, ST, Act, D, O, π, π, ∼1 ,..., ∼K. Argumentamos que m y Primero mostramos que, para cualquier ˆq = [q] ∼1 ,..., [q] ∼k, q ∈ Q y cualquier α = α1 ,..., αk tal que αi ∈ D (i, ˆq), tenemos o (ˆq, α) = [q] ∼1 ,..., [q] ∼k, q donde q = o (q, α) (1) dejen ˆq = o (ˆq, α). Ahora, para cualquier i: inputi (ˆq, α) = ini ([q] ∼i, out1 ([q] ∼1, α1), ..., outi - 1 ([q] ∼i - 1, αi−1), outi+1 ([Q] ∼i+1, αi+1), ..., Outk ([q] ∼k, αk), outenv (q)) = ini ([q] ∼i, α1.../o acciones ..., αk, q) = α1 ,..., αi - 1, αi+1 ,..., αk, q. Del mismo modo, obtenemos esa entrada (ˆq, α) = α1 ,..., αk. Por lo tanto, obtenemos que O (ˆq, α) = O1 ([Q] ∼1, α1, input1 (ˆq, α)) ,..., OK ([Q] ∼K, αk, inputk (ˆq, α)), Oenv (Q, inputenv (ˆq, α)) = [o (Q, α1, ..., αk)] ∼1 ,..., [O (Q, α1, ..., αk)] ∼K, O (Q, α1, ..., αk). Por lo tanto, ˆq = [q] ∼1 ,..., [Q] ∼K, Q para Q = O (Q, α1, ..., αk), que completa la prueba de (1). Ahora argumentamos que St = Q. Claramente, Q ⊆ st. Sea ˆq ∈ ST;Debemos mostrar que ˆq ∈ Q. El argumento está en la inducción en la longitud de la ruta menor O de Q a ˆQ. El caso base, ˆq ∈ Q, es inmediato. Para el paso inductivo, ˆq = O (ˆq, α) para algunos ˆq ∈ Q, y luego tenemos que ˆq ∈ Q por (1). Así, st = Q. Ahora tenemos una correspondencia uno a uno entre ST y ST: R ∈ ST corresponde a [R] ∼1 ,..., [r] ∼k, r ∈ ST. Queda por demostrar que las otras partes de las estructuras mym coinciden en los estados correspondientes: • agt = agt, • act = act, • π = sk i = 1 πi ∪ πenv = π, • para p ∈ π = π: [Q] ∼1 ,..., [q] ∼k, q ∈ π (p) iff q ∈ πenv (p) iff q ∈ π (p) (las mismas valoraciones en los estados correspondientes), • d (i, [q] ∼1, ..,.[Q] ∼k, q) = di ([q] ∼i) = d (i, q), • sigue inmediatamente de (1), y el hecho de que q = st, que o ([q] ∼1, ..., [q] ∼k, q, α) = [r] ∼1 ,..., [r] ∼k, r iff o (q, α) = r (las transiciones en la misma acción conjunta en los estados correspondientes conducen a los estados correspondientes), • [Q] ∼1 ,..., [q] ∼k, q ∼i [r] ∼1 ,..., [r] ∼k, r iff [q] ∼i = [r] ∼i iff q ∼i r (las relaciones de accesibilidad relacionan los estados correspondientes), que completa la prueba. Corolario 4. Para cada CEGS M, hay un error equivalente de Atlir con los estados iniciales Q, es decir, para cada estado Q en M hay un estado Q en CEGS (S, Q) que satisface exactamente las mismas fórmulas de Atlir y viceversa. Proposición 5. Para cada CGS m, hay un mis SM y un conjunto de estados globales Q de SM de modo que CGS (SM, Q) es isomórfico para M. Prueba. Sea M = Agt, St, Act, D, O, π, π. Ahora, deje ˆm = agt, st, act, d, o, π, π, ∼1 ,..., ∼K para algunas relaciones de accesibilidad arbitrarias ∼i sobre St. Por la Proposición 3, existe un mis s ˆm con los estados globales Q tal que ˆm = cegs (s ˆm, q) es isomórfico a ˆm. Sea M el CGS obtenido eliminando las relaciones de accesibilidad de ˆm. Claramente, M es isomórfico a M. Corolario 6. Para cada CGS m, hay un error equivalente de ATL con los estados iniciales Q. Es decir, para cada estado Q en M hay un estado Q en CGS (s, Q) que satisface exactamente las mismas fórmulas ATL, y viceversa. Proposición 7. Los espacios de estado local en un MIS no siempre son compactos con respecto a la estructura de juegos epistémico concurrente subyacente. PRUEBA. Tome un CEGS M en el que el agente I siempre tenga información perfecta sobre el estado global actual del sistema. Al construir un sistema interpretado modular s de tal manera que M = CEGS (S, Q), tenemos que la ITS debe ser isomórfica con St. 902 el sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), la propiedad anterior es parte del patrimonio de sistemas interpretados. La siguiente proposición se deriva del hecho de que los modelos explícitos (y los sistemas interpretados) permiten una interacción intensiva entre los agentes. Proposición 8. El tamaño de In in S es, en general, exponencial con respecto al número de estados locales y acciones locales. Este es el caso incluso cuando las relaciones epistémicas no son relevantes (es decir, cuando S se toma como una representación de un CGS ordinario). PRUEBA. Considere un CGS m con agentes agt = {1, ..., k}, estados globales st = qk i = 1 {qi 0, ..., qi i}, y acto de acciones = {0, 1}, todos habilitadosen todos lados. La función de transición se define como O (Q1 J1, ..., QK JK, α1, ..., αk) = Q1 L1, ..., QK LK, donde Li = (Ji + α1 + ... + αK) mod i. Tenga en cuenta que M puede representarse como un sistema interpretado modular con espacios de estado locales sucintos STI = {qi 0, ..., qi i}. Aún así, las acciones actuales de todos los agentes son relevantes para determinar la transición local resultante del agente i. Llamaremos elementos a, outi, ini la capa de interacción de un sistema modular interpretado S;Los otros elementos de S constituyen la capa local del MIS. En este artículo, finalmente estamos interesados en verificar la complejidad del modelo con respecto al tamaño de la capa local. Con este fin, asumiremos que el tamaño de la capa de interacción es polinomial en el número de estados y acciones locales. Tenga en cuenta que, según las proposiciones 7 y 8, no todos los modelos explícitos se presentan a la representación compacta con un MIS. Aún así, como declaramos al comienzo de la Sección 4, estamos principalmente interesados en un marco de modelado para sistemas de componentes libremente acoplados, donde la interacción es esencial, pero la mayoría de los procesos se realizan localmente de todos modos. Más importante aún, el marco de MIS permite separar la interacción de los agentes de su estructura local en mayor medida. Además, podemos controlar y medir la complejidad de cada capa de una manera más fina que antes. Primero, podemos tratar de abstrae de la complejidad de una capa (por ejemplo, como en este documento, suponiendo que la otra capa se mantenga dentro de ciertos límites de complejidad). En segundo lugar, también podemos medir por separado la complejidad de interacción de diferentes agentes.4.2 Sistemas interpretados modulares vs. Módulos reactivos simples en esta sección mostramos que los módulos reactivos simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares. Primero, definimos nuestra noción (bastante fuerte) de equivalencia de representaciones. Definición 7. Dos representaciones son equivalentes si se desarrollan a las estructuras isomórficas de juegos epistémicos concurrentes. Son equivalentes de CGS si se desarrollan a los mismos CG. Proposición 9. Para cualquier SRML hay un MIS equivalente de CGS. PRUEBA. Considere un SRML R con m módulos y variables N. Construimos s = agt, actuamos, en agt = {a1, ..., ak}, act = {1, ..., n, ⊥1, ..., ⊥n}, y en = sk i =1 STI × STI (la ITS de los espacios de estado locales se definirá en un momento). Supongamos sin pérdida de generalidad que ctri = {x1, ..., xr}. Además, consideramos que todos los comandos protegidos de I son de tipo γi, ψ: ψ;xi: =, o γ⊥ i, ψ: ψ;xi: = ⊥. Ahora, el agente ai en S tiene los siguientes componentes: STI = P (CTRI) (es decir, los estados locales de AI son valoraciones de variables controladas por I);di (qi) = {1, ..., r, ⊥1, ..., ⊥r};outi (qi, α) = qi, qi;ini (qi, q1, q1, ..., qi - 1, qi - 1, qi+1, qi+1, qk, qk) = {xi ∈ Ctri |Q1, ..., qk | = W γi, ψ ψ}, {xi ∈ Ctri |Q1, ..., qk | = W γ⊥ I, ψ ψ}. Para definir las transiciones locales, consideramos tres casos. Si t = F = ∅ (no se habilita la actualización), entonces Oi (Qi, α, T, F) = Qi para cada acción α. Si t = ∅, tomamos cualquier arbitrary ˆx ∈ T, y definimos oi (qi, j, t, f) = qi ∪ {xj} if xj ∈ T, y qi ∪ ∪ {ˆx} de lo contrario;oi (qi, ⊥j, t, f) = qi \\ {xj} if xj ∈ F, y qi ∪ {ˆx} de lo contrario. Además, si t = ∅ = f, tomamos cualquier arbitrary ˆx ∈ F, y definimos oi (qi, j, t, f) = qi ∪ {xj} if xj ∈ T, y qi \\ {ˆxx} de lo contrario;oi (qi, ⊥j, t, f) = qi \\ {xj} if xj ∈ F, y qi \\ {ˆx} de lo contrario. Finalmente, πi = ctri, y qi ∈ πi (xj) iff xj ∈ Qi. La construcción anterior muestra que SRML tiene una representación más compacta de los estados que las variables locales de MIS del agente, doy lugar a los estados locales 2RI. En cierto modo, los módulos reactivos (tanto simples y completos) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos;A continuación, cada módulo puede verse como un producto de sus variables (junto con sus operaciones de actualización). Sin embargo, tenga en cuenta que la especificación de actualizaciones con respecto a una sola variable en un SRML puede requerir comandos protegidos de la longitud total O (2 PK I = 1 RI). Por lo tanto, la representación de transiciones en SRML no es (en el peor de los casos) no más compacta que en MIS, a pesar de la estructura de dos niveles de SRML. Observamos finalmente que MIS son más generales, porque en SRML las acciones actuales de otros agentes no tienen influencia en el resultado del agente es la acción actual (aunque el resultado puede verse influenciado por los estados locales actuales de otros agentes).4.3 Comprobación de modelos Sistemas interpretados modulares Uno de nuestros objetivos principales fue estudiar la complejidad del modelo simbólico, comprobación de Atlir de una manera significativa. Siguiendo los comentarios de los revisores, establecemos nuestros resultados de complejidad solo como conjeturas. Las pruebas preliminares se pueden encontrar en [14]. Conjetura 10. La verificación de modelos de ATL para sistemas interpretados modulares es completado. Conjetura 11. La verificación del modelo Atlir para la clase de sistemas interpretados modulares es PSPACE-COMPLETO. En la tabla se proporciona un resumen de los resultados de complejidad para la verificación del modelo de lógica temporal y estratégica (con y sin componente epistémico). La tabla presenta resultados de integridad para varios modelos y configuraciones de parámetros de entrada. Los símbolos N, K, M representan el número de estados, agentes y transiciones en un modelo explícito;L es la longitud de la fórmula, y Nlocal es el número de estados locales en un programa concurrente o sistema modular interpretado. Los nuevos resultados, conjeturados en este documento, se imprimen en cursiva. Tenga en cuenta que el resultado para la verificación del modelo ATL contra sistemas interpretados modulares es una extensión del resultado de [22].M, L N, K, L Nlocal, K, L CTL P [5] P [5] Pspace [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] Exptime Atlir ΔP 2 [21, 13] ΔP 3 [13] PSPACE Si somos correctos, entonces los resultados para ATL y ATLIR forman un patrón intrigante. Cuando comparamos los agentes de verificación de modelos con información perfecta versus imperfecta, el primer problema parece ser mucho más fácil con los modelos explícitos medidos con el número de transiciones;A continuación, obtenemos la misma clase de complejidad contra modelos explícitos medidos con el número de estados y agentes;Finalmente, la comprobación del modelo de información imperfecta resulta más fácil que verificar el modelo de información perfecta para sistemas interpretados modulares. ¿Por qué puede ser así? Primero, un MIS se desarrolla en CEG y CG de una manera diferente. En el primer caso, se supone que el MIS codifica las relaciones epistémicas explícitamente (lo que lo hace explotar cuando modelamos a los agentes con información perfecta o casi perfecta). En el último caso, la epistémica la sexta intl. Conf.En los agentes autónomos y los sistemas de múltiples agentes (AAMAS 07) se ignora el aspecto 903, lo que da un espacio adicional para codificar la relación de transición de manera más eficiente. Otro factor crucial es el número de estrategias disponibles (en relación con el tamaño de los parámetros de entrada). El número de todas las estrategias es exponencial en el número de estados globales;Para estrategias uniformes, generalmente hay mucho menos de ellas, pero aún así exponencialmente muchas en general. Por lo tanto, el hecho de que las estrategias de información perfectas se puedan sintetizar de manera incremental tiene un impacto sustancial en la complejidad del problema. Sin embargo, medido en términos de estados y agentes locales, el número de todas las estrategias es doblemente exponencial, mientras que solo hay exponencialmente muchas estrategias uniformes, lo que resuelve los resultados a favor de la información imperfecta.5. Conclusiones Hemos presentado una nueva clase de representaciones para sistemas multiagentes abiertos. Nuestras representaciones, llamadas sistemas interpretados modulares, son: modulares, en el sentido de que los componentes se pueden cambiar, reemplazar, eliminar o agregar, con la menor cantidad de cambios posible a toda la representación;más compactos que las representaciones explícitas tradicionales;y fundamentados, en el sentido de que las correspondencias entre las primitivas del modelo y las entidades que se modelan son más inmediatas, dando una metodología para diseñar e implementar sistemas. También conjeturamos que la complejidad de la capacidad estratégica de verificación de modelos para nuestras representaciones es mayor si asumimos información perfecta que si asumimos información imperfecta. Las soluciones, propuestas en este documento, no son necesariamente perfectas (por ejemplo, las funciones de impresión que no son la principal fuente de no modularidad en mis, y tal vez se pueden mejorar), pero creemos que son un paso en el paso en eldirección correcta. Tampoco queremos afirmar que nuestras representaciones deberían reemplazar lenguajes de modelado más elaborados como Promela o módulos reactivos. Solo sugerimos que existe la necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más fácil que los módulos reactivos. También sugerimos que MIS podría ser más adecuado para modelar dominios simples de múltiples agentes, especialmente para el diseño orientado a humanos (en oposición al diseño orientado a la computadora).6. Agradecimientos Agradecemos a los revisores anónimos y Andrzej Tarlecki por sus útiles comentarios. Thomas Ågotnes El trabajo en este documento fue apoyado por las subvenciones 166525/V30 y 176853/S10 del Consejo de Investigación de Noruega.7. Referencias [1] R. Alur y T. A. Henzinger. Módulos reactivos. Métodos formales en el diseño del sistema, 15 (1): 7-48, 1999. [2] R. Alur, T. A. Henzinger y O. Kupferman. Lógica temporal de tiempo alterno. Notas de conferencia en informática, 1536: 23-60, 1998. [3] R. Alur, T. A. Henzinger y O. Kupferman. Lógica temporal de tiempo alterno. Journal of the ACM, 49: 672-713, 2002. [4] R. Alur, T.A. Henzinger, F.Y.C. Mang, S. Qadeer, S.K. Rajamani y S. Tasiran. Manual de usuario de Mocha. En Proceedings of Cav98, Volumen 1427 de las notas de conferencias en informática, páginas 521-525, 1998. [5] E.M. Clarke, E.A. Emerson y A.P. Sistla. Verificación automática de sistemas concurrentes de estado finito utilizando especificaciones lógicas temporales. Transacciones ACM en lenguajes y sistemas de programación, 8 (2): 244-263, 1986. [6] E.A. Emerson y J.Y. Halpern.A veces y nunca revisado: en ramificación versus lógica temporal de tiempo lineal. En Actas del Simposio ACM anual sobre los principios de los lenguajes de programación, páginas 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses y M. Y. Vardi. Razonamiento sobre el conocimiento. MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari y M. de Rijke. Verificación de modelos para lógicas combinadas. En Actas de la 3ª Conferencia Internacional sobre Lógica Temporal (ICTL), 2000. [9] V. Goranko y W. Jamroga. Comparación de la semántica de la lógica para sistemas de múltiples agentes. Synthese, 139 (2): 241-280, 2004. [10] J. Y. Halpern. Razonamiento sobre el conocimiento: una encuesta. En D. M. Gabbay, C. J. Hogger y J. A. Robinson, editores, El Manual de Lógica en Inteligencia Artificial y Programación Lógica, Volumen IV, páginas 1-34. Oxford University Press, 1995. [11] J.Y. Halpern y R. Fagin. Modelado de conocimiento y acción en sistemas distribuidos. Computación distribuida, 3 (4): 159-177, 1989. [12] W. Jamroga y J. Dix. ¿Los agentes hacen que la verificación del modelo explote (computacionalmente)? En M. P˘Echou˘cek, P. Petta y L.Z. Varga, editores, Actas de CEEMAS 2005, volumen 3690 de las notas de conferencias en informática, páginas 398-407. Springer Verlag, 2005. [13] W. Jamroga y J. Dix. Modelo de comprobación de agentes: un aspecto más cercano. Presentado, 2006. [14] W. Jamroga y T. Ågotnes. Sistemas interpretados modulares: un informe preliminar. Informe técnico IFI-06-15, Universidad Tecnológica de Clausthal, 2006. [15] O. Kupferman, M.Y. Vardi y P. Wolper. Un enfoque teórico de autómata para la verificación del modelo de tiempo de ramificación. Journal of the ACM, 47 (2): 312-360, 2000. [16] F. Laroussinie, N. Markey y G. Oreiby. Expresividad y complejidad de ATL. Informe técnico LSV-06-03, CNRS & Ens Cachan, Francia, 2006. [17] K.L. McMillan. Verificación del modelo simbólico: un enfoque para el problema de explosión del estado. Kluwer Academic Publishers, 1993. [18] K.L. McMillan. Aplicando métodos SAT en la verificación simbólica ilimitada del modelo. En Actas de Cav02, volumen 2404 de las notas de la conferencia en informática, páginas 250-264, 2002. [19] W. Penczek y A. Lomuscio. Verificación de propiedades epistémicas de sistemas de agentes múltiples a través de la verificación del modelo limitado. En Actas de AAMAS03, páginas 209-216, Nueva York, NY, EE. UU., 2003. ACM Press.[20] F. Raimondi y A. Lomuscio. La complejidad del modelo simbólico que verifica lógicas temporal-epistémicas. En L. CZaja, editor, Actas de CS y P05, 2005. [21] P. Y. Schobbens. Lógica de tiempo alterno con retiro imperfecto. Notas electrónicas en informática teórica, 85 (2), 2004. [22] W. van der Hoek, A. Lomuscio y M. Wooldridge. Sobre la complejidad de la verificación práctica del modelo ATL. En P. Stone y G. Weiss, editores, Actas de AAMAS06, páginas 201-208, 2006. 904 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)",
    "original_sentences": [
        "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
        "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
        "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
        "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
        "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
        "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
        "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
        "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
        "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
        "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
        "The structure of the paper is as follows.",
        "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
        "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
        "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
        "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
        "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
        "Thus, we usually need representations that are more compact.",
        "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
        "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
        "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
        "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
        "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
        "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
        "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
        "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
        "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
        "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
        "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
        "A q-path is a path that starts in q.",
        "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
        "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
        "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
        "We assume that all ∼a are equivalences.",
        "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
        "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
        "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
        "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
        "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
        "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
        "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
        "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
        "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
        "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
        "DEFINITION 1.",
        "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
        "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
        "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
        "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
        "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
        "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
        "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
        "A collective strategy is uniform if it contains only uniform individual strategies.",
        "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
        "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
        "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
        "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
        "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
        "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
        "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
        "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
        "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
        "Boolean variables, n-ary attributes etc.).",
        "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
        "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
        "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
        "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
        "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
        "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
        "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
        "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
        "Unfortunately, ATL models are anything but open in this sense.",
        "Theoretical complexity results for explicit models are as follows.",
        "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
        "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
        "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
        "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
        "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
        "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
        "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
        "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
        "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
        "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
        "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
        "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
        "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
        "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
        "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
        "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
        "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
        "Here, we use the formulation from [15].",
        "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
        "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
        "Concurrent programs have several advantages.",
        "First of all, they are modular and compact.",
        "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
        "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
        "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
        "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
        "Side effects of actions are also not easy to model.",
        "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
        "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
        "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
        "Now, particular actions are no less important than the resulting transitions.",
        "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
        "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
        "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
        "Finally, we would often like to assume that agents act synchronously.",
        "In particular, all agents play simultaneously in concurrent game structures.",
        "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
        "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
        "The first postulate is easy to satisfy, as we show in the following section.",
        "The second will be addressed in Section 4.",
        "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
        "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
        "DEFINITION 2.",
        "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
        "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
        "DEFINITION 3.",
        "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
        "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
        "It is required that ctr1, . . . ctrk partitions Π.",
        "The idea is that agent i controls the variables ctri.",
        "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
        "A guarded command is enabled if the guard φ is true in the current state of the system.",
        "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
        "Several guarded commands being enabled at the same time model non-deterministic choice.",
        "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
        "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
        "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
        "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
        "Concurrent epistemic programs are modular and have a grounded semantics.",
        "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
        "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
        "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
        "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
        "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
        "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
        "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
        "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
        "We have already mentioned a very limited variant of RML (i.e., SRML).",
        "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
        "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
        "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
        "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
        "Agents can act synchronously as well as asynchronously.",
        "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
        "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
        "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
        "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
        "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
        "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
        "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
        "The proposed framework is presented in Section 4. 4.",
        "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
        "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
        "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
        "DEFINITION 4.",
        "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
        "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
        "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
        "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
        "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
        "The environment, on the other hand, represents the (passive) context of agents actions.",
        "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
        "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
        "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
        "DEFINITION 5.",
        "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
        "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
        "It is required that ϕn ≡ , so that the mapping is effective.",
        "REMARK 1.",
        "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
        "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
        "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
        "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
        "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
        "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
        "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
        "Note that MISs can be used as representations of CGSs too.",
        "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
        "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
        "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
        "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
        "PROPOSITION 3.",
        "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
        "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
        "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
        "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
        "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
        "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
        "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
        "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
        "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
        "We now argue that St = Q.",
        "Clearly, Q ⊆ St .",
        "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
        "The argument is on induction on the length of the least o path from Q to ˆq.",
        "The base case, ˆq ∈ Q, is immediate.",
        "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
        "Thus, St = Q.",
        "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
        "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
        "COROLLARY 4.",
        "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
        "PROPOSITION 5.",
        "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
        "Let M = Agt, St, Act, d, o, Π, π be given.",
        "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
        "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
        "Clearly, M is isomorphic to M. COROLLARY 6.",
        "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
        "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
        "PROPOSITION 7.",
        "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
        "PROOF.",
        "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
        "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
        "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
        "PROPOSITION 8.",
        "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
        "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
        "PROOF.",
        "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
        "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
        "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
        "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
        "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
        "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
        "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
        "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
        "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
        "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
        "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
        "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
        "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
        "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
        "First, we define our (quite strong) notion of equivalence of representations.",
        "DEFINITION 7.",
        "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
        "They are CGS-equivalent if they unfold to the same CGS.",
        "PROPOSITION 9.",
        "For any SRML there is a CGS-equivalent MIS.",
        "PROOF.",
        "Consider an SRML R with k modules and n variables.",
        "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
        "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
        "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
        "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
        "To define local transitions, we consider three cases.",
        "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
        "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
        "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
        "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
        "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
        "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
        "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
        "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
        "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
        "Following the reviewers remarks, we state our complexity results only as conjectures.",
        "Preliminary proofs can be found in [14].",
        "CONJECTURE 10.",
        "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
        "CONJECTURE 11.",
        "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
        "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
        "The table presents completeness results for various models and settings of input parameters.",
        "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
        "The new results, conjectured in this paper, are printed in italics.",
        "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
        "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
        "Why can it be so?",
        "First, a MIS unfolds into CEGS and CGS in a different way.",
        "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
        "In the latter case, the epistemic The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
        "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
        "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
        "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
        "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
        "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
        "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
        "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
        "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
        "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
        "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
        "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
        "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
        "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
        "REFERENCES [1] R. Alur and T. A. Henzinger.",
        "Reactive modules.",
        "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
        "Alternating-time Temporal Logic.",
        "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
        "Alternating-time Temporal Logic.",
        "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
        "Henzinger, F.Y.C.",
        "Mang, S. Qadeer, S.K.",
        "Rajamani, and S. Tasiran.",
        "MOCHA user manual.",
        "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
        "Emerson, and A.P.",
        "Sistla.",
        "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
        "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
        "Emerson and J.Y.",
        "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
        "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
        "Reasoning about Knowledge.",
        "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
        "Model checking for combined logics.",
        "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
        "Comparing semantics of logics for multi-agent systems.",
        "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
        "Reasoning about knowledge: a survey.",
        "In D. M. Gabbay, C. J. Hogger, and J.",
        "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
        "Oxford University Press, 1995. [11] J.Y.",
        "Halpern and R. Fagin.",
        "Modelling knowledge and action in distributed systems.",
        "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
        "Do agents make model checking explode (computationally)?",
        "In M. P˘echou˘cek, P. Petta, and L.Z.",
        "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
        "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
        "Model checking abilities of agents: A closer look.",
        "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
        "Modular interpreted systems: A preliminary report.",
        "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
        "Vardi, and P. Wolper.",
        "An automata-theoretic approach to branching-time model checking.",
        "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
        "Expressiveness and complexity of ATL.",
        "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
        "McMillan.",
        "Symbolic Model Checking: An Approach to the State Explosion Problem.",
        "Kluwer Academic Publishers, 1993. [18] K.L.",
        "McMillan.",
        "Applying SAT methods in unbounded symbolic model checking.",
        "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
        "Verifying epistemic properties of multi-agent systems via bounded model checking.",
        "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
        "ACM Press. [20] F. Raimondi and A. Lomuscio.",
        "The complexity of symbolic model checking temporal-epistemic logics.",
        "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
        "Alternating-time logic with imperfect recall.",
        "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
        "On the complexity of practical ATL model checking.",
        "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "error_count": 0,
    "keys": {
        "modular interpreted system": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A <br>modular interpreted system</br> (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a <br>modular interpreted system</br> S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a <br>modular interpreted system</br> S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a <br>modular interpreted system</br> with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a <br>modular interpreted system</br> S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or <br>modular interpreted system</br>.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un \"sistema modular interpretado\" (mis) se define como una tupla s = agt, env, actuar, en, donde agt = {a1, ..., ak} es un conjunto de agentes, env es el entorno, la actuación es unconjunto de acciones, y en un conjunto de símbolos llamados alfabeto de interacción.",
                "En tal caso, el problema es inherente al dominio, e INI tendrá un tamaño exponencial de WRT el número de agentes.4.1 Representar los sistemas de agentes con mis STG = (QK I = 1 STI) × StenV ser el conjunto de todos los estados globales posibles generados por un \"sistema modular interpretado\" S. Definición 6.",
                "Al construir un \"sistema interpretado modular\" s de tal manera que M = CEGS (S, Q), tenemos que la ITS debe ser isomórfica con St. 902 el sexto intl.",
                "Tenga en cuenta que M se puede representar como un \"sistema modular interpretado\" con espacios de estado locales sucintos STI = {qi 0, ..., qi i}.",
                "Llamaremos elementos a, outi, ini la capa de interacción de un \"sistema interpretado modular\" s;Los otros elementos de S constituyen la capa local del MIS.",
                "Los símbolos N, K, M representan el número de estados, agentes y transiciones en un modelo explícito;L es la longitud de la fórmula, y Nlocal es el número de estados locales en un programa concurrente o \"sistema modular interpretado\"."
            ],
            "translated_text": "",
            "candidates": [
                "sistema modular interpretado",
                "sistema modular interpretado",
                "Sistema modular interpretado",
                "sistema modular interpretado",
                "sistema modular interpretado",
                "sistema interpretado modular",
                "sistema modular interpretado",
                "sistema modular interpretado",
                "sistema modular interpretado",
                "sistema interpretado modular",
                "sistema modular interpretado",
                "sistema modular interpretado"
            ],
            "error": []
        },
        "open computational system": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of <br>open computational system</br>s (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about <br>open computational system</br>s.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una sola unidad, pero será importante cuando los agentes particulares y sus estrategias se destacen.2.3 Agentes y sus estrategias: la lógica temporal de tiempo alterno ATL ATL [3] es una lógica para razonar sobre las propiedades temporales y estratégicas de los \"sistemas computacionales abiertos\" (sistemas de múltiples agentes en particular).",
                "Los estados en un modelo se refieren a los estados globales del sistema;Las transiciones en el modelo también corresponden a transiciones globales, es decir, representan (de manera atómica) todo lo que puede suceder en un solo paso, independientemente de quién lo haya hecho, a quién y de qué manera.• Las lógicas como ATL a menudo se anuncian como marcos para el modelado y el razonamiento sobre el \"sistema computacional abierto\"."
            ],
            "translated_text": "",
            "candidates": [
                "Abrir sistema computacional",
                "sistemas computacionales abiertos",
                "Abrir sistema computacional",
                "sistema computacional abierto"
            ],
            "error": []
        },
        "temporal and strategic logic": {
            "translated_key": "lógica temporal y estratégica",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking <br>temporal and strategic logic</br>s (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En la tabla se proporciona un resumen de los resultados de la complejidad para la verificación del modelo \"lógica temporal y estratégica\" (con y sin componente epistémico)."
            ],
            "translated_text": "",
            "candidates": [
                "lógica temporal y estratégica",
                "lógica temporal y estratégica"
            ],
            "error": []
        },
        "modeling methodology": {
            "translated_key": "metodología de modelado",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or <br>modeling methodology</br>. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Por lo tanto, no están más abiertos ni mejor fundamentados: estaban destinados a optimizar la implementación en lugar de facilitar el diseño o la \"metodología de modelado\".3.3 Sistemas interpretados Los sistemas interpretados [11, 7] están en poder de muchos como un excelente ejemplo de modelos de sistemas distribuidos computacionalmente fundamentados."
            ],
            "translated_text": "",
            "candidates": [
                "metodología de modelado",
                "metodología de modelado"
            ],
            "error": []
        },
        "model checking": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model checking</br>) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on <br>model checking</br> alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model checking</br> systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that <br>model checking</br> ability under imperfect information for MIS can be computationally cheaper than <br>model checking</br> perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND <br>model checking</br> In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model checking</br>.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "<br>model checking</br> CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "<br>model checking</br> ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "<br>model checking</br> ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible <br>model checking</br> properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that <br>model checking</br> CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "<br>model checking</br> ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "<br>model checking</br> CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in <br>model checking</br> complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 <br>model checking</br> Modular Interpreted Systems One of our main aims was to study the complexity of symbolic <br>model checking</br> ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "<br>model checking</br> ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "<br>model checking</br> ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for <br>model checking</br> temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for <br>model checking</br> ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare <br>model checking</br> agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, <br>model checking</br> imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of <br>model checking</br> strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "<br>model checking</br> for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make <br>model checking</br> explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "<br>model checking</br> abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time <br>model checking</br>.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic <br>model checking</br>: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic <br>model checking</br>.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded <br>model checking</br>.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic <br>model checking</br> temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL <br>model checking</br>.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Sistemas interpretados modulares Wojciech Jamroga Departamento de Informática de la Universidad de Claustral, Alemania wjamroga@in.tu-Clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Bergen University College, Noruega Tag@hib.No Resumen, proponemos una nueva clase de representaciones que pueden ser que pueden serUtilizado para modelar (y \"verificación de modelos\") propiedades temporales, estratégicas y epistémicas de los agentes y sus equipos.",
                "También mencionamos los resultados preliminares sobre la lógica temporal de \"verificación de modelos\" para esta clase natural de modelos.",
                "En la Sección 3, presentamos una visión general de las representaciones que se han utilizado para modelar y \"verificación de modelos\" los sistemas en los que el tiempo, la acción (y posiblemente conocimiento) son importantes;Mencionamos representaciones especialmente utilizadas para el análisis teórico.",
                "Concluimos con una hipótesis algo sorprendente, que la capacidad de \"verificación de modelos\" bajo información imperfecta para MIS puede ser computacionalmente más barata que la información perfecta de \"verificación de modelos\".",
                "Modelos y \"verificación de modelos\" En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden usarse para modelar y \"verificación de modelos\".",
                "La \"comprobación del modelo\" CTL y CTLK son P-completas, y se puede hacer en el tiempo O (ml), donde M es el número de transiciones en el modelo, y L es la longitud de la fórmula [5].",
                "El ATL de \"verificación de modelos\" es WRT-COMPLETO P.M, L y ΔP 3 -complicado WRT.N, K, L (K es el número de agentes) [3, 12, 16].",
                "El Atlir \"verificación del modelo\" es ΔP 2 complete WRT.M, L y ΔP 3 -complicado WRT.N, K, L [21, 13].3.2 Representaciones comprimidas La representación explícita de todos los estados y transiciones es ineficiente de muchas maneras.",
                "Dichos modelos ofrecen alguna esperanza para las propiedades factibles de \"verificación de modelos\" de los sistemas abiertos/de múltiples agentes, aunque es bien sabido que son compactos solo en una fracción de todos los casos.4 Para nosotros, sin embargo, son insuficientes por otra razón:Son simplemente representaciones optimizadas de modelos explícitos.",
                "Observamos que \"verificación de modelos\" CTL contra programas concurrentes es completado con PSPACE en el número de estados locales y la longitud de la fórmula [15].3.5 CP sincrónico y módulos reactivos simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones que actualmente ejecutan los otros jugadores."
            ],
            "translated_text": "",
            "candidates": [
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "comprobación del modelo",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación del modelo",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos"
            ],
            "error": []
        },
        "multi-agent system": {
            "translated_key": "sistema de múltiples agentes",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a <br>multi-agent system</br> the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a <br>multi-agent system</br> as reading and/or writing from/to program variables.",
                "This view of a <br>multi-agent system</br> is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En el caso de un \"sistema de múltiples agentes\", la 3 otra clase de modelos ATL, los sistemas de transición alternativos [2] representan transiciones de una manera más sucinta.",
                "En segundo lugar, no siempre es conveniente representar todo lo que está sucediendo en un \"sistema de múltiples agentes\" como lectura y/o escritura de/para programar variables.",
                "Esta visión de un \"sistema de múltiples agentes\" está posiblemente cerca de la implementación de su computadora, pero generalmente bastante distante del dominio del mundo real, por lo tanto, la necesidad de un marco más abstracto y más flexible conceptualmente flexible."
            ],
            "translated_text": "",
            "candidates": [
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes"
            ],
            "error": []
        },
        "higher level representation language": {
            "translated_key": "lenguaje de representación de nivel superior",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on <br>higher level representation language</br>s for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Últimamente, una cantidad cada vez mayor de investigación se ha centrado en el \"lenguaje de representación de nivel superior\" para modelos de tales lógicas, motivados principalmente por la necesidad de representaciones compactas y para representaciones que se corresponden más estrechamente a los sistemas reales que se modelan."
            ],
            "translated_text": "",
            "candidates": [
                "lenguaje de representación de nivel superior",
                "lenguaje de representación de nivel superior"
            ],
            "error": []
        },
        "branching time": {
            "translated_key": "tiempo de ramificación",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine <br>branching time</br>, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 <br>branching time</br>: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Más precisamente: lógicas modales que combinan \"tiempo de ramificación\", conocimiento y estrategias bajo información incompleta.",
                "La lógica del tiempo, el conocimiento y la capacidad estratégica primero, presentamos las lógicas CTL, CTLK, ATL y ATLIR que son el punto de partida de nuestro estudio.2.1 \"Tiempo de ramificación\": CTL Computation Tree Logic CTL [6] Incluye operadores de propiedades temporales de los sistemas: es decir, el cuantificador de ruta E (hay una ruta), junto con operadores temporales: F (en el siguiente estado), 2 (siempreDe ahora en adelante) y U (hasta)."
            ],
            "translated_text": "",
            "candidates": [
                "tiempo de ramificación",
                "tiempo de ramificación",
                "tiempo de ramificación",
                "Tiempo de ramificación"
            ],
            "error": []
        },
        "computation tree logic ctl": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with <br>computation tree logic ctl</br>, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL <br>computation tree logic ctl</br> [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Comenzamos con \"Computation Tree Logic CTL\", luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de lógica temporal de tiempo alterno (ATL): una para el perfecto y otro para el caso de información imperfecta.",
                "La lógica del tiempo, el conocimiento y la capacidad estratégica primero, presentamos las lógicas CTL, CTLK, ATL y ATLIR que son el punto de partida de nuestro estudio.2.1 Tiempo de ramificación: CTL \"Lógica del árbol de cálculo CTL\" [6] incluye operadores de propiedades temporales de los sistemas: es decir, cuantificador de ruta e (hay una ruta), junto con operadores temporales: F (en el siguiente estado), 2 (siempreDe ahora en adelante) y U (hasta)."
            ],
            "translated_text": "",
            "candidates": [
                "Lógica de árbol de cálculo CTL",
                "Computation Tree Logic CTL",
                "Lógica de árbol de cálculo CTL",
                "Lógica del árbol de cálculo CTL"
            ],
            "error": []
        },
        "alternating-time temporal logic": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking <br>alternating-time temporal logic</br> for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of <br>alternating-time temporal logic</br> (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL <br>alternating-time temporal logic</br> ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "<br>alternating-time temporal logic</br>.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "<br>alternating-time temporal logic</br>.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "También mencionamos resultados preliminares sobre la verificación del modelo \"lógica temporal en tiempo alterno\" para esta clase natural de modelos.",
                "Comenzamos con la lógica del árbol de cálculo CTL, luego agregamos conocimiento (CTLK), y luego discutimos dos variantes de \"lógica temporal de tiempo alterno\" (ATL): una para el perfecto y otro para el caso de información imperfecta.",
                "Esto no tiene influencia en la forma en que modelamos la evolución de un sistema como una sola unidad, pero será importante cuando los agentes particulares y sus estrategias se destacen.2.3 Agentes y sus estrategias: la lógica temporal de \"tiempo alterna\" ATL [3] es una lógica para razonar sobre las propiedades temporales y estratégicas de los sistemas computacionales abiertos (sistemas de agentes múltiples en particular).",
                "\"Lógica temporal de tiempo alterno\".",
                "\"Lógica temporal de tiempo alterno\"."
            ],
            "translated_text": "",
            "candidates": [
                "lógica temporal de tiempo alterno",
                "lógica temporal en tiempo alterno",
                "lógica temporal de tiempo alterno",
                "lógica temporal de tiempo alterno",
                "lógica temporal de tiempo alterno",
                "tiempo alterna",
                "lógica temporal de tiempo alterno",
                "Lógica temporal de tiempo alterno",
                "lógica temporal de tiempo alterno",
                "Lógica temporal de tiempo alterno"
            ],
            "error": []
        },
        "kripke structure": {
            "translated_key": "Estructura de Kripke",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "synchronous concurrent program": {
            "translated_key": "programa concurrente sincrónico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A <br>synchronous concurrent program</br> consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un \"programa concurrente sincrónico\" consiste en k procesos concurrentes PI = STI, ACTI, RI, πi, πi con el siguiente 5 El concepto no es nuevo, por supuesto, y ya ha existido en el conocimiento popular, aunque no logramos encontrar una definición explícitaen la literatura.Inglocando a un CGS: Agt = {1, ..., k}, st = qk i = 1 sti, act = sk i = 1 acti, d (i, q1, ..., qk) = {αi |qi, αi, qi ∈ Ri para algunos qi ∈ STI}, o (Q1, ..., QK, α1, ..., αk) = Q1, ..., QK tal que Qi, αi, qi ∈ Ri paracada yo;Π = sk i = 1 πi, y π (p) = πi (p) para p ∈ πi."
            ],
            "translated_text": "",
            "candidates": [
                "programa concurrente sincrónico",
                "programa concurrente sincrónico"
            ],
            "error": []
        },
        "reactive module": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple <br>reactive module</br>s (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, <br>reactive module</br>s support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple <br>reactive module</br>s are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, <br>reactive module</br>s (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or <br>reactive module</br>s.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than <br>reactive module</br>s.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Observamos que el simple \"módulo reactivo\" s (SRML) de [22] puede verse como una implementación particular de programas concurrentes sincrónicos.",
                "Además, el \"módulo reactivo\" S admite información incompleta (a través de la observabilidad de las variables), aunque no es el foco principal de RML.",
                "Módulos reactivos simples en esta sección mostramos que los \"módulos reactivos\" simples son (como ya sugerimos) una implementación específica (y algo limitada) de sistemas interpretados modulares.",
                "En cierto modo, el \"módulo reactivo\" (tanto simple como lleno) son representaciones de dos niveles: primero, el sistema se representa como un producto de módulos;A continuación, cada módulo puede verse como un producto de sus variables (junto con sus operaciones de actualización).",
                "Tampoco queremos afirmar que nuestras representaciones deberían reemplazar lenguajes de modelado más elaborados como Promela o \"Módulo reactivo\".",
                "Solo sugerimos que existe la necesidad de modelos compactos, modulares y razonablemente fundamentados que sean más expresivos que los programas concurrentes (epistémicos), y que aún permitan un análisis teórico más fácil que el \"módulo reactivo\"."
            ],
            "translated_text": "",
            "candidates": [
                "módulo reactivo",
                "módulo reactivo",
                "módulo reactivo",
                "módulo reactivo",
                "módulo reactivo",
                "módulos reactivos",
                "módulo reactivo",
                "módulo reactivo",
                "módulo reactivo",
                "Módulo reactivo",
                "módulo reactivo",
                "módulo reactivo"
            ],
            "error": []
        },
        "model methodology": {
            "translated_key": "metodología modelo",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and model checking) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on model checking alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and model checking systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that model checking ability under imperfect information for MIS can be computationally cheaper than model checking perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and model checking.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible model checking properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that model checking CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA model checker [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in model checking complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic model checking ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for model checking temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for model checking ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare model checking agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, model checking imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of model checking strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make model checking explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time model checking.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic model checking.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded model checking.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic model checking temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL model checking.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "model check": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Modular Interpreted Systems Wojciech Jamroga Department of Informatics Clausthal University of Technology, Germany wjamroga@in.tu-clausthal.de Thomas Ågotnes Department of Computer Engineering Bergen University College, Norway tag@hib.no ABSTRACT We propose a new class of representations that can be used for modeling (and <br>model check</br>ing) temporal, strategic and epistemic properties of agents and their teams.",
                "Our representations borrow the main ideas from interpreted systems of Halpern, Fagin et al. ; however, they are also modular and compact in the way concurrent programs are.",
                "We also mention preliminary results on <br>model check</br>ing alternating-time temporal logic for this natural class of models.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial IntelligenceMultiagent Systems; I.2.4 [Artificial Intelligence]: Knowledge Representation Formalisms and Methods-Modal logic General Terms Theory 1.",
                "INTRODUCTION The logical foundations of multi-agent systems have received much attention in recent years.",
                "Logic has been used to represent and reason about, e.g., knowledge [7], time [6], cooperation and strategic ability [3].",
                "Lately, an increasing amount of research has focused on higher level representation languages for models of such logics, motivated mainly by the need for compact representations, and for representations that correspond more closely to the actual systems which are modeled.",
                "Multi-agent systems are open systems, in the sense that agents interact with an environment only partially known in advance.",
                "Thus, we need representations of models of multi-agent systems which are modular, in the sense that a component, such as an agent, can be replaced, removed, or added, without major changes to the representation of the whole model.",
                "However, as we argue in this paper, few existing representation languages are both modular, compact and computationally grounded on the one hand, and allow for representing properties of both knowledge and strategic ability, on the other.",
                "In this paper we present a new class of representations for models of open multi-agent systems, which are modular, compact and come with an implicit methodology for modeling and designing actual systems.",
                "The structure of the paper is as follows.",
                "First, in Section 2, we present the background of our work - that is, logics that combine time, knowledge, and strategies.",
                "More precisely: modal logics that combine branching time, knowledge, and strategies under incomplete information.",
                "We start with computation tree logic CTL, then we add knowledge (CTLK), and then we discuss two variants of alternating-time temporal logic (ATL): one for the perfect, and one for the imperfect information case.",
                "The semantics of logics like the ones presented in Section 2 are usually defined over explicit models (Kripke structures) that enumerate all possible (global) states of the system.",
                "However, enumerating these states is one of the things one mostly wants to avoid, because there are too many of them even for simple systems.",
                "Thus, we usually need representations that are more compact.",
                "Another reason for using a more specialized class of models is that general Kripke structures do not always give enough help in terms of methodology, both at the stage of design, nor at implementation.",
                "This calls for a semantics which is more grounded, in the sense that the correspondence between elements of the model, and the entities that are modeled, is more immediate.",
                "In Section 3, we present an overview of representations that have been used for modeling and <br>model check</br>ing systems in which time, action (and possibly knowledge) are important; we mention especially representations used for theoretical analysis.",
                "We point out that the compact and/or grounded representations of temporal models do not play their role in a satisfactory way when agents strategies are considered.",
                "Finally, in Section 4, we present our framework of modular interpreted systems (MIS), and show where it fits in the picture.",
                "We conclude with a somewhat surprising hypothesis, that <br>model check</br>ing ability under imperfect information for MIS can be computationally cheaper than <br>model check</br>ing perfect information.",
                "Until now, almost all complexity results were distinctly in favor of perfect information strategies (and the others were indifferent). 2.",
                "LOGICS OF TIME, KNOWLEDGE, AND STRATEGIC ABILITY First, we present the logics CTL, CTLK, ATL and ATLir that are the starting point of our study. 2.1 Branching Time: CTL Computation tree logic CTL [6] includes operators for temporal properties of systems: i.e., path quantifier E (there is a path), together with temporal operators: f(in the next state), 2 (always from now on) and U (until).1 Every occurrence of a temporal operator is immediately preceded by exactly one path quantifier (this variant of the language is sometimes called vanilla CTL).",
                "Let Π be a set of atomic propositions with a typical element p. CTL formulae ϕ are defined as follows: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | E fϕ | E2ϕ | Eϕ U ϕ.",
                "The semantics of CTL is based on Kripke models M = St, R, π , which include a nonempty set of states St, a state transition relation R ⊆ St × St, and a valuation of propositions π : Π → P(St).",
                "A path λ in M refers to a possible behavior (or computation) of system M, and can be represented as an infinite sequence of states q0q1q2... such that qiRqi+1 for every i = 0, 1, 2, .... We denote the ith state in λ by λ[i].",
                "A q-path is a path that starts in q.",
                "Interpretation of a formula in a state q in model M is defined as follows: M, q |= p iff q ∈ π(p); M, q |= ¬ϕ iff M, q |= ϕ; M, q |= ϕ ∧ ψ iff M, q |= ϕ and M, q |= ψ; M, q |= E fϕ iff there is a q-path λ such that M, λ[1] |= ϕ; M, q |= E2ϕ iff there is a q-path λ such that M, λ[i] |= ϕ for every i ≥ 0; M, q |= Eϕ U ψ iff there is a q-path λ and i ≥ 0 such that M, λ[i] |= ψ and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.2 Adding Knowledge: CTLK CTLK [19] is a straightforward combination of CTL and standard epistemic logic [10, 7].",
                "Let Agt = {1, ..., k} be a set of agents with a typical element a. Epistemic logic uses operators for representing agents knowledge: Kaϕ is read as agent a knows that ϕ.",
                "Models of CTLK extend models of CTL with epistemic indistinguishability relations ∼a⊆ St × St (one per agent).",
                "We assume that all ∼a are equivalences.",
                "The semantics of epistemic operators is defined as follows: M, q |= Kaϕ iff M, q |= ϕ for every q such that q ∼a q .",
                "Note that, when talking about agents knowledge, we implicitly assume that agents may have imperfect information about the actual current state of the world (otherwise the notion of knowledge would be trivial).",
                "This does not have influence on the way we model evolution of a system as a single unit, but it will become important when particular agents and their strategies come to the fore. 2.3 Agents and Their Strategies: ATL Alternating-time temporal logic ATL [3] is a logic for reasoning about temporal and strategic properties of open computational systems (multi-agent systems in particular).",
                "The language of ATL consists of the following formulae: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A fϕ | A 2ϕ | A ϕ U ϕ. where A ⊆ Agt.",
                "Informally, A ϕ says that agents A have a collective strategy to enforce ϕ.",
                "It should be noted that the CTL path quantifiers A, E can be expressed with ∅ , Agt respectively.",
                "The semantics of ATL is defined in so called concurrent game structures (CGSs).",
                "A CGS is a tuple M = Agt, St, Act, d, o, Π, π , 1 Additional operators A (for every path) and 3 (sometime in the future) are defined in the usual way. consisting of: a set Agt = {1, . . . , k} of agents; set St of states; valuation of propositions π : Π → P(St); set Act of atomic actions.",
                "Function d : Agt × St → P(Act) indicates the actions available to agent a ∈ Agt in state q ∈ St.",
                "Finally, o is a deterministic transition function which maps a state q ∈ St and an action profile α1, . . . , αk ∈ Actk , αi ∈ d(i, q), to another state q = o(q, α1, . . . , αk).",
                "DEFINITION 1.",
                "A (memoryless) strategy of agent a is a function sa : St → Act such that sa(q) ∈ d(a, q).2 A collective strategy SA for a team A ⊆ Agt specifies an individual strategy for each agent a ∈ A.",
                "Finally, the outcome of strategy SA in state q is defined as the set of all computations that may result from executing SA from q on: out(q, SA) = {λ = q0q1q2... | q0 = q and for every i = 1, 2, ... there exists αi−1 1 , ..., αi−1 k such that αi−1 a = SA(a)(qi−1) for each a ∈ A, αi−1 a ∈ d(a, qi−1) for each a /∈ A, and o(qi−1, αi−1 1 , ..., αi−1 k ) = qi}.",
                "The semantics of cooperation modalities is as follows: M, q |= A fϕ iff there is a collective strategy SA such that, for every λ ∈ out(q, SA), we have M, λ[1] |= ϕ; M, q |= A 2ϕ iff there exists SA such that, for every λ ∈ out(q, SA), we have M, λ[i] for every i ≥ 0; M, q |= A ϕ U ψ iff there exists SA such that for every λ ∈ out(q, SA) there is a i ≥ 0, for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i. 2.4 Agents with Imperfect Information: ATLir As ATL does not include incomplete information in its scope, it can be seen as a logic for reasoning about agents who always have complete knowledge about the current state of the whole system.",
                "ATLir [21] includes the same formulae as ATL, except that the cooperation modalities are presented with a subscript: A ir indicates that they address agents with imperfect information and imperfect recall.",
                "Formally, the recursive definition of ATLir formulae is: ϕ ::= p | ¬ϕ | ϕ ∧ ϕ | A ir fϕ | A ir2ϕ | A irϕ U ϕ Models of ATLir, concurrent epistemic game structures (CEGS), can be defined as tuples M = Agt, St, Act, d, o, ∼1, ..., ∼k, Π, π , where Agt, St, Act, d, o, Π, π is a CGS, and ∼1, ..., ∼k are epistemic (equivalence) relations.",
                "It is required that agents have the same choices in indistinguishable states: q ∼a q implies d(a, q) = d(a, q ).",
                "ATLir restricts the strategies that can be used by agents to uniform strategies, i.e. functions sa : St → Act, such that: (1) sa(q) ∈ d(a, q), and (2) if q ∼a q then sa(q) = sa(q ).",
                "A collective strategy is uniform if it contains only uniform individual strategies.",
                "Again, the function out(q, SA) returns the set of all paths that may result from agents A executing collective strategy SA from state q.",
                "The semantics of ATLir formulae can be defined as follows: M, q |= A ir fϕ iff there is a uniform collective strategy SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[1] |= ϕ; 2 This is a deviation from the original semantics of ATL [3], where strategies assign agents choices to sequences of states, which suggests that agents can by definition recall the whole history of each game.",
                "While the choice of one or another notion of strategy affects the semantics of the full ATL ∗ , and most ATL extensions (e.g. for games with imperfect information), it should be pointed out that both types of strategies yield equivalent semantics for pure ATL (cf. [21]). 898 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) M, q |= A ir2ϕ iff there exists SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), we have M, λ[i] for every i ≥ 0; M, q |= A irϕ U ψ iff there exist SA such that, for every a ∈ A, q such that q ∼a q , and λ ∈ out(SA, q ), there is i ≥ 0 for which M, λ[i] |= ψ, and M, λ[j] |= ϕ for every 0 ≤ j < i.",
                "That is, A irϕ holds iff A have a uniform collective strategy, such that for every path that can possibly result from execution of the strategy according to at least one agent from A, ϕ is the case. 3.",
                "MODELS AND MODEL CHECKING In this section, we present and discuss various (existing) representations of systems that can be used for modeling and <br>model check</br>ing.",
                "We believe that the two most important points of reference are in this case: (1) the modeling formalism (i.e., the logic and the semantics we use), and (2) the phenomenon, or more generally, the domain we are going to model (to which we will often refer as the real world).",
                "Our aim is a representation which is reasonably close to the real world (i.e., it is sufficiently compact and grounded), and still not too far away from the formalism (so that it e.g. easily allows for theoretical analysis of computational problems).",
                "We begin with discussing the merits of explicit modelsin our case, these are transition systems, concurrent game structures and CEGSs, presented in the previous section. 3.1 Explicit Models Obviously, an advantage of explicit models is that they are very close to the semantics of our logics (simply because they are the semantics).",
                "On the other hand, they are in many ways difficult to use to describe an actual system: • Exponential size: temporal models usually have an exponential number of states with respect to any higher-level description (e.g.",
                "Boolean variables, n-ary attributes etc.).",
                "Also, their size is exponential in the number of processes (or agents) if the evolution of a system results from joint (synchronous or asynchronous) actions of several active entities [15].",
                "For CGSs the situation is even worse: here, also the number of transitions is exponential, even if we fix the number of states.3 In practice, this means that such representations are very seldom scalable. • Explicit models include no modularity.",
                "States in a model refer to global states of the system; transitions in the model correspond to global transitions as well, i.e., they represent (in an atomic way) everything that may happen in one single step, regardless of who has done it, to whom, and in what way. • Logics like ATL are often advertised as frameworks for modeling and reasoning about open computational systems.",
                "Ideally, one would like the elements of such a system to have as little interdependencies as possible, so that they can be plugged in and out without much hassle, for instance when we want to test various designs or implementations of the active component.",
                "In the case of a multi-agent system the 3 Another class of ATL models, alternating transition systems [2] represent transitions in a more succinct way.",
                "While we still have exponentially many states in an ATS, the number of transitions is simply quadratic wrt. to states (like for CTL models).",
                "Unfortunately, ATS are even less modular and harder to design than concurrent game structures, and they cannot be easily extended to handle incomplete information (cf. [9]). need is perhaps even more obvious.",
                "We do not only need to re-plug various designs of a single agent in the overall architecture; we usually also need to change (e.g., increase) the number of agents acting in a given environment without necessarily changing the design of the whole system.",
                "Unfortunately, ATL models are anything but open in this sense.",
                "Theoretical complexity results for explicit models are as follows.",
                "Model checking CTL and CTLK is P-complete, and can be done in time O(ml), where m is the number of transitions in the model, and l is the length of the formula [5].",
                "Alternatively, it can be done in time O(n2 l), where n is the number of states.",
                "Model checking ATL is P-complete wrt. m, l and ΔP 3 -complete wrt. n, k, l (k being the number of agents) [3, 12, 16].",
                "Model checking ATLir is ΔP 2complete wrt. m, l and ΔP 3 -complete wrt. n, k, l [21, 13]. 3.2 Compressed Representations Explicit representation of all states and transitions is inefficient in many ways.",
                "An alternative is to represent the state/transition space in a symbolic way [17, 18].",
                "Such models offer some hope for feasible <br>model check</br>ing properties of open/multi-agent systems, although it is well known that they are compact only in a fraction of all cases.4 For us, however, they are insufficient for another reason: they are merely optimized representations of explicit models.",
                "Thus, they are neither more open nor better grounded: they were meant to optimize implementation rather than facilitate design or modeling methodology. 3.3 Interpreted Systems Interpreted systems [11, 7] are held by many as a prime example of computationally grounded models of distributed systems.",
                "An interpreted system can be defined as a tuple IS = St1, ..., Stk, Stenv, R, π .",
                "St1, ..., Stk are local state spaces of agents 1, ..., k, and Stenv is the set of states of the environment.",
                "The set of global states is defined as St = St1 × ... × Stk × Stenv; R ⊆ St × St is a transition relation, and π : Π → P(St).",
                "While the transition relation encapsulates the (possible) evolution of the system over time, the epistemic dimension is defined by the local components of each global state: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .",
                "It is easy to see that such a representation is modular and compact as far as we are concerned with states.",
                "Moreover, it gives a natural (grounded) approach to knowledge, and suggests an intuitive methodology for modeling epistemic states.",
                "Unfortunately, the way transitions are represented in interpreted systems is neither compact, nor modular, nor grounded: the temporal aspect of the system is given by a joint transition function, exactly like in explicit models.",
                "This is not without a reason: if we separate activities of the agents too much, we cannot model interaction in the framework any more, and interaction is the most interesting thing here.",
                "But the bottom line is that the temporal dimension of an interpreted system has exponential representation.",
                "And it is almost as difficult to plug components in and out of an interpreted system, as for an ordinary CTL or ATL model, since the local activity of an agent is completely merged with his interaction with the rest of the system. 3.4 Concurrent Programs The idea of concurrent programs has been long known in the literature on distributed systems.",
                "Here, we use the formulation from [15].",
                "A concurrent program P is composed of k concurrent processes, each described by a labeled transition system Pi = Sti, Acti, Ri, Πi, πi , where Sti is the set of local states of process 4 Representation R of an explicit model M is compact if the size of R is logarithmic with respect to the size of M. The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 899 i, Acti is the set of local actions, Ri ⊆ Sti ×Acti ×Sti is a transition relation, and Πi, πi are the set of local propositions and their valuation.",
                "The behavior of program P is given by the product automaton of P1, ..., Pk under the assumption that processes work asynchronously, actions are interleaved, and synchronization is obtained through common action names.",
                "Concurrent programs have several advantages.",
                "First of all, they are modular and compact.",
                "They allow for local modeling of components - much more so than interpreted systems (not only states, but also actions are local here).",
                "Moreover, they allow for representing explicit interaction between local transitions of reactive processes, like willful communication, and synchronization.",
                "On the other hand, they do not allow for representing implicit, incidental, or not entirely benevolent interaction between processes.",
                "For example, if we want to represent the act of pushing somebody, the pushed object must explicitly execute an action of being pushed, which seems somewhat ridiculous.",
                "Side effects of actions are also not easy to model.",
                "Still, this is a minor complaint in the context of CTL, because for temporal logics we are only interested in the flow of transitions, and not in the underlying actions.",
                "For temporal reasoning about k asynchronous processes with no implicit interaction, concurrent programs seem just about perfect.",
                "The situation is different when we talk about autonomous, proactive components (like agents), acting together (cooperatively or adversely) in a common environment - and we want to address their strategies and abilities.",
                "Now, particular actions are no less important than the resulting transitions.",
                "Actions may influence other agents local states without their consent, they may have side effects on other agents states etc.",
                "Passing messages and/or calling procedures is by no means the only way of interaction between agents.",
                "Moreover, the availability of actions (to an agent) should not depend on the actions that will be executed by other agents at the same time - these are the outcome states that may depend on these actions!",
                "Finally, we would often like to assume that agents act synchronously.",
                "In particular, all agents play simultaneously in concurrent game structures.",
                "But, assuming synchrony and autonomy of actions, synchronization can no longer be a means of coordination.",
                "To sum up, we need a representation which is very much like concurrent programs, but allows for modeling agents that play synchronously, and which enables modeling more sophisticated interaction between agents actions.",
                "The first postulate is easy to satisfy, as we show in the following section.",
                "The second will be addressed in Section 4.",
                "We note that <br>model check</br>ing CTL against concurrent programs is PSPACE-complete in the number of local states and the length of the formula [15]. 3.5 Synchronous CP and Simple Reactive Modules The semantics of ATL is based on synchronous models where availability of actions does not depend on the actions currently executed by the other players.",
                "A slightly different variant of concurrent programs can be defined via synchronous product of programs, so that all agents play simultaneously.5 Unfortunately, under such interpretation, no direct interaction between agents actions can be modeled at all.",
                "DEFINITION 2.",
                "A synchronous concurrent program consists of k concurrent processes Pi = Sti, Acti, Ri, Πi, πi with the follow5 The concept is not new, of course, and has already existed in folk knowledge, although we failed to find an explicit definition in the literature. ing unfolding to a CGS: Agt = {1, ..., k}, St = Qk i=1 Sti, Act = Sk i=1 Acti, d(i, q1, ..., qk ) = {αi | qi, αi, qi ∈ Ri for some qi ∈ Sti}, o( q1, ..., qk , α1, ..., αk) = q1, ..., qk such that qi, αi, qi ∈ Ri for every i; Π = Sk i=1 Πi, and π(p) = πi(p) for p ∈ Πi.",
                "We note that the simple reactive modules (SRML) from [22] can be seen as a particular implementation of synchronous concurrent programs.",
                "DEFINITION 3.",
                "A SRML system is a tuple Σ, Π, m1, . . . , mk , where Σ = {1, . . . , k} is a set of modules (or agents), Π is a set of Boolean variables, and, for each i ∈ Σ, we have mi = ctri, initi, updatei , where ctri ⊆ Π.",
                "Sets initi and updatei consist of guarded commands of the form φ ; v1 := ψ1; . . . ; vk := ψk, where every vj ∈ ctri, and φ, ψ1, . . . , ψk are propositional formulae over Π.",
                "It is required that ctr1, . . . ctrk partitions Π.",
                "The idea is that agent i controls the variables ctri.",
                "The init guarded commands are used to initialize the controlled variables, while the update guarded commands can change their values in each round.",
                "A guarded command is enabled if the guard φ is true in the current state of the system.",
                "In each round an enabled update guarded command is executed: each ψj is evaluated against the current state of the system, and its logical value is assigned to vj.",
                "Several guarded commands being enabled at the same time model non-deterministic choice.",
                "Model checking ATL for SRML has been proved EXPTIMEcomplete in the size of the model and the length of the formula [22]. 3.6 Concurrent Epistemic Programs Concurrent programs (both asynchronous and synchronous) can be used to encode epistemic relations too - exactly in the same way as interpreted systems do [20].",
                "That is, when unfolding a concurrent program to a model of CTLK or ATLir, we define that q1, ..., qk ∼i q1, ..., qk iff qi = qi .",
                "Model checking CTLK against concurrent epistemic programs is PSPACE-complete [20].",
                "SRML can be also interpreted in the same way; then, we would assume that every agent can see only the variables he controls.",
                "Concurrent epistemic programs are modular and have a grounded semantics.",
                "They are usually compact (albeit not always: for example, an agent with perfect information will always blow up the size of such a program).",
                "Still, they inherit all the problems of concurrent programs with perfect information, discussed in Section 3.4: limited interaction between components, availability of local actions depending on the actual transition etc.",
                "The problems were already important for agents with perfect information, but they become even more crucial when agents have only limited knowledge of the current situation.",
                "One of the most important applications of logics that combine strategic and epistemic properties is verification of communication protocols (e.g., in the context of security).",
                "Now, we may want to, e.g., check agents ability to pass an information between them, without letting anybody else intercept the message.",
                "The point is that the action of intercepting is by definition enabled; we just look for a protocol in which the transition of successful interception is never carried out.",
                "So, availability of actions must be independent of the actions chosen by the other agents under incomplete information.",
                "On the other hand, interaction is arguably the most interesting feature of multi-agent systems, and it is really hard to imagine models of strategic-epistemic logics, in which it is not possible to represent communication. 3.7 Reactive Modules Reactive modules [1] can be seen as a refinement of concurrent epistemic programs (primarily used by the MOCHA <br>model check</br>er [4]), but they are much more powerful, expressive and 900 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) grounded.",
                "We have already mentioned a very limited variant of RML (i.e., SRML).",
                "The vocabulary of RML is very close to implementations (in terms of general computational systems): the modules are essentially collections of variables, states are just valuations of variables; events/actions are variable updates.",
                "However, the sets of variables controlled by different agents can overlap, they can change over time etc.",
                "Moreover, reactive modules support incomplete information (through observability of variables), although it is not the main focus of RML.",
                "Again, the relationship between sets of observable variables (and to sets of controlled variables) is mostly left up to the designer of a system.",
                "Agents can act synchronously as well as asynchronously.",
                "To sum up, RML define a powerful framework for modeling distributed systems with various kinds of synchrony and asynchrony.",
                "However, we believe that there is still a need for a simpler and slightly more abstract class of representations.",
                "First, the framework of RML is technically complicated, involving a number auxiliary concepts and their definitions.",
                "Second, it is not always convenient to represent all that is going on in a multi-agent system as reading and/or writing from/to program variables.",
                "This view of a multi-agent system is arguably close to its computer implementation, but usually rather distant from the real world domainhence the need for a more abstract, and more conceptually flexible framework.",
                "Third, the separation of the local complexity, and the complexity of interaction is not straightforward.",
                "Our new proposal, more in the spirit of interpreted systems, takes these observations as the starting point.",
                "The proposed framework is presented in Section 4. 4.",
                "MODULAR INTERPRETED SYSTEMS The idea behind distributed systems (multi-agent systems even more so) is that we deal with several loosely coupled components, where most of the processing goes on inside components (i.e., locally), and only a small fraction of the processing occurs between the components.",
                "Interaction is crucial (which makes concurrent programs an insufficient modeling tool), but it usually consumes much less of the agents resources than local computations (which makes the explicit transition tables of CGS, CEGS, and interpreted systems an overkill).",
                "Modular interpreted systems, proposed here, extrapolate the modeling idea behind interpreted systems in a way that allows for a tight control of the interaction complexity.",
                "DEFINITION 4.",
                "A modular interpreted system (MIS) is defined as a tuple S = Agt, env, Act, In , where Agt = {a1, ..., ak} is a set of agents, env is the environment, Act is a set of actions, and In is a set of symbols called interaction alphabet.",
                "Each agent has the following internal structure: ai = Sti, di, outi, ini, oi, Πi, πi , where: • Sti is a set of local states, • di : Sti → P(Act) defines local availability of actions; for convenience of the notation, we additionally define the set of situated actions as Di = { qi, α | qi ∈ Sti, α ∈ di(qi)}, • outi, ini are interaction functions; outi : Di → In refers to the influence that a given situated action (of agent ai) may possibly have on the external world, and ini : Sti ×Ink → In translates external manifestations of the other agents (and the environment) into the impression that they make on ais transition function depending on the local state of ai, • oi : Di × In → Sti is a (deterministic) local transition function, • Πi is a set of local propositions of agent ai where we require that Πi and Πj are disjunct when i = j, and • πi : Πi → P(Sti) is a valuation of these propositions.",
                "The environment env = Stenv, outenv, inenv, oenv, Πenv, πenv has the same structure as an agent except that it does not perform actions, and that thus outenv : Stenv → In and oenv : Stenv × In → Stenv.",
                "Within our framework, we assume that every action is executed by an actor, that is, an agent.",
                "As a consequence, every actor is explicitly represented in a MIS as an agent, just like in the case of CGS and CEGS.",
                "The environment, on the other hand, represents the (passive) context of agents actions.",
                "In practice, it serves to capture the aspects of the global state that are not observable by any of the agents.",
                "The input functions ini seem to be the fragile spots here: when given explicitly as tables, they have size exponential wrt. the number of agents (and linear wrt. the size of In).",
                "However, we can use, e.g., a construction similar to the one from [16] to represent interaction functions more compactly.",
                "DEFINITION 5.",
                "Implicit input function for state q ∈ Sti is given by a sequence ϕ1, η1 , ..., ϕn, ηn , where each ηj ∈ In is an interaction symbol, and each ϕj is a boolean combination of propositions ˆηi , with η ∈ In; ˆηi stands for η is the symbol currently generated by agent i.",
                "The input function is now defined as follows: ini(q, 1, ..., k, env) = ηj iff j is the lowest index such that {ˆ1 1, ..., ˆk k, ˆenv env} |= ϕj.",
                "It is required that ϕn ≡ , so that the mapping is effective.",
                "REMARK 1.",
                "Every ini can be encoded as an implicit input function, with each ϕj being of polynomial size with respect to the number of interaction symbols (cf. [16]).",
                "Note that, for some domains, the MIS representation of a system requires exponentially many symbols in the interaction alphabet In.",
                "In such a case, the problem is inherent to the domain, and ini will have size exponential wrt the number of agents. 4.1 Representing Agent Systems with MIS Let Stg = ( Qk i=1 Sti)×Stenv be the set of all possible global states generated by a modular interpreted system S. DEFINITION 6.",
                "The unfolding of a MIS S for initial states Q ⊆ Stg to a CEGS cegs(S, Q) = Agt , St , Π , π , Act , d , o , ∼1, ..., ∼k is defined as follows: • Agt = {1, ..., k} and Act = Act, • St is the set of global states from Stg which are reachable from some state in Q via the transition relation defined by o (below), • Π = Sk i=1 Πi ∪ Πenv, • For each q = q1, . . . , qk, qenv ∈ St and i = 1, ..., k, env, we define q ∈ π (p) iff p ∈ Πi and qi ∈ πi(p), • d (i, q) = di(qi) for global state q = q1, ..., qk, qenv , • The transition function is constructed as follows.",
                "Let q = q1, ..., qk, qenv ∈ St , and α = α1, ..., αk be an action profile s.t. αi ∈ d (i, q).",
                "We define inputi(q, α) = ini ` qi, out1(q1, α1), . . . , outi−1(qi−1, αi−1), outi+1(qi+1, αi+1), . . . , outk(qk, αk), outenv(qenv) ´ for each agent i = 1, . . . , k, and inputenv(q, α) = inenv ` qenv, out1(q1, α1), . . . , outk(qk, αk) ´ .",
                "Then, o (q, α) = o1( q1, α1 , input1(q, α)), . . . , ok( qk, αk , inputk(q, α)), oenv(qenv, inputenv(q, α)) ; The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 901 • For each i = 1, ..., k: q1, ..., qk, qenv ∼i q1, ..., qk, qenv iff qi = qi .6 REMARK 2.",
                "Note that MISs can be used as representations of CGSs too.",
                "In that case, epistemic relations ∼i are simply omitted in the unfolding.",
                "We denote the unfolding of a MIS S for initial states Q into a CGS by cgs(S, Q).",
                "Propositions 3 and 5 state that modular interpreted systems can be used as representations for explicit models of multi-agent systems.",
                "On the other hand, these representations are not always compact, as demonstrated by Propositions 7 and 8.",
                "PROPOSITION 3.",
                "For every CEGS M, there is a MIS SM and a set of global states Q of SM such that cegs(SM , Q) is isomorphic to M.7 PROOF.",
                "Let M = {1, . . . , k}, St, Act, d, o, Π, π, ∼1, . . . , ∼k be a CEGS.",
                "We construct a MIS SM = {a1, . . . , ak}, env, Act, In with agents ai = Sti, di, outi, ini, oi, Πi, πi and environment env = Stenv, outenv, inenv, oenv, Πenv, πenv , plus a set Q ⊆ Stg of global states, as follows. • In = Act ∪ St ∪ (Actk−1 × St), • Sti = {[q]∼i | q ∈ St} for 1 ≤ i ≤ k (i.e., Sti is the set of is indistinguishability classes in M), • Stenv = St, • di([q]∼i ) = d(i, q) for 1 ≤ i ≤ k (this is well-defined since d(i, q) = d(i, q ) whenever q ∼i q ), • outi([q]∼i , αi) = αi for 1 ≤ i ≤ k; outenv(q) = q, • ini([q]∼i , α1, . . . , αi−1, αi+1, . . . , αk, qenv) = α1, . . . , αi−1, αi+1, . . . , αk, qenv for i ∈ {1, . . . , k}; inenv(q, α1 . . . , αk) = α1, . . . , αk ; ini(x) and inenv(x) are arbitrary for other arguments x, • oi( [q]∼i , αi , α1, . . . , αi−1, αi+1, . . . , αk, qenv ) = [o(qenv, α1, . . . , αk)]∼i for 1 ≤ i ≤ k and αi ∈ di([q]∼i ); oenv(q, α1, . . . , αk ) = o(q, α1, . . . , αk); oi and oenv are arbitrary for other arguments, • Πi = ∅ for 1 ≤ i ≤ k, and Πenv = Π, • πenv(p) = π(p) • Q = { [q]∼1 , . . . , [q]∼k , q : q ∈ St} Let M = cegs(SM , Q) = Agt , St , Act , d , o , Π , π , ∼1, . . . , ∼k .",
                "We argue that M and M are isomorphic by establishing a oneto-one correspondence between the respective sets of states, and showing that the other parts of the structures agree on corresponding states.",
                "First we show that, for any ˆq = [q ]∼1 , . . . , [q ]∼k , q ∈ Q and any α = α1, . . . , αk such that αi ∈ d (i, ˆq ), we have o (ˆq , α) = [q]∼1 , . . . , [q]∼k , q where q = o(q , α) (1) Let ˆq = o (ˆq , α).",
                "Now, for any i: inputi(ˆq , α) = ini([q ]∼i , out1([q ]∼1 , α1), ..., outi−1([q ]∼i−1 , αi−1), outi+1([q ]∼i+1 , αi+1), . . . , outk([q ]∼k , αk), outenv(q )) = ini([q ]∼i , α1, . . . , αi−1, αi+1, 6 This shows another difference between the environment and the agents: the environment does not possess knowledge. 7 We say that two CEGS are isomorphic if they only differ in the names of states and/or actions. . . . , αk, q ) = α1, . . . , αi−1, αi+1, . . . , αk, q .",
                "Similarly, we get that inputenv(ˆq , α) = α1, . . . , αk .",
                "Thus we get that o (ˆq , α) = o1( [q ]∼1 , α1 , input1(ˆq , α)), . . . , ok( [q ]∼k , αk , inputk(ˆq , α)), oenv(q , inputenv(ˆq , α)) = [o(q , α1, . . . , αk)]∼1 , . . . , [o(q , α1, . . . , αk)]∼k , o(q , α1, . . . , αk) .",
                "Thus, ˆq = [q]∼1 , . . . , [q]∼k , q for q = o(q , α1, . . . , αk), which completes the proof of (1).",
                "We now argue that St = Q.",
                "Clearly, Q ⊆ St .",
                "Let ˆq ∈ St ; we must show that ˆq ∈ Q.",
                "The argument is on induction on the length of the least o path from Q to ˆq.",
                "The base case, ˆq ∈ Q, is immediate.",
                "For the inductive step, ˆq = o (ˆq , α) for some ˆq ∈ Q, and then we have that ˆq ∈ Q by (1).",
                "Thus, St = Q.",
                "Now we have a one-to-one correspondence between St and St : r ∈ St corresponds to [r]∼1 , . . . , [r]∼k , r ∈ St .",
                "It remains to be shown that the other parts of the structures M and M agree on corresponding states: • Agt = Agt, • Act = Act, • Π = Sk i=1 Πi ∪ Πenv = Π, • For p ∈ Π = Π: [q ]∼1 , . . . , [q ]∼k , q ∈ π (p) iff q ∈ πenv(p) iff q ∈ π(p) (same valuations at corresponding states), • d (i, [q ]∼1 , . . . , [q ]∼k , q ) = di([q ]∼i ) = d(i, q), • It follows immediately from (1), and the fact that Q = St , that o ( [q ]∼1 , . . . , [q ]∼k , q , α) = [r ]∼1 , . . . , [r ]∼k , r iff o(q , α) = r (transitions on the same joint action in corresponding states lead to corresponding states), • [q ]∼1 , . . . , [q ]∼k , q ∼i [r ]∼1 , . . . , [r ]∼k , r iff [q ]∼i = [r ]∼i iff q ∼i r (the accessibility relations relate corresponding states), which completes the proof.",
                "COROLLARY 4.",
                "For every CEGS M, there is an ATLir-equivalent MIS S with initial states Q, that is, for every state q in M there is a state q in cegs(S, Q) satisfying exactly the same ATLir formulae, and vice versa.",
                "PROPOSITION 5.",
                "For every CGS M, there is a MIS SM and a set of global states Q of SM such that cgs(SM , Q) is isomorphic to M. PROOF.",
                "Let M = Agt, St, Act, d, o, Π, π be given.",
                "Now, let ˆM = Agt, St, Act, d, o, Π, π, ∼1, . . . , ∼k for some arbitrary accessibility relations ∼i over St. By Proposition 3, there exists a MIS S ˆM with global states Q such that ˆM = cegs(S ˆM , Q) is isomorphic to ˆM.",
                "Let M be the CGS obtained by removing the accessibility relations from ˆM .",
                "Clearly, M is isomorphic to M. COROLLARY 6.",
                "For every CGS M, there is an ATL-equivalent MIS S with initial states Q.",
                "That is, for every state q in M there is a state q in cgs(S, Q) satisfying exactly the same ATL formulae, and vice versa.",
                "PROPOSITION 7.",
                "The local state spaces in a MIS are not always compact with respect to the underlying concurrent epistemic game structure.",
                "PROOF.",
                "Take a CEGS M in which agent i has always perfect information about the current global state of the system.",
                "When constructing a modular interpreted system S such that M = cegs(S, Q), we have that Sti must be isomorphic with St. 902 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) The above property is a part of the interpreted systems heritage.",
                "The next proposition stems from the fact that explicit models (and interpreted systems) allow for intensive interaction between agents.",
                "PROPOSITION 8.",
                "The size of In in S is, in general, exponential with respect to the number of local states and local actions.",
                "This is the case even when epistemic relations are not relevant (i.e., when S is taken as a representation of an ordinary CGS).",
                "PROOF.",
                "Consider a CGS M with agents Agt = {1, ..., k}, global states St = Qk i=1{qi 0, ..., qi i}, and actions Act = {0, 1}, all enabled everywhere.",
                "The transition function is defined as o( q1 j1 , ..., qk jk , α1, ..., αk) = q1 l1 , ..., qk lk , where li = (ji + α1 + ... + αk) mod i.",
                "Note that M can be represented as a modular interpreted system with succinct local state spaces Sti = {qi 0, ..., qi i}.",
                "Still, the current actions of all agents are relevant to determine the resulting local transition of agent i.",
                "We will call items In, outi, ini the interaction layer of a modular interpreted system S; the other elements of S constitute the local layer of the MIS.",
                "In this paper we are ultimately interested in <br>model check</br>ing complexity with respect to the size of the local layer.",
                "To this end, we will assume that the size of interaction layer is polynomial in the number of local states and actions.",
                "Note that, by Propositions 7 and 8, not every explicit model submits to compact representation with a MIS.",
                "Still, as we declared at the beginning of Section 4, we are mainly interested in a modeling framework for systems of loosely coupled components, where interaction is essential, but most processing is done locally anyway.",
                "More importantly, the framework of MIS allows for separating the interaction of agents from their local structure to a larger extent.",
                "Moreover, we can control and measure the complexity of each layer in a finer way than before.",
                "First, we can try to abstract from the complexity of a layer (e.g. like in this paper, by assuming that the other layer is kept within certain complexity bounds).",
                "Second, we can also measure separately the interaction complexity of different agents. 4.2 Modular Interpreted Systems vs.",
                "Simple Reactive Modules In this section we show that simple reactive modules are (as we already suggested) a specific (and somewhat limited) implementation of modular interpreted systems.",
                "First, we define our (quite strong) notion of equivalence of representations.",
                "DEFINITION 7.",
                "Two representations are equivalent if they unfold to isomorphic concurrent epistemic game structures.",
                "They are CGS-equivalent if they unfold to the same CGS.",
                "PROPOSITION 9.",
                "For any SRML there is a CGS-equivalent MIS.",
                "PROOF.",
                "Consider an SRML R with k modules and n variables.",
                "We construct S = Agt, Act, In with Agt = {a1, ..., ak}, Act = { 1, ..., n, ⊥1, ..., ⊥n}, and In = Sk i=1 Sti × Sti (the local state spaces Sti will be defined in a moment).",
                "Let us assume without loss of generality that ctri = {x1, ..., xr}.",
                "Also, we consider all guarded commands of i to be of type γi,ψ : ψ ; xi := , or γ⊥ i,ψ : ψ ; xi := ⊥.",
                "Now, agent ai in S has the following components: Sti = P(ctri) (i.e., local states of ai are valuations of variables controlled by i); di(qi) = { 1, ..., r, ⊥1, ..., ⊥r}; outi(qi, α) = qi, qi ; ini(qi, q1, q1 , ..., qi−1, qi−1 , qi+1, qi+1 , qk, qk ) = {xi ∈ ctri | q1, ..., qk |= W γi,ψ ψ}, {xi ∈ ctri | q1, ..., qk |= W γ⊥ i,ψ ψ} .",
                "To define local transitions, we consider three cases.",
                "If t = f = ∅ (no update is enabled), then oi(qi, α, t, f ) = qi for every action α.",
                "If t = ∅, we take any arbitrary ˆx ∈ t, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi ∪ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\ {xj} if xj ∈ f, and qi ∪ {ˆx} otherwise.",
                "Moreover, if t = ∅ = f, we take any arbitrary ˆx ∈ f, and define oi(qi, j, t, f ) = qi ∪ {xj} if xj ∈ t, and qi \\ {ˆx} otherwise; oi(qi, ⊥j, t, f ) = qi \\{xj} if xj ∈ f, and qi \\{ˆx} otherwise.",
                "Finally, Πi = ctri, and qi ∈ πi(xj) iff xj ∈ qi.",
                "The above construction shows that SRML have more compact representation of states than MIS: ri local variables of agent i give rise to 2ri local states.",
                "In a way, reactive modules (both simple and full) are two-level representations: first, the system is represented as a product of modules; next, each module can be seen as a product of its variables (together with their update operations).",
                "Note, however, that specification of updates with respect to a single variable in an SRML may require guarded commands of total length O(2 Pk i=1 ri ).",
                "Thus, the representation of transitions in SRML is (in the worst case) no more compact than in MIS, despite the two-level structure of SRML.",
                "We observe finally that MIS are more general, because in SRML the current actions of other agents have no influence on the outcome of agent is current action (although the outcome can be influenced by other agents current local states). 4.3 Model Checking Modular Interpreted Systems One of our main aims was to study the complexity of symbolic <br>model check</br>ing ATLir in a meaningful way.",
                "Following the reviewers remarks, we state our complexity results only as conjectures.",
                "Preliminary proofs can be found in [14].",
                "CONJECTURE 10.",
                "Model checking ATL for modular interpreted systems is EXPTIME-complete.",
                "CONJECTURE 11.",
                "Model checking ATLir for the class of modular interpreted systems is PSPACE-complete.",
                "A summary of complexity results for <br>model check</br>ing temporal and strategic logics (with and without epistemic component) is given in the table below.",
                "The table presents completeness results for various models and settings of input parameters.",
                "Symbols n, k, m stand for the number of states, agents and transitions in an explicit model; l is the length of the formula, and nlocal is the number of local states in a concurrent program or modular interpreted system.",
                "The new results, conjectured in this paper, are printed in italics.",
                "Note that the result for <br>model check</br>ing ATL against modular interpreted systems is an extension of the result from [22]. m, l n, k, l nlocal, k, l CTL P [5] P [5] PSPACE [15] CTLK P [5, 8] P [5, 8] PSPACE [20] ATL P [3] ΔP 3 [12, 16] EXPTIME ATLir ΔP 2 [21, 13] ΔP 3 [13] PSPACE If we are right, then the results for ATL and ATLir form an intriguing pattern.",
                "When we compare <br>model check</br>ing agents with perfect vs. imperfect information, the first problem appears to be much easier against explicit models measured with the number of transitions; next, we get the same complexity class against explicit models measured with the number of states and agents; finally, <br>model check</br>ing imperfect information turns out to be easier than model checking perfect information for modular interpreted systems.",
                "Why can it be so?",
                "First, a MIS unfolds into CEGS and CGS in a different way.",
                "In the first case, the MIS is assumed to encode the epistemic relations explicitly (which makes it explode when we model agents with perfect, or almost perfect information).",
                "In the latter case, the epistemic The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 903 aspect is ignored, which gives some extra room for encoding the transition relation more efficiently.",
                "Another crucial factor is the number of available strategies (relative to the size of input parameters).",
                "The number of all strategies is exponential in the number of global states; for uniform strategies, there are usually much less of them but still exponentially many in general.",
                "Thus, the fact that perfect information strategies can be synthesized incrementally has a substantial impact on the complexity of the problem.",
                "However, measured in terms of local states and agents, the number of all strategies is doubly exponential, while there are only exponentially many uniform strategies - which settles the results in favor of imperfect information. 5.",
                "CONCLUSIONS We have presented a new class of representations for open multiagent systems.",
                "Our representations, called modular interpreted systems, are: modular, in the sense that components can be changed, replaced, removed or added, with as little changes to the whole representation as possible; more compact than traditional explicit representations; and grounded, in the sense that the correspondences between the primitives of the model and the entities being modeled are more immediate, giving a methodology for designing and implementing systems.",
                "We also conjecture that the complexity of <br>model check</br>ing strategic ability for our representations is higher if we assume perfect information than if we assume imperfect information.",
                "The solutions, proposed in this paper, are not necessarily perfect (for example, the impression functions ini seem to be the main source of non-modularity in MIS, and can be perhaps improved), but we believe them to be a step in the right direction.",
                "We also do not mean to claim that our representations should replace more elaborate modeling languages like Promela or reactive modules.",
                "We only suggest that there is a need for compact, modular and reasonably grounded models that are more expressive than concurrent (epistemic) programs, and still allow for easier theoretical analysis than reactive modules.",
                "We also suggest that MIS might be better suited for modeling simple multi-agent domains, especially for human-oriented (as opposed to computer-oriented) design. 6.",
                "ACKNOWLEDGMENTS We thank the anonymous reviewers and Andrzej Tarlecki for their helpful remarks.",
                "Thomas Ågotnes work on this paper was supported by grants 166525/V30 and 176853/S10 from the Research Council of Norway. 7.",
                "REFERENCES [1] R. Alur and T. A. Henzinger.",
                "Reactive modules.",
                "Formal Methods in System Design, 15(1):7-48, 1999. [2] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Lecture Notes in Computer Science, 1536:23-60, 1998. [3] R. Alur, T. A. Henzinger, and O. Kupferman.",
                "Alternating-time Temporal Logic.",
                "Journal of the ACM, 49:672-713, 2002. [4] R. Alur, T.A.",
                "Henzinger, F.Y.C.",
                "Mang, S. Qadeer, S.K.",
                "Rajamani, and S. Tasiran.",
                "MOCHA user manual.",
                "In Proceedings of CAV98, volume 1427 of Lecture Notes in Computer Science, pages 521-525, 1998. [5] E.M. Clarke, E.A.",
                "Emerson, and A.P.",
                "Sistla.",
                "Automatic verification of finite-state concurrent systems using temporal logic specifications.",
                "ACM Transactions on Programming Languages and Systems, 8(2):244-263, 1986. [6] E.A.",
                "Emerson and J.Y.",
                "Halpern. sometimes and not never revisited: On branching versus linear time temporal logic.",
                "In Proceedings of the Annual ACM Symposium on Principles of Programming Languages, pages 151-178, 1982. [7] R. Fagin, J. Y. Halpern, Y. Moses, and M. Y. Vardi.",
                "Reasoning about Knowledge.",
                "MIT Press: Cambridge, MA, 1995. [8] M. Franceschet, A. Montanari, and M. de Rijke.",
                "Model checking for combined logics.",
                "In Proceedings of the 3rd International Conference on Temporal Logic (ICTL), 2000. [9] V. Goranko and W. Jamroga.",
                "Comparing semantics of logics for multi-agent systems.",
                "Synthese, 139(2):241-280, 2004. [10] J. Y. Halpern.",
                "Reasoning about knowledge: a survey.",
                "In D. M. Gabbay, C. J. Hogger, and J.",
                "A. Robinson, editors, The Handbook of Logic in Artificial Intelligence and Logic Programming, Volume IV, pages 1-34.",
                "Oxford University Press, 1995. [11] J.Y.",
                "Halpern and R. Fagin.",
                "Modelling knowledge and action in distributed systems.",
                "Distributed Computing, 3(4):159-177, 1989. [12] W. Jamroga and J. Dix.",
                "Do agents make <br>model check</br>ing explode (computationally)?",
                "In M. P˘echou˘cek, P. Petta, and L.Z.",
                "Varga, editors, Proceedings of CEEMAS 2005, volume 3690 of Lecture Notes in Computer Science, pages 398-407.",
                "Springer Verlag, 2005. [13] W. Jamroga and J. Dix.",
                "Model checking abilities of agents: A closer look.",
                "Submitted, 2006. [14] W. Jamroga and T. Ågotnes.",
                "Modular interpreted systems: A preliminary report.",
                "Technical Report IfI-06-15, Clausthal University of Technology, 2006. [15] O. Kupferman, M.Y.",
                "Vardi, and P. Wolper.",
                "An automata-theoretic approach to branching-time <br>model check</br>ing.",
                "Journal of the ACM, 47(2):312-360, 2000. [16] F. Laroussinie, N. Markey, and G. Oreiby.",
                "Expressiveness and complexity of ATL.",
                "Technical Report LSV-06-03, CNRS & ENS Cachan, France, 2006. [17] K.L.",
                "McMillan.",
                "Symbolic Model Checking: An Approach to the State Explosion Problem.",
                "Kluwer Academic Publishers, 1993. [18] K.L.",
                "McMillan.",
                "Applying SAT methods in unbounded symbolic <br>model check</br>ing.",
                "In Proceedings of CAV02, volume 2404 of Lecture Notes in Computer Science, pages 250-264, 2002. [19] W. Penczek and A. Lomuscio.",
                "Verifying epistemic properties of multi-agent systems via bounded <br>model check</br>ing.",
                "In Proceedings of AAMAS03, pages 209-216, New York, NY, USA, 2003.",
                "ACM Press. [20] F. Raimondi and A. Lomuscio.",
                "The complexity of symbolic <br>model check</br>ing temporal-epistemic logics.",
                "In L. Czaja, editor, Proceedings of CS&P05, 2005. [21] P. Y. Schobbens.",
                "Alternating-time logic with imperfect recall.",
                "Electronic Notes in Theoretical Computer Science, 85(2), 2004. [22] W. van der Hoek, A. Lomuscio, and M. Wooldridge.",
                "On the complexity of practical ATL <br>model check</br>ing.",
                "In P. Stone and G. Weiss, editors, Proceedings of AAMAS06, pages 201-208, 2006. 904 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Sistemas interpretados modulares Wojciech Jamroga Departamento de Informática de la Universidad de Claustral, Alemania wjamroga@in.tu-Clausthal.de Thomas Ågotnes Departamento de Ingeniería Informática Bergen University College, Noruega Tag@hib.No Resumen, proponemos una nueva clase de representaciones que pueden ser que pueden serSe utiliza para modelar (y \"verificar\" modelos) propiedades temporales, estratégicas y epistémicas de los agentes y sus equipos.",
                "También mencionamos resultados preliminares en \"verificación de modelos\" en la lógica temporal de tiempo alterno para esta clase natural de modelos.",
                "En la Sección 3, presentamos una descripción general de las representaciones que se han utilizado para modelar y \"verificación de modelos\" Los sistemas ING en los que son importantes el tiempo, la acción (y posiblemente el conocimiento);Mencionamos representaciones especialmente utilizadas para el análisis teórico.",
                "Concluimos con una hipótesis algo sorprendente, que la capacidad de \"verificación de modelos\" bajo información imperfecta para MIS puede ser computacionalmente más barata que la \"verificación del modelo\" en la información perfecta.",
                "Modelos y verificación de modelos En esta sección, presentamos y discutimos varias representaciones (existentes) de sistemas que pueden usarse para modelar y \"verificación de modelos\".",
                "Dichos modelos ofrecen alguna esperanza para las propiedades factibles de \"verificación de modelos\" de los sistemas abiertos/múltiples agentes, aunque es bien sabido que son compactos solo en una fracción de todos los casos.4 Para nosotros, sin embargo, son insuficientes por otra razón: Son simplemente representaciones optimizadas de modelos explícitos.",
                "Observamos que la \"verificación de modelos\" CTL contra programas concurrentes es PSPACE-COMPLETE en el número de estados locales y la longitud de la fórmula [15].3.5 CP sincrónico y módulos reactivos simples La semántica de ATL se basa en modelos síncronos donde la disponibilidad de acciones no depende de las acciones que actualmente ejecutan los otros jugadores.",
                "Por otro lado, la interacción es posiblemente la característica más interesante de los sistemas de múltiples agentes, y es realmente difícil imaginar modelos de lógicas estratégicas epistémicas, en las que no es posible representar la comunicación.3.7 Módulos reactivos Los módulos reactivos [1] pueden verse como un refinamiento de programas epistémicos concurrentes (utilizados principalmente por la \"verificación del modelo\" de Mocha [4]), pero son mucho más poderosos, expresivos y 900 el sexto intl.",
                "En este documento, finalmente estamos interesados en \"verificar\" la complejidad de la ingles con respecto al tamaño de la capa local.",
                "Observamos finalmente que MIS son más generales, porque en SRML las acciones actuales de otros agentes no tienen influencia en el resultado del agente es la acción actual (aunque el resultado puede verse influenciado por los estados locales actuales de otros agentes).4.3 Comprobación de modelos Sistemas interpretados modulares Uno de nuestros objetivos principales fue estudiar la complejidad de la \"verificación del modelo\" simbólica de la manera significativa."
            ],
            "translated_text": "",
            "candidates": [
                "comprobación de modelos",
                "verificar",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "verificación del modelo",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación de modelos",
                "comprobación de modelos",
                "verificación del modelo",
                "comprobación de modelos",
                "verificar",
                "comprobación de modelos",
                "verificación del modelo"
            ],
            "error": []
        }
    }
}