{
    "id": "I-42",
    "original_text": "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems. Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure. We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements. Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches. The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP. We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm. We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree. We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity. For some problem instances we observe significant improvements in message and computation sizes compared to DPOP. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1. INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP). With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems. CSPs were originally extended to distributed agent environments in [9]. Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2]. Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint. Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions. Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility. This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1]. Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming. Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3]. Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7]. To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem. It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree. However, it was also shown that finding the optimal pseudotree was NP-Hard. We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics. We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors. We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes. After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees. Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types. In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees. We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees. We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm. We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics. We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances. We conclude with a selection of ideas for future work and extensions for DCPOP. 2. PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6]. A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal. Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities. The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values. For this paper we only consider binary utility functions involving two variables. Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches. As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent). Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C). Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree. Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship. Figure 2: A cross-edged pseudotree. Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship. The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root. A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges. Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E). In a cross-edged pseudotree we designate certain edges as primary. The set of primary edges defines a spanning tree of the nodes. The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree. This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance. Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion. First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U. Next, various heuristics are used to arrange this graph into a pseudotree. One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion. We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph. This includes DFS, breadth-first search, and best-first search based traversals. Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3. DPOP ALGORITHM The original DPOP algorithm operates in three main phases. The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm. The second phase joins utility hypercubes from children and the local node and propagates them towards the root. The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node. The complexity of DPOP depends on the size of the largest computation and utility message during phase two. It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6]. DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard. Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8]. At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube. This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X). This hypercube has dimensional size equal to the number of pseudo-parents plus one. A message containing this hypercube is sent to P(X). Agents located at non-leaf nodes wait for all messages from children to arrive. Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y. The local utility hypercube is then joined with all of the hypercubes from the child messages. At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube. This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains. A message containing this hypercube is now sent to P(Y). The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube. This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children. Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children. The combined hypercube contains only values for the domain for Z. At this point the agent at node Z simply chooses the assignment for its domain that has the best utility. A value propagation message with this assignment is sent to each node in C(Z). Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message. The node adds its domain assignment to the assignments it received and passes the set of assignments to its children. The algorithm is complete when all nodes have chosen an assignment for their domain. 4. DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases. The first phase generates the cross-edged pseudotree for the DCOP instance. The second phase merges branches and propagates the utility hypercubes. The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node. For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity. The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree. Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree. A description of this method and the pseudotree selection process appears in Section 5. At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents. In DCPOP, a node X is allowed to have a utility function involving a branch-parent. The concept of a branch can be seen in Figure 2 with node E representing our node X. The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent. This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X). It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1). Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X. In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch. As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent. In DCPOP this message contains dimensions for the domains of P(X) and PP(X). If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure. In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch. When a node Y receives utility propagation messages from all of The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X. The merged branch information structure accumulates the number of merged branches for X. If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X. This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X. In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes. To illustrate this process, we will examine what happens in the second phase for node B in Figure 2. In the second phase Node B receives two utility propagation messages. The first comes from node C and includes dimensions for domains E, B, and A. It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch. The second comes from node D and includes dimensions for domains E and B. It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch. Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A. Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains. In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y. This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children. At this point the agent at node Z chooses the assignment for its domain that has the best utility. If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X. Thus any node that is a merge point will choose assignments for a domain other than its own. These assignments are then passed down the primary edge hierarchy. If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X. Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children. The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP. Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP. Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges. Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node. Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node. Thus all value propagation assignments are chosen at the node of the assignment domain. For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points. We note that any node X that is not a merge point assigns its value exactly as in DPOP. The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X). As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X). Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X). Thus after eliminating domains for which assignments are known, only the domain of X is left. The agent at node X can now correctly choose the assignment with maximum utility for its own domain. If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root. From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages. Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree. For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X). Thus X has utility information about all of the utility functions of which Y is a part. By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y. The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X). The second phase sends one value assignment message to each C(X). Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance. The actual complexity of DCPOP depends on two additional measurements: message size and computation size. Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges. It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree. In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X. Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph. However, in practice a well constructed cross-edged pseudotree can achieve much better results. Later we address the issue of choosing well constructed crossedged pseudotrees from a set. We introduce an additional measurement of the maximum sequential path cost through the algorithm. This measurement directly relates to the maximum amount of parallelism achievable by the algorithm. To take this measurement we first store the total computation size for each node during phase two and three. This computation size represents the number of individual accesses to a value in a hypercube at each node. For example, a join between two domains of size 4 costs 4 ∗ 4 = 16. Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes. The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5. HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm. We acknowledge 744 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e. Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance. The problem of finding the best pseudotree for a given DCOP instance is NP-Hard. Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic. Some previous research focused on finding heuristics to generate good pseudotrees [8]. While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees. We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance. The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity. To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments. Instead, messages include dimensional and branch information but no utility hypercubes. After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree. The root then broadcasts the total complexity for that heuristic to all nodes. After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree. Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic. The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal. The general distributed algorithm uses a token passing mechanism and a linear number of messages. Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion. The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal. A general distributed best-first algorithm for node expansion is presented in Algorithm 2. An evaluation function at each node provides the values that are used to determine the next best node to expand. Note that in this algorithm each node only exchanges its best value with its neighbors. In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed). From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement. The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak. After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children. The complexity of the best-first traversal depends on the complexity of the evaluation function. Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ). For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation. The place operation is at most O(V ) because of the sent messages. Finding the next node uses recursion and traverses only already placed The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions. Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors. This operation is O(V · E), but results can be cached using only O(V ) space at each node. Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E). If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E). This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E). Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6. COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP. We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity. If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity. We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics). In Figure 3(a) we have a DCOP instance with six nodes. This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition. In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance. It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession. We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree. Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b). We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP. Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches. In addition each of these nodes has node A as its parent. Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F). Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal. We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains. However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint. Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar. In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7. EXPERIMENTAL RESULTS 746 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size. We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance. We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm. The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node. We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD). To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each. Each problem was generated by assigning a random number (picked from a range) of constraints to each variable. The generator then created binary constraints until each variable reached its maximum number of constraints. The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5. The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3. Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem. Results are shown for the first set in Table 1 and for the second set in Table 2. For the two problem sets we split the cases into low density and high density categories. Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g. IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems). High density problems consist of the remainder of the problem sets. In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All). The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC. These are all versions of the guided DFS traversal discussed in Section 5. The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B. These are all versions of the best-first traversal discussed in Section 5. For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set. For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set. For the CD and MD metrics the value shown is the average number of dimensions. For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem). The final row in both tables is a measurement of improvement of DCPOP-All over DPOP. For the CD and MD metrics the value shown is a reduction in number of dimensions. For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100). Notice that DCPOPAll outperforms DPOP on all metrics. This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP. Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP. Another trend we notice is that the improvement is greater for high density problems than low density problems. We show this trend in greater detail in Figures 4, 5, and 6. Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6]. The problem setup includes a number of people that are grouped into departments. Each person must attend a specified number of meetings. Meetings can be held within departments or among departments, and can be assigned to one of eight time slots. The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting. All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot. All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot. Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot. For our tests we generated 100 sample problems for each combination of agents and meetings. Results are shown in Table 3. The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree. The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP. Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8. CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements. Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase. Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes. We have shown that DCPOP fully extends DPOP by performing the same operations given the same input. We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees. We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees. We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity. Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees. Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9. REFERENCES [1] J. Liu and K. P. Sycara. Exploiting problem structure for distributed constraint optimization. In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995. MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni. A dynamic distributed constraint satisfaction approach to resource allocation. Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo. An asynchronous complete method for distributed constraint optimization. In AAMAS 03, 2003. [4] A. Petcu. Frodo: A framework for open/distributed constraint optimization. Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings. A-dpop: Approximations in distributed optimization. In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings. Dpop: A scalable method for multiagent constraint optimization. In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes. M-dpop: Faithful distributed implementation of efficient social choice problems. In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov. Solving meeting scheduling problems using distributed pseudotree-optimization procedure. Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara. Distributed constraint satisfaction for formalizing distributed problem solving. In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara. The distributed constraint satisfaction problem: Formalization and algorithms. Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl. Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)",
    "original_translation": "Un método completo de optimización de restricciones distribuidas para arreglos de pseudotreos no tradicionales ∗ James Atlas Computer and Information Sciences de Delaware Newark, de 19716 atlas@cis.udel.edu Keith Decker Computadora e ciencias de la información Universidad de Delaware Newark, DE 19716 Decker@cis.La optimización de restricciones distribuidas abstractas de UDEL.EDU (DCOP) es un marco general que puede modelar problemas complejos en sistemas de múltiples agentes. Varios algoritmos actuales que resuelven instancias generales de DCOP, incluidas las adoptas y DPOP, organizan agentes en una estructura de pseudotree tradicional. Introducimos una extensión al algoritmo DPOP que maneja un conjunto extendido de arreglos de pseudotree. Nuestro algoritmo resuelve correctamente las instancias DCOP para seudotrees que incluyen bordes entre nodos en ramas separadas. El algoritmo también resuelve instancias con arreglos de pseudotree tradicionales utilizando el mismo procedimiento que DPOP. Comparamos nuestro algoritmo con DPOP utilizando varias métricas, incluido el ancho inducido de los seudotrees, la dimensionalidad máxima de los mensajes y el cálculo, y el costo máximo de ruta secuencial a través del algoritmo. Probamos que para algunas instancias problemáticas no es posible generar una pseudotree tradicional utilizando heurísticas transversales de borde que supere a una pseudotree de bordes cruzados. Utilizamos múltiples heurísticas para generar seudotrees y elegir el mejor seudotree en la complejidad lineal del espacio-tiempo. Para algunas instancias problemáticas, observamos mejoras significativas en los tamaños de mensajes y cálculos en comparación con DPOP. Categorías y descriptores de sujetos I.2.11 [Inteligencia artificial]: Sistemas de inteligencia artificial distribuidos Algoritmos de términos generales 1. Introducción Muchos problemas históricos en la comunidad de IA pueden transformarse en problemas de satisfacción de restricciones (CSP). Con el advenimiento de la IA distribuida, los sistemas de múltiples agentes se convirtieron en una forma popular de modelar las complejas interacciones y la coordinación requeridas para resolver problemas distribuidos. Los CSP se extendieron originalmente a los entornos de agentes distribuidos en [9]. Los primeros dominios para problemas de satisfacción de restricciones distribuidas (DISCSP) incluyeron la programación de la tienda de trabajo [1] y la asignación de recursos [2]. Muchos dominios para los sistemas de agentes, especialmente la coordinación del trabajo en equipo, la programación distribuida y las redes de sensores, implican problemas demasiado restringidos que son difíciles o imposibles de satisfacer para cada restricción. Los enfoques recientes para resolver problemas en estos dominios se basan en técnicas de optimización que mapean las limitaciones en funciones de utilidad de valores múltiples. En lugar de encontrar una tarea que satisfaga todas las limitaciones, estos enfoques encuentran una tarea que produce un alto nivel de utilidad global. Esta extensión al enfoque DISCSP original se ha vuelto popular en los sistemas de múltiples agentes, y se ha etiquetado como el problema de optimización de restricciones distribuidas (DCOP) [1]. Los algoritmos actuales que resuelven DCOP completos utilizan dos enfoques principales: búsqueda y programación dinámica. Los algoritmos basados en la búsqueda que se originaron en DISCSP generalmente usan alguna forma de retracking [10] o propagación de límites, como en Adopt [3]. Los algoritmos basados en programación dinámica incluyen DPOP y sus extensiones [5, 6, 7]. Hasta la fecha, ambas categorías de algoritmos organizan agentes en una pseudotree tradicional para resolver el problema. Se ha demostrado en [6] que cualquier gráfico de restricción se puede asignar en una pseudotree tradicional. Sin embargo, también se demostró que encontrar el pseudotree óptimo era NP-Hard. Comenzamos a investigar el rendimiento de los pseudotrees tradicionales generados por la heurística actual transversal de los bordes. Descubrimos que estas heurísticas a menudo producían poco paralelismo, ya que los seudotrees tendían a tener factores de alta profundidad y baja ramificación. Sospechamos que podría haber otras formas de organizar los pseudotrees que proporcionarían un mayor paralelismo y tamaños de mensajes más pequeños. Después de explorar estos otros arreglos, encontramos que los pseudotrees de bordes cruzados proporcionan profundidades más cortas y factores de ramificación más altos que los pseudotrees tradicionales. Nuestra hipótesis era que estos pseudotrees cruzados superarían a los pseudotrees tradicionales para algunos tipos de problemas. En este artículo presentamos una extensión del algoritmo DPOP que maneja un conjunto extendido de arreglos de pseudotree que incluyen seudotrees de bordes cruzados. Comenzamos con una definición de 741 978-81-904262-7-5 (RPS) c 2007 Ifaamas DCOP, pseudotrees tradicionales y pseudotrees de bordes cruzados. Luego proporcionamos un resumen del algoritmo DPOP original e presentamos nuestro algoritmo DCPOP. Discutimos la complejidad de nuestro algoritmo, así como el impacto de la heurística de la generación de seudotree. Luego mostramos que nuestro procedimiento distribuido de optimización de pseudotree de bordes cruzados (DCPOP) funciona significativamente mejor en la práctica que el algoritmo DPOP original para algunas instancias problemáticas. Concluimos con una selección de ideas para el trabajo futuro y las extensiones para DCPOP.2. Definición de problemas DCOP se ha formalizado de manera ligeramente diferente en la literatura reciente, por lo que adoptaremos la definición como se presenta en [6]. Un problema de optimización de restricción distribuido con nodos n y restricciones M consiste en la tuple <x, d, u> donde: • x = {x1, .., xn} es un conjunto de variables, cada una asignada a un agente único • D= {d1, .., dn} es un conjunto de dominios finitos para cada variable • u = {u1, .., um} es un conjunto de funciones de utilidad, de modo que cada función implica un subconjunto de variables en x y define una utilidadPara cada combinación de valores entre estas variables, una solución óptima a una instancia de DCOP consiste en una asignación de valores en D a X de modo que la suma de utilidades en U es máxima. Los dominios de problemas que requieren un costo mínimo en lugar de la utilidad máxima pueden asignar los costos en servicios públicos negativos. Las funciones de utilidad representan restricciones suaves, pero también pueden representar restricciones duras mediante el uso de valores negativos arbitrariamente grandes. Para este artículo solo consideramos funciones de utilidad binaria que involucran dos variables. Las funciones de utilidad de orden superior pueden modelarse con cambios menores en el algoritmo, pero también aumentan sustancialmente la complejidad.2.1 Los pseudotrees tradicionales seudotrees son una estructura común utilizada en los procedimientos de búsqueda para permitir el procesamiento paralelo de ramas independientes. Como se define en [6], una pseudotree es una disposición de un gráfico G en un árbol enraizado t de tal manera que los vértices en G que comparten un borde están en la misma rama en T. Un borde posterior es un borde entre un nodo X yCualquier nodo que se encuentre en la ruta de X a la raíz (excluyendo XS Parent). La Figura 1 muestra una pseudotree con cuatro nodos, tres bordes (A-B, B-C, BD) y un de vanguardia (A-C). También se definen en [6] se existen cuatro tipos de relaciones entre los nodos en un pseudotree: • p (x) - el padre de un nodo x: el nodo único más alto en la seudotree que está conectado a x directamente a través de un borde de árbol • c(X) - Los hijos de un nodo X: el conjunto de nodos más bajos en el pseudotree que están conectados a x directamente a través de los bordes de los árboles • PP (x) - los pseudo -parentes de un nodo X: el conjunto de nodos más altos en elPseudotree que están conectados a x directamente a través de back-back-backs (en la Figura 1, a = pp (c)) • PC (x)-los pseudo-niños de un nodo X: el conjunto de nodos más bajos en el pseudotree que están conectados aX directamente a través de bordes de fondo (en la Figura 1, c = PC (a)) Figura 1: una pseudotree tradicional. Los bordes de línea continua representan relaciones entre padres e hijos y la línea discontinua representa una relación pseudo-parent-pseudo-e-e-e-e-e-e-e-e-child. Figura 2: un pseudotree de bordes cruzados. Los bordes de la línea continua representan relaciones entre padres e hijos, la línea discontinua representa una relación pseudoparent-pseudo-e-e-e-e-e-e-e-e-fild, y la línea punteada representa una relación de rama-sobrenadina. El nodo en negrita, B, es el punto de fusión para el nodo E. 2.2 Pseudotrees de bordes cruzados. Definimos un borde cruzado como un borde del nodo X a un nodo Y que está por encima de X pero no en la ruta de X a la raíz. Un pseudotree de bordes cruzados es una pseudotree tradicional con la adición de carcajadas cruzadas. La Figura 2 muestra una pseudotree cruzada con un borde cruzado (D-E). En una pseudotree de bordes cruzados designamos ciertos bordes como primarios. El conjunto de bordes primarios define un árbol de expansión de los nodos. Las relaciones padre, niño, pseudo-parente y pseudo-child de la pseudotree tradicional ahora se definen en el contexto de este árbol principal de abordaje de borde. Esta definición también produce dos tipos adicionales de relaciones que pueden existir entre los nodos: • BP (X): los padres de rama de un nodo X: el conjunto de nodos más altos en el pseudotree que están conectados a X pero no están en la ruta primariade x a la raíz (en la figura 2, d = bp (e)) • bc (x) - los niños ramificados de un nodo x: el conjunto de nodos más bajos en el pseudotree que están conectados a x pero no están en ningúnruta primaria de x a cualquier nodo de hoja (en la Figura 2, E = BC (d)) 2.3 Generación de seudotree 742 El sexto intl. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07), los algoritmos de corriente generalmente tienen una fase de preexecución para generar una pseudotree tradicional a partir de una instancia general de DCOP. Nuestro algoritmo DCPOP genera un pseudotree de bordes cruzados de la misma manera. Primero, la instancia DCOP <x, d, u> se traduce directamente en un gráfico con x como el conjunto de vértices y un borde para cada par de variables representadas en U. A continuación, se utilizan varias heurísticas para organizar este gráfico en una pseudotree. Una heurística común es realizar una búsqueda guiada de profundidad primero (DFS) ya que el recorrido resultante es una pseudotree, y un DFS se puede realizar fácilmente de manera distribuida. Definimos un método basado en el borde como cualquier método que produzca un pseudotree en el que todos los pares de padres/niños compartan un borde en el gráfico original. Esto incluye DFS, búsqueda de amplitud-primera y la mejor primera búsqueda basadas en la búsqueda. Nuestras heurísticas que generan pseudotrees de bordes cruzados utilizan un recorrido de búsqueda distribuido de la mejor primera búsqueda.3. Algoritmo DPOP El algoritmo DPOP original funciona en tres fases principales. La primera fase genera una pseudotree tradicional a partir de la instancia de DCOP utilizando un algoritmo distribuido. La segunda fase se une a los hipercubos de servicios públicos de los niños y el nodo local y los propaga hacia la raíz. La tercera fase elige una tarea para cada dominio de una manera de arriba hacia abajo, comenzando con el agente en el nodo raíz. La complejidad de DPOP depende del tamaño del mensaje de cálculo y utilidad más grande durante la fase dos. Se ha demostrado que este tamaño corresponde directamente al ancho inducido de la pseudotree generada en la fase uno [6]. DPOP utiliza heurísticas de tiempo polinomial para generar la seudotree desde que encontrar el ancho mínimo de ancho inducido pseudotree es NP-Hard. Se han desarrollado varias heurísticas distribuidas EdgetRaversal para encontrar pseudotrees de bajo ancho [8]. Al final de la primera fase, cada agente conoce a sus padres, hijos, pseudo-padres y pseudo-niños.3.1 Los agentes de propagación de servicios públicos ubicados en nodos de hoja en el pseudotree comienzan el proceso calculando un hipercubo local de utilidad. Este hipercubo en el nodo X contiene utilidades sumadas para cada combinación de valores en los dominios para p (x) y pp (x). Este hipercube tiene un tamaño dimensional igual al número de pseudo-parentes más uno. Un mensaje que contiene este hipercube se envía a P (x). Los agentes ubicados en los nodos no hojas esperan a que lleguen todos los mensajes de los niños. Una vez que el agente en el nodo Y tiene todos los mensajes de utilidad, calcula su hipercubo de utilidad local que incluye dominios para P (Y), PP (Y) e Y. El hipercube de utilidad local se une con todos los hipercubos de los mensajes infantiles. En este punto, se conocen todas las utilidades que involucran el nodo Y, y el dominio para Y puede eliminarse de manera segura del hipercubo unido. Este proceso de eliminación elige la mejor utilidad sobre el dominio de Y para cada combinación de los dominios restantes. Un mensaje que contiene este hipercube ahora se envía a P (y). El tamaño dimensional de este hipercubo depende del número de dominios superpuestos en los mensajes recibidos y la utilidad local Hypercube. Esta fase de propagación basada en programación dinámica continúa hasta que el agente en el nodo raíz del pseudotree haya recibido todos los mensajes de sus hijos.3.2 Propagación del valor La propagación del valor comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. Como Z no tiene padres ni pseudo-padres, simplemente combina los hipercubos de servicios públicos recibidos de sus hijos. El hipercubo combinado contiene solo valores para el dominio para Z. En este punto, el agente en el nodo Z simplemente elige la asignación para su dominio que tiene la mejor utilidad. Se envía un mensaje de propagación de valor con esta asignación a cada nodo en C (z). El nodo del otro recibe un mensaje de propagación de valor de su padre y elige la asignación de su dominio que tiene la mejor utilidad dadas las tareas recibidas en el mensaje. El nodo agrega su asignación de dominio a las asignaciones que recibió y pasa el conjunto de tareas a sus hijos. El algoritmo está completo cuando todos los nodos han elegido una tarea para su dominio.4. Algoritmo DCPOP Nuestra extensión al algoritmo DPOP original, que se muestra en el Algoritmo 1, comparte las mismas tres fases. La primera fase genera el pseudotree de bordes cruzados para la instancia de DCOP. La segunda fase fusiona ramas y propaga los hipercubos de utilidad. La tercera fase elige asignaciones para dominios en los puntos de fusión de rama y de una manera de arriba hacia abajo, comenzando con el agente en el nodo raíz. Para la primera fase generamos una pseudotree utilizando varias heurísticas distribuidas y seleccionamos la que con la más baja complejidad general. La complejidad del tamaño del mensaje de cálculo y utilidad en DCPOP no corresponde directamente al ancho inducido del pseudotree de filo cruzado. En cambio, utilizamos un método de tiempo polinomial para calcular el tamaño máximo de cálculo y mensaje de utilidad para una pseudotree de filo cruzado dado. Una descripción de este método y el proceso de selección de pseudotree aparece en la Sección 5. Al final de la primera fase, cada agente conoce a sus padres, hijos, pseudoparentes, pseudo-niños, sucursales y hijos de ramas.4.1 Las ramas de fusión y la propagación de utilidad en el algoritmo DPOP original Un nodo X solo tenía funciones de utilidad que involucraban a su padre y sus pseudo-padres. En DCPOP, se permite que un nodo X tenga una función de utilidad que involucre a un parente de rama. El concepto de una rama se puede ver en la Figura 2 con el nodo E que representa nuestro nodo X. Las dos rutas distintas desde el nodo E al nodo B se denominan ramas de E. El nodo único donde todas las ramas de E se encuentran es el nodo B, que se llama el punto de fusión de E. Agentes con nodos que tienen a los padres de ramas que comienzan enviando unMensaje de propagación de utilidad a cada sán y padre. Este mensaje incluye un hipercubo de utilidad bidimensional con dominios para el nodo X y la BP-PARENT BP (X). También incluye una estructura de información de rama que contiene el nodo de origen de la rama, x, el número total de ramas que se originan en x y el número de ramas que se originan en x que se fusionan en una sola representación por esta estructura de información de la rama (este númerocomienza en 1). Intuitivamente cuando el número de ramas fusionadas es igual al número total de ramas de origen, el algoritmo ha alcanzado el punto de fusión para X. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su billete de rama, nodo D. Este mensaje tiene dimensiones para los dominios de E y D, e incluye información de rama con un origen de E, 2 ramas totales y 1 rama fusionada. Como en la fase original de propagación de utilidad DPOP, un agente en el nodo Leaf X envía un mensaje de propagación de utilidad a su padre. En DCPOP, este mensaje contiene dimensiones para los dominios de P (x) y PP (x). Si el nodo X también tiene a la sucursal, entonces el mensaje de propagación de la utilidad también contiene una dimensión para el dominio de X, e incluirá una estructura de información de rama. En la Figura 2, el nodo E envía un mensaje de propagación de utilidad a su padre, el nodo C. Este mensaje tiene dimensiones para los dominios de E y C, e incluye información de rama con un origen de E, 2 ramas totales y 1 rama fusionada. Cuando un nodo Y recibe mensajes de propagación de utilidad de todo el sexto INTL. Conf.En agentes autónomos y sistemas de múltiples agentes (AAMAS 07) 743 Sus hijos y children, fusiona cualquier ramas con el mismo nodo de origen X. La estructura de información de la rama fusionada acumula el número de ramas fusionadas para X. Si el número total acumulativo de ramas fusionadas es igual al número total de ramas, entonces Y es el punto de fusión para X. Esto significa que los hipercubos de utilidad presentes en Y contienen toda la información sobre las valoraciones para las funciones de servicios públicos que involucran el nodo X. Además de la eliminación típica del dominio de Y de los hipercubos de utilidad, ahora podemos eliminar de manera segura el dominio de X de los hipercubos de utilidad. Para ilustrar este proceso, examinaremos lo que sucede en la segunda fase para el nodo B en la Figura 2. En la segunda fase, el nodo B recibe dos mensajes de propagación de utilidad. El primero proviene del nodo C e incluye dimensiones para dominios E, B y A. También tiene una estructura de información de rama con origen de E, 2 ramas totales y 1 rama fusionada. El segundo proviene del nodo D e incluye dimensiones para los dominios E y B. También tiene una estructura de información de rama con origen de E, 2 ramas totales y 1 rama fusionada. El nodo B luego fusiona las estructuras de información de la rama de ambos mensajes porque tienen el mismo origen, el nodo E. Dado que el número de ramas fusionadas que se originan en E ahora es 2 y las ramas totales que se originan en E es 2, el nodo B ahora elimina las dimensiones paraDominio E. El nodo B también elimina la dimensión para su propio dominio, dejando solo información sobre el dominio A. El nodo B luego envía un mensaje de propagación de utilidad al nodo A, que contiene solo una dimensión para el dominio de A. Aunque no es posible en DPOP, este método de propagación de utilidad y eliminación de dimensiones puede producir hipercubos en el nodo Y que no comparten ningún dominio. En DCPOP no unimos hipercubos independientes del dominio, sino que podemos enviar múltiples hipercubos en el mensaje de propagación de utilidad enviado a los padres de Y. Este enfoque perezoso para unirse ayuda a reducir los tamaños de mensajes.4.2 Propagación del valor Como en DPOP, la propagación del valor comienza cuando el agente en el nodo raíz Z ha recibido todos los mensajes de sus hijos. En este punto, el agente en el nodo Z elige la asignación para su dominio que tiene la mejor utilidad. Si Z es el punto de fusión para las ramas de algún nodo X, Z también elegirá la asignación para el dominio de X. Por lo tanto, cualquier nodo que sea un punto de fusión elegirá tareas para un dominio que no sea el suyo. Estas tareas se transmiten por la jerarquía de borde primario. Si el nodo X en la jerarquía tiene algas de ramas, entonces el mensaje de asignación de valor de P (x) contendrá una asignación para el dominio de X. Cada nodo en la jerarquía agrega cualquier tarea que haya elegido a las que recibió y pasa el conjunto de tareas a sus hijos. El algoritmo está completo cuando todos los nodos han elegido o recibido una tarea para su dominio.4.3 Prueba de corrección probaremos la corrección de DCPOP al señalar primero que DCPOP extiende completamente DPOP y luego examinando los dos casos para la asignación de valor en DCPOP. Dada una pseudotree tradicional como entrada, la ejecución del algoritmo DCPOP es idéntica a DPOP. Usando una disposición de pseudotree tradicional, no los nodos tienen serales de ramas o children, ya que todos los bordes son bordes o bordes de árboles. Por lo tanto, el algoritmo DCPOP que utiliza una pseudotree tradicional envía solo mensajes de propagación de utilidad que contienen dominios pertenecientes a los padres o pseudo-parentes de un nodo. Dado que ningún nodo tiene ningún tipo de sucursal, no existen ramas y, por lo tanto, ningún nodo sirve como punto de fusión para ningún otro nodo. Por lo tanto, todas las asignaciones de propagación de valor se eligen en el nodo del dominio de asignación. Para la ejecución de DCPOP con pseudotrees de bordes cruzados, algunos nodos sirven como puntos de fusión. Observamos que cualquier nodo X que no sea un punto de fusión asigna su valor exactamente como en DPOP. El hipercube de utilidad local en X contiene dominios para X, P (X), PP (X) y BC (X). Como en DPOP, el mensaje de asignación de valor recibido en x incluye los valores asignados a P (x) y pp (x). Además, dado que X no es un punto de fusión, todas las tareas a BC (x) deben haberse calculado en puntos de fusión más altos en el árbol y están en el mensaje de asignación de valor de P (x). Por lo tanto, después de eliminar los dominios para los cuales se conocen las tareas, solo queda el dominio de x. El agente en el nodo X ahora puede elegir correctamente la asignación con la utilidad máxima para su propio dominio. Si el nodo X es un punto de fusión para alguna rama, Hijo Y, sabemos que X debe ser un nodo a lo largo de la ruta desde y hasta la raíz, y de P (y) y toda BP (y) a la raíz. Del algoritmo, sabemos que Y necesariamente tiene toda la información de C (y), PC (y) y BC (y) ya que espera sus mensajes. El nodo X tiene información sobre todos los nodos debajo del árbol, que incluiría Y, P (Y), BP (y) y los PP (y) que están por debajo de x en el árbol. Para cualquier pp (y) arriba x en el árbol, X recibe la asignación para el dominio de PP (y) en el mensaje de asignación de valor de P (x). Por lo tanto, X tiene información de utilidad sobre todas las funciones de utilidad de las cuales Y es parte. Al eliminar los dominios incluidos en el mensaje de asignación de valor, el nodo X se deja con un hipercubo de utilidad local con dominios para X e Y. El agente en el nodo X ahora puede elegir correctamente las tareas con la utilidad máxima para los dominios de X e Y. 4.4 Análisis de complejidad La primera fase de DCPOP envía un mensaje a cada P (x), PP (x) y BP (x). La segunda fase envía un mensaje de asignación de valor a cada C (x). Por lo tanto, DCPOP produce un número lineal de mensajes con respecto al número de bordes (funciones de utilidad) en el pseudotree cruzado y la instancia DCOP original. La complejidad real de DCPOP depende de dos medidas adicionales: tamaño de mensaje y tamaño de cálculo. El tamaño del mensaje y el tamaño de cálculo en DCPOP dependen del número de ramas superpuestas, así como del número de bordes superpuestos. Se demostró en [6] que el número de bordes posteriores superpuestos es igual al ancho inducido de la seudotree. En un pseudotree de bordes cruzados mal construidos, el número de ramas superpuestas en el nodo X puede ser tan grande como el número total de descendientes de X. Por lo tanto, el tamaño total del mensaje en DCPOP en una instancia mal construida puede ser exponencial en el número total de nodos en el gráfico. Sin embargo, en la práctica, una pseudotree bien construida puede lograr resultados mucho mejores. Más tarde abordamos el tema de elegir pseudotrees cruzados bien construidos de un conjunto. Introducimos una medición adicional del costo de ruta secuencial máximo a través del algoritmo. Esta medición se relaciona directamente con la cantidad máxima de paralelismo que se puede lograr por el algoritmo. Para tomar esta medición, primero almacenamos el tamaño total de cálculo para cada nodo durante la fase dos y tres. Este tamaño de cálculo representa el número de accesos individuales a un valor en un hipercubo en cada nodo. Por ejemplo, una unión entre dos dominios de tamaño 4 cuesta 4 ∗ 4 = 16. Luego se pueden dibujar dos gráficos acíclicos dirigidos (DAG);Uno con los mensajes de propagación de utilidad como bordes y la fase dos costos en los nodos, y el otro con mensajes de asignación de valor y la fase tres costos en los nodos. El costo máximo de ruta secuencial es igual a la suma de la ruta más larga en cada DAG desde la raíz hasta cualquier nodo de hoja.5. Heurística En nuestra evaluación de la complejidad en DCPOP, nos centramos en el peor de los casos que posiblemente produce el algoritmo. Reconocemos 744 el sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07) Algoritmo 1 Algoritmo DCPOP 1: DCPOP (x; d; u) Cada agente XI ejecuta: Fase 1: Creación de pseudotree 2: Líder electo de todos XJ ∈ X 3: Iniciadores de líder electoPseudotree Creation 4: después, Xi sabe P (xi), pp (xi), bp (xi), c (xi), bc (xi) y pc (xi) fase 2: propagación de mensajes utilizado 5: if | bp (xi (xi) |> 0 luego 6: Branchxi ← | BP (xi) |+ 1 7: Para todos los xk ∈Bp (xi) do 8: utilxi (xk) ← Compute utils (xi, xk) 9: enviar mensaje (xk, utilxi (xk), branchxi) 10: if | c (xi) |= 0 (es decir. Xi es un nodo de hoja) luego 11: utilxi (p (xi)) ← Computed Utils (p (xi), pp (xi)) para todos los pp (xi) 12: enviar mensaje (p (xi), utilxi (p (p (p (p (p (p (p (p (p (Xi)), Branchxi) 13: Enviar mensaje (pp (xi), utilizar vacío, rama vacía) a todos los pp (xi) 14: activar el controlador de mensajes utilizado () Fase 3: Valor Propagación de mensajes 15: Activar Valor Message Handler ()Handler de mensajes del algoritmo final (xk, utilxk (xi), branchxk) 16: almacenar utilxk (xi), branchxk (xi) 17: si los mensajes de todos los niños y los niños de la rama llegaron entonces 18: para todos bj ∈Branch (xi)do 19: si bj se fusiona, entonces 20: une a todos los hipercubos donde bj ∈Util (xi) 21: elimine bj del hipercubo unido 22: si p (xi) == nulo (eso significa xi es la raíz) entonces 23: v∗ i ← Elija óptimo (nulo) 24: envío de valor (xi, v ∗ i) a todos c (xi) 25: else 26: utilxi (p (xi)) ← Compute Utils (P (xi), pp (xi)) 27: Enviar mensaje (p (xi), utilxi (p (xi)), branchxi (p (xi))) Valor Mensaje Handler (valuexi, p (xi)) 28: Agregue todo xk ← v ∗ k ∈Valuexi,P (xi) a la vista del agente 29: xi ← v ∗ i = Elija óptimo (vista de agente) 30: Enviar valorxl, xi a todos xl ∈C (xi) que en los problemas del mundo real la generación de la pseudotree tiene un impacto significativo enel rendimiento real. El problema de encontrar el mejor pseudotree para una instancia de DCOP dada es NP-Hard. Por lo tanto, se usa una heurística para la generación, y el rendimiento del algoritmo depende de la seudotree encontrada por la heurística. Algunas investigaciones anteriores se centraron en encontrar heurísticas para generar buenos pseudotrees [8]. Si bien hemos desarrollado algunas heurísticas que generan buenos pseudotrees de bordes cruzados para su uso con DCPOP, nuestro enfoque ha sido usar múltiples heurísticas y luego seleccionar la mejor pseudotree de los seudotrees generados. Consideramos solo la heurística que se ejecutan en tiempo polinomial con respecto al número de nodos en la instancia original de DCOP. El algoritmo DCPOP real tiene la peor complejidad exponencial de los casos, pero podemos calcular el tamaño máximo del mensaje, el tamaño de la cálculo y el costo de ruta secuencial para una pseudotree de bordes cruzados dados en la complejidad lineal de espacio-tiempo. Para hacer esto, simplemente ejecutamos el algoritmo sin intentar calcular cualquiera de los hipercubos de utilidad local u asignaciones de valor óptimas. En su lugar, los mensajes incluyen información dimensional y de rama, pero no hay hipercubos de utilidad. Después de que cada heurística complete su generación de una pseudotree, ejecutamos el procedimiento de medición y propagamos la información de medición hasta la raíz elegida en esa seudotree. La raíz luego transmite la complejidad total de esa heurística para todos los nodos. Después de que todas las heurísticas han tenido la oportunidad de completar, cada nodo sabe qué heurística produjo la mejor seudotree. Cada nodo luego procede a comenzar el algoritmo DCPOP utilizando su conocimiento del pseudotree generado por la mejor heurística. La heurística utilizada para generar seudotrees tradicionales realiza un transversal DFS distribuido. El algoritmo distribuido general utiliza un mecanismo de aprobación de tokens y un número lineal de mensajes. La heurística basada en DFS mejorada Utilice un procedimiento especial para elegir el nodo raíz y también proporcionar una función de pedido sobre los vecinos de un nodo para determinar el orden de la recursión de ruta. Las heurísticas basadas en DFS utilizadas en nuestros experimentos provienen del trabajo realizado en [4, 8].5.1 El mejor primer pseudotree heurística de bordes cruzados La heurística utilizada para generar pseudotrees cruzados realizan una mejor transversal. En el Algoritmo 2 se presenta un algoritmo general distribuido para la expansión del nodo para la expansión del nodo. Una función de evaluación en cada nodo proporciona los valores que se utilizan para determinar el siguiente mejor nodo para expandirse. Tenga en cuenta que en este algoritmo cada nodo solo intercambia su mejor valor con sus vecinos. En nuestros experimentos utilizamos varias funciones de evaluación que tomaron como argumentos una lista ordenada de antepasados y un nodo, que contiene una lista de vecinos (con la profundidad de colocación de cada vecino en el árbol si se colocó). A partir de estos, podemos calcular los ramas, las ramas y las relaciones desconocidas para una posible colocación de nodos. La mejor función general calculó el valor como antepasados (Branchparents+Branchildren) con el número de relaciones desconocidas como un desempate. Después de completar, cada nodo tiene conocimiento de sus padres y antepasados, por lo que puede determinar fácilmente qué nodos conectados son pseudo-padres, ramas, pseudo-niñes y chíbles de sucursales. La complejidad de la mejor transversal depende de la complejidad de la función de evaluación. Suponiendo una complejidad de O (V) para la función de evaluación, que es el caso de nuestra mejor función general, la mejor transversal es O (V · E) que es en el peor de O (N3). Para cada v ∈ V realizamos una operación de lugar y encontramos el siguiente nodo para colocar utilizando la operación GetBestneighbor. La operación del lugar es como máximo o (v) debido a los mensajes enviados. Encontrar el siguiente nodo usa recursión y recorridos solo se colocó el sexto INTL. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 745 Algoritmo 2 Distribuido el mejor algoritmo de búsqueda de la primera raíz ← ElegedLeader Next (root, ∅) lugar (nodo, parent) nodoEnviar mensaje de colocación (nodo, nodo.ancestors) a todos los vecinos de nodo siguiente (actual, anterior) Si la corriente no se coloca, entonces coloque (actual, anterior) Siguiente (actual, ∅) más mejor ← GetBestneighbor (actual, anterior) Si es mejor)= ∅ Entonces, si anteriormente = ∅ entonces termina, todos los nodos se colocan a continuación (anterior, ∅) más siguiente (mejor, actual) getBestneighbor (actual, anterior) mejor ← ∅;puntaje ← 0 para todos n ∈ Current. Neighbors do si n!= Anterior entonces si n se coloca, entonces nscore ← getBestneighbor (n, actual) más nscore ← Evalúe (actual, n) Si nscore> anota y luego obtiene ← nscore mejor ← n devuelve mejor, puntaje nodos, por lo que tiene o (v) recursiones. Cada recursión realiza una operación recursiva de GetBestneighbor que atraviesa todos los nodos colocados y sus vecinos. Esta operación es O (V · E), pero los resultados se pueden almacenar en caché utilizando solo el espacio O (V) en cada nodo. Así tenemos O (V · (V +V +V · E)) = O (V 2 · E). Si somos inteligentes sobre la evaluación de los cambios locales cuando cada nodo recibe mensajes de colocación de sus vecinos y almacena en caché los resultados La operación de GetBestneighbor es solo o (e). Esto aumenta la complejidad de la operación del lugar, pero para todas las ubicaciones la complejidad total es solo o (V · E). Por lo tanto, tenemos una complejidad general de O (V · E +V · (V +E)) = O (V · E).6. Comparación de la complejidad en DPOP y DCPOP Ya hemos demostrado que, dada la misma entrada, DCPOP realiza lo mismo que DPOP. También hemos demostrado que podemos predecir con precisión el rendimiento de un pseudotree dado en complejidad lineal en tiempo espacial. Si usamos un número constante de heurísticas para generar el conjunto de seudotrees, podemos elegir el mejor seudotree en la complejidad lineal del espacio-tiempo. Ahora demostraremos que existe una instancia de DCOP para la cual un pseudotree de bordes cruzados supera a todos los pseudotrees tradicionales posibles (basados en heurísticas traversales de borde). En la Figura 3 (a) tenemos una instancia de DCOP con seis nodos. Este es un gráfico bipartito con cada partición totalmente conectada a la otra (a) (b) (c) Figura 3: (a) la instancia de DCOP (b) Una disposición de pseudotree tradicional para la instancia DCOP (c) un pseudotree de filo cruzadodisposición para la partición de instancia DCOP. En la Figura 3 (b) vemos una disposición tradicional de seudotree para esta instancia de DCOP. Es fácil ver que cualquier heurística basada en EdgetRaversal no puede expandir dos nodos de la misma partición en sucesión. También vemos que ningún nodo puede tener más de un hijo porque cualquier acuerdo de este tipo sería una seudotree inválida. Por lo tanto, cualquier disposición de pseudotree tradicional para esta instancia de DCOP debe tomar la forma de la Figura 3 (b). Podemos ver que el nodo de superposición F-B y F-A del nodo C. C. El nodo C también tiene un padre E, y un borde posterior con D. usando el algoritmo DPOP original (o DCPOP ya que son idénticos en este caso), encontramosQue el cálculo en el nodo C implica cinco dominios: A, B, C, D y E., en contraste, la disposición de pseudotree de filo cruzado en la Figura 3 (c) requiere solo un máximo de cuatro dominios en cualquier cálculo durante DCPOP. Dado que el nodo A es el punto de fusión para ramas de B y C, podemos ver que cada uno de los nodos D, E y F tienen dos ramas superpuestas. Además, cada uno de estos nodos tiene el nodo A como padre. Usando el algoritmo DCPOP, encontramos que el cálculo en el nodo D (o E o F) implica cuatro dominios: A, B, C y D (o E o F). Dado que no se puede crear una mejor disposición de pseudotree tradicional utilizando una heurística transversal de borde, hemos demostrado que DCPOP puede superar a DPOP incluso si usamos la pseudotree óptima que se encuentra a través del traversal de borde. Reconocemos que los arreglos de pseudotree que permiten las relaciones entre padres e hijos sin una restricción real pueden resolver el problema en la Figura 3 (a) con el tamaño máximo de cálculo de cuatro dominios. Sin embargo, las heurísticas actuales utilizadas con DPOP no producen tales pseudotrees, y tal heurística sería difícil de distribuir ya que cada nodo requeriría información sobre los nodos con los que no tiene restricción. Además, si bien no lo probamos aquí, los pseudotrees de bordes cruzados pueden producir tamaños de mensajes más pequeños que tales seudotatas, incluso si el tamaño de cálculo es similar. En la práctica, dado que encontrar la mejor disposición de pseudotree es NP-Hard, encontramos que las heurísticas que producen pseudotrees de filo cruzado a menudo producen tamaños de cálculo y mensajes significativamente más pequeños.7. Resultados experimentales 746 El sexto intl. Conf.En agentes autónomos y sistemas de agentes múltiples (AAMAS 07), las métricas de rendimiento existentes para los algoritmos DCOP incluyen el número total de mensajes, ciclos de reloj sincrónicos y tamaño de mensaje. Ya hemos demostrado que el número total de mensajes es lineal con respecto al número de restricciones en la instancia de DCOP. También introdujimos el costo máximo de ruta secuencial (PC) como una medición de la cantidad máxima de paralelismo lograble por el algoritmo. El costo máximo de la ruta secuencial es igual a la suma de los cálculos realizados en la ruta más larga desde la raíz hasta cualquier nodo de hoja. También incluimos como métricas el tamaño máximo de cálculo en número de dimensiones (CD) y tamaño máximo del mensaje en número de dimensiones (MD). Para analizar la complejidad relativa de una instancia DCOP dada, encontramos el ancho mínimo inducido (IW) de cualquier pseudotree tradicional producida por una heurística para el DPOP original.7.1 Instancias genéricas de DCOP Para nuestras pruebas iniciales generamos al azar dos conjuntos de problemas con 3000 casos en cada uno. Cada problema se generó asignando un número aleatorio (elegido desde un rango) de restricciones a cada variable. Luego, el generador creó restricciones binarias hasta que cada variable alcanzó su número máximo de restricciones. El primer conjunto usa 20 variables, y el mejor DPOP IW varía de 1 a 16 con un promedio de 8.5. El segundo conjunto usa 100 variables, y el mejor DPOP IW varió de 2 a 68 con un promedio de 39.3. Dado que la mayoría de los problemas en el segundo conjunto eran demasiado complejos para calcular la solución, tomamos medidas de las métricas utilizando las técnicas descritas anteriormente en la Sección 5 sin resolver el problema. Los resultados se muestran para el primer conjunto en la Tabla 1 y para el segundo conjunto en la Tabla 2. Para los dos conjuntos de problemas, dividimos los casos en categorías de baja densidad y alta densidad. Los casos de baja densidad consisten en aquellos problemas que tienen un mejor DEPOP es menor o igual a la mitad del número total de nodos (p. IW ≤ 10 para los 20 problemas de nodo e IW ≤ 50 para los 100 problemas de nodo). Los problemas de alta densidad consisten en el resto de los conjuntos de problemas. Tanto en la Tabla 1 como en la Tabla 2, hemos enumerado las métricas de rendimiento para el algoritmo DPOP original, el algoritmo DCPOP que usa solo seudotreos de bordado cruzado (DCPOP-CE) y el algoritmo DCPOP utilizando seudotreos tradicionales y de bordes cruzados (DCPOP-ALL). Los pseudotrees utilizados para DPOP se generaron utilizando 5 heurísticas: DFS, DFS MCN, DFS Clique MCN, DFS MCN DSTB y DFS MCN BEC. Estas son todas las versiones del traversal DFS guiado discutido en la Sección 5. Los pseudotrees de bordes cruzados utilizados para DCPOP-CE se generaron usando 5 heurísticas: MCN, LCN, MCN A-B, LCN A-B y LCSG A-B. Estas son todas las versiones del mejor recorrido discutido en la Sección 5. Tanto para DPOP como para DCPOP-CE elegimos la mejor pseudotree producida por sus respectivas 5 heurísticas para cada problema en el set. Para DCPOP-All, elegimos la mejor pseudotree producida por las 10 heurísticas para cada problema en el set. Para las métricas de CD y MD, el valor que se muestra es el número promedio de dimensiones. Para la métrica de PC, el valor que se muestra es el logaritmo natural del costo máximo de la ruta secuencial (ya que el valor real crece exponencialmente con la complejidad del problema). La fila final en ambas tablas es una medición de la mejora de DCPOP-ALL sobre DPOP. Para las métricas de CD y MD, el valor que se muestra es una reducción en el número de dimensiones. Para la métrica de PC, el valor mostrado es una reducción porcentual en el costo máximo de ruta secuencial (% = DP OP −DCP OP DCP OP ∗ 100). Observe que DCPOPall supera a DPOP en todas las métricas. Esto lógicamente se deduce de nuestra afirmación anterior de que dada la misma entrada, DCPOP funciona exactamente igual que DPOP. Por lo tanto, dada la elección entre los pseudotrees producidos por las 10 heurísticas, DCPOP-ALL siempre eliminará el algoritmo de alta densidad de densidad CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-ALL 7.62 6.49.3.66 12.72 11.36 5.05 Mejora 0.18 0.32 13% 0.62 0.98 36% Tabla 1: 20 Problemas de nodos Algoritmo de alta densidad CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-ECE 33.49 29.17 15.22 57.11 529.57 14.10 56.33 51.17 18.84 Mejora 1.00 2.78 104% 2.18 6.33 256% Tabla 2: 100 Problemas de nodos Figura 4: Tamaño de dimensión de cálculo Figura 5: Tamaño de dimensión del mensaje El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (Aamas 07) 747 Figura 6: Costo de ruta DCPOP Mejora Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 24 2476 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Tabla 3: Problemas de programación de reuniones realizan DPOP. Otra tendencia que notamos es que la mejora es mayor para problemas de alta densidad que los problemas de baja densidad. Mostramos esta tendencia con mayor detalle en las Figuras 4, 5 y 6. Observe cómo aumenta la mejora a medida que aumenta la complejidad del problema.7.2 Problema de programación de reuniones Además de nuestras pruebas DCOP genéricas iniciales, realizamos una serie de pruebas en el problema de programación de reuniones (MSP) como se describe en [6]. La configuración del problema incluye a varias personas que se agrupan en los departamentos. Cada persona debe asistir a un número específico de reuniones. Las reuniones se pueden celebrar dentro de los departamentos o entre los departamentos, y pueden asignarse a uno de los ocho espacios de tiempo. El MSP se asigna a una instancia de DCOP donde cada variable representa la ranura de tiempo a la que una persona específica asistirá a una reunión específica. Todas las variables que pertenecen a la misma persona tienen restricciones de exclusión mutua colocadas para que la persona no pueda asistir a más de una reunión durante el mismo intervalo de tiempo. Todas las variables que pertenecen a la misma reunión tienen restricciones de igualdad para que todos los participantes elijan la misma ranura de tiempo. Se colocan restricciones unarias en cada variable para tener en cuenta la valoración de una persona de cada reunión y intervalo de tiempo. Para nuestras pruebas generamos 100 problemas de muestra para cada combinación de agentes y reuniones. Los resultados se muestran en la Tabla 3. Los valores en las primeras cinco columnas representan (en orden de izquierda a derecha), el número total de agentes, el número total de reuniones, el número total de variables, el número total promedio de limitaciones y el IW mínimo promedio producido por unseudotree. Las últimas tres columnas muestran las mismas métricas que utilizamos para las instancias genéricas de DCOP, excepto que esta vez solo mostramos las mejoras de DCPOP-ALL sobre DPOP. El rendimiento es mejor en promedio para todas las instancias de MSP, pero nuevamente vemos mejoras más grandes para instancias problemáticas más complejas.8. Conclusiones y trabajos futuros presentamos un algoritmo completo y distribuido que resuelve instancias generales de DCOP utilizando arreglos de pseudotree cruzados. Nuestro algoritmo extiende el algoritmo DPOP agregando mensajes de propagación de utilidad adicionales e introduciendo el concepto de fusión de ramas durante la fase de propagación de servicios públicos. Nuestro algoritmo también permite que las asignaciones de valor ocurran en puntos de fusión de nivel superior para nodos de nivel inferior. Hemos demostrado que DCPOP extiende completamente DPOP realizando las mismas operaciones dada la misma entrada. También hemos demostrado a través de algunos ejemplos y datos experimentales que DCPOP puede lograr un mayor rendimiento para algunas instancias problemáticas al extender el conjunto de entrada permitido para incluir pseudotrees de bordes cruzados. Pusimos especial énfasis en el papel que juegan las heurísticas que trazan el borde en la generación de seudotrees. Hemos demostrado que la penalización de rendimiento es mínima para generar múltiples heurísticas, y que podemos elegir el pseudotree mejor generado en la complejidad lineal del espacio-tiempo. Dada la importancia de un buen seudotree para el rendimiento, el trabajo futuro incluirá nuevas heurísticas para encontrar mejores seudotrees. El trabajo futuro también incluirá la adaptación de las extensiones DPOP existentes [5, 7] que admiten diferentes dominios de problemas para su uso con DCPOP.9. Referencias [1] J. Liu y K. P. Sycara. Explotación de la estructura del problema para la optimización de restricciones distribuidas. En V. Lesser, Editor, Actas de la primera conferencia internacional sobre sistemas de múltiples agentes, páginas 246-254, San Francisco, CA, 1995. MIT Press.[2] P. J. Modi, H. Jung, M. Tambe, W.-M.Shen y S. Kulkarni. Un enfoque dinámico de satisfacción de restricción distribuida para la asignación de recursos. Notas de conferencia en informática, 2239: 685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe y M. Yokoo. Un método completo asincrónico para la optimización de restricciones distribuidas. En Aamas 03, 2003. [4] A. Petcu. Frodo: un marco para la optimización de restricciones abiertas/distribuidas. Informe técnico No. 2006/001 2006/001, Instituto Swiss Federal de Tecnología (EPFL), Lausana (Suiza), 2006. http://liawww.epfl.ch/frodo/.[5] A. Petcu y B. Faltings. A-DPOP: aproximaciones en la optimización distribuida. En el póster en CP 2005, páginas 802-806, Sitges, España, octubre de 2005. [6] A. Petcu y B. Faltings. DPOP: un método escalable para la optimización de restricciones multiagente. En IJCAI 05, páginas 266-271, Edimburgo, Escocia, agosto de 2005. [7] A. Petcu, B. Faltings y D. Parkes. M-DPOP: Implementación distribuida fiel de problemas eficientes de elección social. En Aamas 06, páginas 1397-1404, Hakodate, Japón, mayo de 2006. [8] G. Ushakov. Resolver problemas de programación de reuniones utilizando el procedimiento distribuido de pseudotree-optimización. Tesis de maestría, ´ECOLE POLYTECHNIQUE F´ED´ERALE DE LAUSANNE, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. Satisfacción de restricción distribuida para formalizar la resolución de problemas distribuidos. En la Conferencia Internacional sobre Sistemas de Computación Distribuida, páginas 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida y K. Kuwabara. El problema de satisfacción de la restricción distribuida: formalización y algoritmos. Conocimiento e ingeniería de datos, 10 (5): 673-685, 1998. 748 El sexto intl. Conf.en agentes autónomos y sistemas de múltiples agentes (AAMAS 07)",
    "original_sentences": [
        "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
        "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
        "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
        "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
        "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
        "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
        "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
        "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
        "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
        "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
        "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
        "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
        "CSPs were originally extended to distributed agent environments in [9].",
        "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
        "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
        "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
        "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
        "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
        "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
        "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
        "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
        "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
        "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
        "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
        "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
        "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
        "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
        "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
        "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
        "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
        "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
        "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
        "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
        "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
        "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
        "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
        "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
        "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
        "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
        "For this paper we only consider binary utility functions involving two variables.",
        "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
        "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
        "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
        "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
        "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
        "Figure 2: A cross-edged pseudotree.",
        "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
        "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
        "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
        "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
        "In a cross-edged pseudotree we designate certain edges as primary.",
        "The set of primary edges defines a spanning tree of the nodes.",
        "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
        "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
        "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
        "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
        "Next, various heuristics are used to arrange this graph into a pseudotree.",
        "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
        "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
        "This includes DFS, breadth-first search, and best-first search based traversals.",
        "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
        "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
        "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
        "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
        "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
        "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
        "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
        "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
        "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
        "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
        "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
        "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
        "A message containing this hypercube is sent to P(X).",
        "Agents located at non-leaf nodes wait for all messages from children to arrive.",
        "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
        "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
        "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
        "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
        "A message containing this hypercube is now sent to P(Y).",
        "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
        "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
        "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
        "The combined hypercube contains only values for the domain for Z.",
        "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
        "A value propagation message with this assignment is sent to each node in C(Z).",
        "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
        "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
        "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
        "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
        "The first phase generates the cross-edged pseudotree for the DCOP instance.",
        "The second phase merges branches and propagates the utility hypercubes.",
        "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
        "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
        "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
        "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
        "A description of this method and the pseudotree selection process appears in Section 5.",
        "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
        "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
        "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
        "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
        "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
        "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
        "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
        "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
        "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
        "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
        "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
        "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
        "When a node Y receives utility propagation messages from all of The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
        "The merged branch information structure accumulates the number of merged branches for X.",
        "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
        "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
        "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
        "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
        "In the second phase Node B receives two utility propagation messages.",
        "The first comes from node C and includes dimensions for domains E, B, and A.",
        "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
        "The second comes from node D and includes dimensions for domains E and B.",
        "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
        "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
        "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
        "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
        "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
        "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
        "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
        "Thus any node that is a merge point will choose assignments for a domain other than its own.",
        "These assignments are then passed down the primary edge hierarchy.",
        "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
        "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
        "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
        "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
        "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
        "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
        "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
        "Thus all value propagation assignments are chosen at the node of the assignment domain.",
        "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
        "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
        "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
        "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
        "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
        "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
        "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
        "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
        "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
        "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
        "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
        "Thus X has utility information about all of the utility functions of which Y is a part.",
        "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
        "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
        "The second phase sends one value assignment message to each C(X).",
        "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
        "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
        "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
        "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
        "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
        "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
        "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
        "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
        "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
        "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
        "To take this measurement we first store the total computation size for each node during phase two and three.",
        "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
        "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
        "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
        "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
        "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
        "We acknowledge 744 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
        "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
        "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
        "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
        "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
        "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
        "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
        "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
        "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
        "Instead, messages include dimensional and branch information but no utility hypercubes.",
        "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
        "The root then broadcasts the total complexity for that heuristic to all nodes.",
        "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
        "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
        "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
        "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
        "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
        "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
        "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
        "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
        "Note that in this algorithm each node only exchanges its best value with its neighbors.",
        "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
        "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
        "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
        "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
        "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
        "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
        "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
        "The place operation is at most O(V ) because of the sent messages.",
        "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
        "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
        "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
        "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
        "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
        "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
        "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
        "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
        "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
        "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
        "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
        "In Figure 3(a) we have a DCOP instance with six nodes.",
        "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
        "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
        "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
        "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
        "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
        "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
        "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
        "In addition each of these nodes has node A as its parent.",
        "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
        "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
        "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
        "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
        "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
        "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
        "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
        "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
        "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
        "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
        "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
        "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
        "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
        "The generator then created binary constraints until each variable reached its maximum number of constraints.",
        "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
        "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
        "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
        "Results are shown for the first set in Table 1 and for the second set in Table 2.",
        "For the two problem sets we split the cases into low density and high density categories.",
        "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
        "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
        "High density problems consist of the remainder of the problem sets.",
        "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
        "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
        "These are all versions of the guided DFS traversal discussed in Section 5.",
        "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
        "These are all versions of the best-first traversal discussed in Section 5.",
        "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
        "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
        "For the CD and MD metrics the value shown is the average number of dimensions.",
        "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
        "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
        "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
        "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
        "Notice that DCPOPAll outperforms DPOP on all metrics.",
        "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
        "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
        "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
        "We show this trend in greater detail in Figures 4, 5, and 6.",
        "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
        "The problem setup includes a number of people that are grouped into departments.",
        "Each person must attend a specified number of meetings.",
        "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
        "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
        "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
        "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
        "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
        "For our tests we generated 100 sample problems for each combination of agents and meetings.",
        "Results are shown in Table 3.",
        "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
        "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
        "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
        "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
        "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
        "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
        "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
        "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
        "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
        "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
        "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
        "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
        "REFERENCES [1] J. Liu and K. P. Sycara.",
        "Exploiting problem structure for distributed constraint optimization.",
        "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
        "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
        "A dynamic distributed constraint satisfaction approach to resource allocation.",
        "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
        "An asynchronous complete method for distributed constraint optimization.",
        "In AAMAS 03, 2003. [4] A. Petcu.",
        "Frodo: A framework for open/distributed constraint optimization.",
        "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
        "A-dpop: Approximations in distributed optimization.",
        "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
        "Dpop: A scalable method for multiagent constraint optimization.",
        "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
        "M-dpop: Faithful distributed implementation of efficient social choice problems.",
        "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
        "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
        "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
        "Distributed constraint satisfaction for formalizing distributed problem solving.",
        "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
        "The distributed constraint satisfaction problem: Formalization and algorithms.",
        "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
        "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
    ],
    "error_count": 0,
    "keys": {
        "distributed constraint optimization": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete <br>distributed constraint optimization</br> Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT <br>distributed constraint optimization</br> (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the <br>distributed constraint optimization</br> Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A <br>distributed constraint optimization</br> Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for <br>distributed constraint optimization</br>.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for <br>distributed constraint optimization</br>.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/<br>distributed constraint optimization</br>.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un método completo de \"optimización de restricciones distribuidas\" para arreglos de pseudotreos no tradicionales ∗ James Atlas Computer and Information Sciences University of Delaware Newark, de 19716 atlas@cis.udel.edu Keith Decker Computadora e ciencias de la información Universidad de Delaware Newark, de 19716 Decker@cis.udel.edu Abstract \"Optimización de restricciones distribuidas\" (DCOP) es un marco general que puede modelar problemas complejos en sistemas de agentes múltiples.",
                "Esta extensión al enfoque DISCSP original se ha vuelto popular en los sistemas de múltiples agentes, y se ha etiquetado como el problema de la \"optimización de restricciones distribuidas\" (DCOP) [1].",
                "Un problema de \"optimización de restricciones distribuidas\" con N nodos y restricciones M consiste en la tuple <x, d, u> donde: • x = {x1, .., xn} es un conjunto de variables, cada una asignada a un agente único• d = {d1, .., dn} es un conjunto de dominios finitos para cada variable • u = {u1, .., um} es un conjunto de funciones de utilidad, de modo que cada función implica un subconjunto de variables en x y defineUna utilidad para cada combinación de valores entre estas variables, una solución óptima a una instancia de DCOP consiste en una asignación de valores en D a X de modo que la suma de utilidades en U es máxima.",
                "Explotación de la estructura del problema para la \"optimización de restricciones distribuidas\".",
                "Un método completo asíncrono para \"optimización de restricciones distribuidas\".",
                "Frodo: un marco para la optimización de restricciones abiertas/\"distribuidas\"."
            ],
            "translated_text": "",
            "candidates": [
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "Optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "optimización de restricciones distribuidas",
                "distribuidas"
            ],
            "error": []
        },
        "pseudotree arrangement": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional <br>pseudotree arrangement</br> no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional <br>pseudotree arrangement</br> for the DCOP instance (c) A cross-edged <br>pseudotree arrangement</br> for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional <br>pseudotree arrangement</br> for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional <br>pseudotree arrangement</br> for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged <br>pseudotree arrangement</br> in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional <br>pseudotree arrangement</br> can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best <br>pseudotree arrangement</br> is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Usando una \"disposición de seudotree\" tradicional, no hay nodos que tengan ramificaciones o hijos de ramas, ya que todos los bordes son bordes o bordes de árboles.",
                "Este es un gráfico bipartito con cada partición completamente conectada a la otra (a) (b) (c) Figura 3: (a) la instancia DCOP (b) una \"disposición de seudotree\" tradicional para la instancia DCOP (c) una cruzada\"Arreglo de seudotree\" bordado para la partición de instancia DCOP.",
                "En la Figura 3 (b) vemos una \"disposición de seudotree\" tradicional para esta instancia de DCOP.",
                "Por lo tanto, cualquier \"disposición de seudotree\" tradicional para esta instancia de DCOP debe tomar la forma de la Figura 3 (b).",
                "Podemos ver que el nodo de superposición F-B y F-A del nodo C. C. El nodo C también tiene un padre E, y un borde posterior con D. usando el algoritmo DPOP original (o DCPOP ya que son idénticos en este caso), encontramosQue el cálculo en el nodo C implica cinco dominios: A, B, C, D y E. En contraste, la \"disposición de seudotree\" transversal en la Figura 3 (c) requiere solo un máximo de cuatro dominios en cualquier cálculo durante DCPOP.",
                "Dado que no se puede crear una mejor \"disposición de pseudotree\" tradicional utilizando una heurística transversal de borde, hemos demostrado que DCPOP puede superar a DPOP incluso si usamos la pseudotree óptima que se encuentra a través de la transferencia de borde.",
                "En la práctica, dado que encontrar la mejor \"disposición de seudotree\" es NP-Hard, encontramos que las heurísticas que producen pseudotrees de filo cruzado a menudo producen tamaños de cálculo y mensajes significativamente más pequeños.7."
            ],
            "translated_text": "",
            "candidates": [
                "disposición de pseudotree",
                "disposición de seudotree",
                "disposición de pseudotree",
                "disposición de seudotree",
                "Arreglo de seudotree",
                "disposición de pseudotree",
                "disposición de seudotree",
                "disposición de pseudotree",
                "disposición de seudotree",
                "disposición de pseudotree",
                "disposición de seudotree",
                "disposición de pseudotree",
                "disposición de pseudotree",
                "Arreglo de seudotree",
                "disposición de seudotree"
            ],
            "error": []
        },
        "multi-agent system": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in <br>multi-agent system</br>s.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, <br>multi-agent system</br>s became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in <br>multi-agent system</br>s, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un método completo de optimización de restricciones distribuidas para arreglos de pseudotreos no tradicionales ∗ James Atlas Computer and Information Sciences de Delaware Newark, de 19716 atlas@cis.udel.edu Keith Decker Computadora e ciencias de la información Universidad de Delaware Newark, DE 19716 Decker@cis.UDEL.EDU Optimización de restricciones distribuidas abstractas (DCOP) es un marco general que puede modelar problemas complejos en el \"sistema de múltiples agentes\".",
                "Con el advenimiento de la IA distribuida, el \"sistema de múltiples agentes\" se convirtió en una forma popular de modelar las complejas interacciones y la coordinación requeridas para resolver problemas distribuidos.",
                "Esta extensión al enfoque DISCSP original se ha vuelto popular en los \"sistemas de múltiples agentes\", y se ha etiquetado como el problema de optimización de restricciones distribuidas (DCOP) [1]."
            ],
            "translated_text": "",
            "candidates": [
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistema de múltiples agentes",
                "sistemas de múltiples agentes"
            ],
            "error": []
        },
        "agent": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-<br>agent</br> systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-<br>agent</br> systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed <br>agent</br> environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for <br>agent</br> systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-<br>agent</br> systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique <br>agent</br> • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the <br>agent</br> at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each <br>agent</br> knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the <br>agent</br> at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the <br>agent</br> at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the <br>agent</br> at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the <br>agent</br> at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the <br>agent</br> at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each <br>agent</br> knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an <br>agent</br> at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the <br>agent</br> at the root node Z has received all messages from its children.",
                "At this point the <br>agent</br> at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The <br>agent</br> at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The <br>agent</br> at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each <br>agent</br> Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to <br>agent</br> view 29: Xi ← v ∗ i =Choose optimal(<br>agent</br> view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-<br>agent</br> Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-<br>agent</br> Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Un método completo de optimización de restricciones distribuidas para arreglos de pseudotreos no tradicionales ∗ James Atlas Computer and Information Sciences de Delaware Newark, de 19716 atlas@cis.udel.edu Keith Decker Computadora e ciencias de la información Universidad de Delaware Newark, DE 19716 Decker@cis.UDEL.EDU Optimización de restricciones distribuidas abstractas (DCOP) es un marco general que puede modelar problemas complejos en los sistemas múltiples de \"agente\".",
                "Con el advenimiento de la IA distribuida, los sistemas multi-\"agentes\" se convirtieron en una forma popular de modelar las complejas interacciones y la coordinación requeridas para resolver problemas distribuidos.",
                "Los CSP se extendieron originalmente a los entornos distribuidos de \"agente\" en [9].",
                "Muchos dominios para los sistemas de \"agente\", especialmente la coordinación del trabajo en equipo, la programación distribuida y las redes de sensores, implican problemas demasiado restringidos que son difíciles o imposibles de satisfacer para cada restricción.",
                "Esta extensión al enfoque DISCSP original se ha vuelto popular en los sistemas múltiples de \"agente\", y se ha etiquetado como el problema de optimización de restricciones distribuidas (DCOP) [1].",
                "Un problema de optimización de restricciones distribuido con nodos n y restricciones M consiste en la tuple <x, d, u> donde: • x = {x1, .., xn} es un conjunto de variables, cada una asignada a un \"agente\" único \"• d = {d1, .., dn} es un conjunto de dominios finitos para cada variable • u = {u1, .., um} es un conjunto de funciones de utilidad, de modo que cada función implica un subconjunto de variables en x y defineUna utilidad para cada combinación de valores entre estas variables, una solución óptima a una instancia de DCOP consiste en una asignación de valores en D a X de modo que la suma de utilidades en U es máxima.",
                "Conf.En agentes autónomos y sistemas múltiples \"agentes\" (AAMAS 07), los algoritmos de corriente generalmente tienen una fase de pre-ejecución para generar una pseudotree tradicional a partir de una instancia general de DCOP.",
                "La tercera fase elige una tarea para cada dominio de una manera de arriba hacia abajo, comenzando con el \"agente\" en el nodo raíz.",
                "Al final de la primera fase, cada \"agente\" conoce a sus padres, hijos, pseudo-padres y pseudo-niños.3.1 Los agentes de propagación de servicios públicos ubicados en nodos de hoja en el pseudotree comienzan el proceso calculando un hipercubo local de utilidad.",
                "Una vez que el \"agente\" en el nodo Y tiene todos los mensajes de utilidad, calcula su hipercube de utilidad local que incluye dominios para P (Y), PP (Y) e Y.",
                "Esta fase de propagación basada en programación dinámica continúa hasta que el \"agente\" en el nodo raíz del pseudotree ha recibido todos los mensajes de sus hijos.3.2 Propagación del valor La propagación del valor comienza cuando el \"agente\" en el nodo raíz Z ha recibido todos los mensajes de sus hijos.",
                "En este punto, el \"agente\" en el nodo Z simplemente elige la asignación para su dominio que tiene la mejor utilidad.",
                "La tercera fase elige asignaciones para dominios en los puntos de fusión de rama y de una manera de arriba hacia abajo, comenzando con el \"agente\" en el nodo raíz.",
                "Al final de la primera fase, cada \"agente\" conoce a sus padres, hijos, pseudoparentes, pseudo-childos, sucursales y chíbles de ramas.4.1 Las ramas de fusión y la propagación de utilidad en el algoritmo DPOP original Un nodo X solo tenía funciones de utilidad que involucraban a su padre y sus pseudo-padres.",
                "Como en la fase original de propagación de utilidad DPOP, un \"agente\" en el nodo Leaf X envía un mensaje de propagación de utilidad a su padre.",
                "Conf.En agentes autónomos y sistemas múltiples de \"agente\" (aamas 07) 743 sus hijos y children, fusiona cualquier ramas con el mismo nodo de origen X.",
                "Este enfoque perezoso para unirse ayuda a reducir los tamaños de mensajes.4.2 Propagación del valor Como en DPOP, la propagación del valor comienza cuando el \"agente\" en el nodo raíz Z ha recibido todos los mensajes de sus hijos.",
                "En este punto, el \"agente\" en el nodo Z elige la asignación para su dominio que tiene la mejor utilidad.",
                "El \"agente\" en el nodo X ahora puede elegir correctamente la asignación con máxima utilidad para su propio dominio.",
                "El \"agente\" en el nodo X ahora puede elegir correctamente las asignaciones con la utilidad máxima para los dominios de X e Y. 4.4 Análisis de complejidad La primera fase de DCPOP envía un mensaje a cada P (x), PP (x) y BP ((BP ((X).",
                "Conf.en agentes autónomos y algoritmo de sistemas múltiples \"agentes\" (aamas 07) algoritmo DCPOP 1: dcpop (x; d; u) Cada \"agente\" XI ejecuta: fase 1: creación de pseudotree 2: elección líder de todos xj ∈ X 3 3 3 3: El líder electo inicia la creación de pseudotree 4: después, xi conoce p (xi), pp (xi), bp (xi), c (xi), bc (xi) y pc (xi) fase 2: propagación de mensajes utilizado 5: si| BP (xi) |> 0 luego 6: Branchxi ← | BP (xi) |+ 1 7: Para todos los xk ∈Bp (xi) do 8: utilxi (xk) ← Compute utils (xi, xk) 9: enviar mensaje (xk, utilxi (xk), branchxi) 10: if | c (xi)",
                "Xi es un nodo de hoja) luego 11: utilxi (p (xi)) ← Computed Utils (p (xi), pp (xi)) para todos los pp (xi) 12: enviar mensaje (p (xi), utilxi (p (p (p (p (p (p (p (p (p (Xi)), Branchxi) 13: Enviar mensaje (pp (xi), utilizar vacío, rama vacía) a todos los pp (xi) 14: activar el controlador de mensajes utilizado () Fase 3: Valor Propagación de mensajes 15: Activar Valor Message Handler ()Handler de mensajes del algoritmo final (xk, utilxk (xi), branchxk) 16: almacenar utilxk (xi), branchxk (xi) 17: si los mensajes de todos los niños y los niños de la rama llegaron entonces 18: para todos bj ∈Branch (xi)do 19: si bj se fusiona, entonces 20: une a todos los hipercubos donde bj ∈Util (xi) 21: elimine bj del hipercubo unido 22: si p (xi) == nulo (eso significa xi es la raíz) entonces 23: v∗ i ← Elija óptimo (nulo) 24: envío de valor (xi, v ∗ i) a todos c (xi) 25: else 26: utilxi (p (xi)) ← Compute Utils (P (xi), pp (xi)) 27: Enviar mensaje (p (xi), utilxi (p (xi)), branchxi (p (xi))) Valor Mensaje Handler (valuexi, p (xi)) 28: Agregue todo xk ← v ∗ k ∈Valuexi,P (xi) a \"agente\" vista 29: xi ← v ∗ i = elige óptimo (\"agente\" vista) 30: Enviar valorxl, xi a todos xl ∈C (xi) que en los problemas del mundo real la generación de la pseudotree tieneUn impacto significativo en el rendimiento real.",
                "Conf.en agentes autónomos y sistemas múltiples de \"agente\" (AAMAS 07) 745 Algoritmo 2 Distribuido el mejor algoritmo de búsqueda raíz ← Electleader Elective (root, ∅) lugar (nodo, parent) nodo.∪ Mensaje de colocación de envío de padres (nodo, nodo.ancestors) a todos los vecinos del nodo siguiente (actual, anterior) Si la corriente no se coloca, luego coloque (actual, anterior) Siguiente (actual, ∅) más mejor ← GetBestneighbor (actual, anterior, anterior)Si es mejor = ∅ entonces si anterior = ∅ entonces termina, todos los nodos se colocan a continuación (anterior, ∅) más siguiente (mejor, actual) getBestneighbor (actual, anterior) mejor ← ∅;puntaje ← 0 para todos n ∈ Current. Neighbors do si n!= Anterior entonces si n se coloca, entonces nscore ← getBestneighbor (n, actual) más nscore ← Evalúe (actual, n) Si nscore> anota y luego obtiene ← nscore mejor ← n devuelve mejor, puntaje nodos, por lo que tiene o (v) recursiones.",
                "Conf.En los agentes autónomos y los sistemas múltiples \"agentes\" (AAMAS 07) Las métricas de rendimiento existentes para los algoritmos DCOP incluyen el número total de mensajes, ciclos de reloj sincrónicos y tamaño de mensaje.",
                "Conf.en agentes autónomos y sistemas múltiples de \"agente\" (AAMAS 07) 747 Figura 6: Costo de ruta DCPOP Mejora Ag Mtg Vars const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9%50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Tabla 3: Reunión de problemas de programación de la programación.",
                "En V. Lesser, Editor, Actas de la Primera Conferencia Internacional sobre Sistemas Multi-\"Agentes\", páginas 246-254, San Francisco, CA, 1995.",
                ""
            ],
            "translated_text": "",
            "candidates": [
                "agente",
                "agente",
                "agente",
                "agentes",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agentes",
                "agente",
                "agente",
                "agente",
                "agente",
                "Agent Agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "|= 0 (es decir, agente",
                "agentes",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agente",
                "agentes",
                "agente",
                "agente",
                "Agente",
                "Agentes",
                "",
                "agentes"
            ],
            "error": []
        },
        "maximum sequential path cost": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the <br>maximum sequential path cost</br> through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the <br>maximum sequential path cost</br> through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The <br>maximum sequential path cost</br> is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the <br>maximum sequential path cost</br> (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The <br>maximum sequential path cost</br> is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the <br>maximum sequential path cost</br> (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the <br>maximum sequential path cost</br> (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Comparamos nuestro algoritmo con DPOP utilizando varias métricas, incluido el ancho inducido de los pseudotrees, la dimensionalidad máxima de los mensajes y el cálculo, y el \"costo máximo de ruta secuencial\" a través del algoritmo.",
                "Introducimos una medición adicional del \"costo máximo de ruta secuencial\" a través del algoritmo.",
                "El \"costo máximo de ruta secuencial\" es igual a la suma de la ruta más larga en cada DAG desde la raíz hasta cualquier nodo de hoja.5.",
                "También introdujimos el \"costo máximo de ruta secuencial\" (PC) como una medición de la cantidad máxima de paralelismo lograble por el algoritmo.",
                "El \"costo máximo de ruta secuencial\" es igual a la suma de los cálculos realizados en la ruta más larga desde la raíz hasta cualquier nodo de hoja.",
                "Para la métrica de PC, el valor que se muestra es el logaritmo natural del \"costo máximo de ruta secuencial\" (ya que el valor real crece exponencialmente con la complejidad del problema).",
                "Para la métrica de PC, el valor que se muestra es una reducción porcentual en el \"costo máximo de ruta secuencial\" (% = dp OP -DCP OP DCP OP ∗ 100)."
            ],
            "translated_text": "",
            "candidates": [
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial",
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial",
                "Costo máximo de ruta secuencial",
                "costo máximo de ruta secuencial",
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial",
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial",
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial",
                "costo de ruta secuencial máximo",
                "costo máximo de ruta secuencial"
            ],
            "error": []
        },
        "edge-traversal heuristic": {
            "translated_key": "Heurística transversal de borde",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an <br>edge-traversal heuristic</br>, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dado que no se puede crear una mejor disposición de pseudotree tradicional utilizando una \"heurística transversal de borde\", hemos demostrado que DCPOP puede superar a DPOP incluso si usamos la pseudotree óptima que se encuentra a través del trasionario de borde."
            ],
            "translated_text": "",
            "candidates": [
                "Heurística transversal de borde",
                "heurística transversal de borde"
            ],
            "error": []
        },
        "cross-edged pseudotree": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a <br>cross-edged pseudotree</br>.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed <br>cross-edged pseudotree</br> Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A <br>cross-edged pseudotree</br>.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A <br>cross-edged pseudotree</br> is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a <br>cross-edged pseudotree</br> with a cross-edge (D-E).",
                "In a <br>cross-edged pseudotree</br> we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a <br>cross-edged pseudotree</br> in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the <br>cross-edged pseudotree</br> for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the <br>cross-edged pseudotree</br>.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given <br>cross-edged pseudotree</br>.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the <br>cross-edged pseudotree</br> and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed <br>cross-edged pseudotree</br>, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed <br>cross-edged pseudotree</br> can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given <br>cross-edged pseudotree</br> in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first <br>cross-edged pseudotree</br> heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a <br>cross-edged pseudotree</br> outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A <br>cross-edged pseudotree</br> arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the <br>cross-edged pseudotree</br> arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using <br>cross-edged pseudotree</br> arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Probamos que para algunas instancias problemáticas no es posible generar una pseudotree tradicional utilizando heurísticas de transferencia de bordes que superarán a una \"pseudotree cruzada\".",
                "Luego mostramos que nuestro procedimiento distribuido de optimización de \"pseudotree de filo cruzado\" (DCPOP) funciona significativamente mejor en la práctica que el algoritmo DPOP original para algunas instancias problemáticas.",
                "Figura 2: Una \"Pseudotree de bordes cruzados\".",
                "Un \"pseudotree de bordes cruzados\" es una pseudotree tradicional con la adición de bordes cruzados.",
                "La Figura 2 muestra una \"pseudotree cruzada\" con un borde cruzado (D-E).",
                "En un \"pseudotree de bordes cruzados\" designamos ciertos bordes como primarios.",
                "Nuestro algoritmo DCPOP genera un \"Pseudotree de bordes cruzados\" de la misma manera.",
                "La primera fase genera la \"Pseudotree de bordes cruzados\" para la instancia de DCOP.",
                "La complejidad del tamaño del mensaje de cálculo y utilidad en DCPOP no corresponde directamente al ancho inducido del \"Pseudotree de filo cruzado\".",
                "En su lugar, utilizamos un método de tiempo polinomial para calcular el tamaño máximo de cálculo y mensaje de utilidad para un \"pseudotree de filo cruzado\" dado.",
                "Por lo tanto, DCPOP produce un número lineal de mensajes con respecto al número de bordes (funciones de utilidad) en el \"Pseudotree de filo cruzado\" y la instancia DCOP original.",
                "En una \"pseudotree\" mal construida \", el número de ramas superpuestas en el nodo X puede ser tan grande como el número total de descendientes de X.",
                "Sin embargo, en la práctica, un \"pseudotree de filo cruzado bien bien construido puede lograr resultados mucho mejores.",
                "El algoritmo DCPOP real tiene la peor complejidad exponencial de los casos, pero podemos calcular el tamaño máximo del mensaje, el tamaño de la cálculo y el costo de ruta secuencial para una \"pseudotree cruzada\" en complejidad lineal de espacio-tiempo.",
                "Las heurísticas basadas en DFS utilizadas en nuestros experimentos provienen del trabajo realizado en [4, 8].5.1 La mejor primera heurística \"Pseudotree\" Heuristic, la heurística utilizada para generar pseudotrees de bordes cruzados realizan una mejor transversal transversal.",
                "Ahora demostraremos que existe una instancia de DCOP para la cual un \"seudotree de bordes cruzados\" supera a todos los seudotrees tradicionales posibles (basados en heurísticas de transferencia de bordes).",
                "Este es un gráfico bipartito con cada partición totalmente conectada a la otra (a) (b) (c) Figura 3: (a) la instancia de DCOP (b) Una disposición de seudotree tradicional para la instancia DCOP (c) A \"cruzado cruzadoPseudotree \"Arreglo para la partición de instancia de DCOP.",
                "Podemos ver que el nodo de superposición F-B y F-A del nodo C. C. El nodo C también tiene un padre E, y un borde posterior con D. usando el algoritmo DPOP original (o DCPOP ya que son idénticos en este caso), encontramosQue el cálculo en el nodo C implica cinco dominios: A, B, C, D y E. En contraste, la disposición de \"pseudotree de filo cruzado\" en la Figura 3 (c) requiere solo un máximo de cuatro dominios en cualquier cálculo durante DCPOP.",
                "Conclusiones y trabajos futuros presentamos un algoritmo completo y distribuido que resuelve las instancias generales de DCOP utilizando los arreglos de \"pseudotree cruzado\"."
            ],
            "translated_text": "",
            "candidates": [
                "seudotree de bordes cruzados",
                "pseudotree cruzada",
                "seudotree de bordes cruzados",
                "pseudotree de filo cruzado",
                "seudotree de bordes cruzados",
                "Pseudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "pseudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "pseudotree cruzada",
                "seudotree de bordes cruzados",
                "pseudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "Pseudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "Pseudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "Pseudotree de filo cruzado",
                "seudotree de bordes cruzados",
                "pseudotree de filo cruzado",
                "seudotree de bordes cruzados",
                "Pseudotree de filo cruzado",
                "Pseudotree de bordes cruzados",
                "pseudotree",
                "seudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "pseudotree cruzada",
                "seudotree de bordes cruzados",
                "Pseudotree",
                "seudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "seudotree de bordes cruzados",
                "cruzado cruzadoPseudotree ",
                "seudotree de bordes cruzados",
                "pseudotree de filo cruzado",
                "seudotree de bordes cruzados",
                "pseudotree cruzado"
            ],
            "error": []
        },
        "job shop scheduling": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included <br>job shop scheduling</br> [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Los primeros dominios para problemas de satisfacción de restricciones distribuidas (DISCSP) incluyeron \"programación de tiendas de trabajo\" [1] y asignación de recursos [2]."
            ],
            "translated_text": "",
            "candidates": [
                "Programación de la tienda de empleo",
                "programación de tiendas de trabajo"
            ],
            "error": []
        },
        "resource allocation": {
            "translated_key": "Asignación de recursos",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and <br>resource allocation</br> [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to <br>resource allocation</br>.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Los primeros dominios para problemas de satisfacción de restricciones distribuidas (DISCSP) incluyeron la programación de la tienda de trabajo [1] y la \"asignación de recursos\" [2].",
                "Un enfoque dinámico de satisfacción de restricción distribuida para la \"asignación de recursos\"."
            ],
            "translated_text": "",
            "candidates": [
                "Asignación de recursos",
                "asignación de recursos",
                "Asignación de recursos",
                "asignación de recursos"
            ],
            "error": []
        },
        "teamwork coordination": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially <br>teamwork coordination</br>, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Muchos dominios para los sistemas de agentes, especialmente la \"coordinación del trabajo en equipo\", la programación distribuida y las redes de sensores, implican problemas demasiado restringidos que son difíciles o imposibles de satisfacer para cada restricción."
            ],
            "translated_text": "",
            "candidates": [
                "Coordinación de trabajo en equipo",
                "coordinación del trabajo en equipo"
            ],
            "error": []
        },
        "multi-valued utility function": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into <br>multi-valued utility function</br>s.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Los enfoques recientes para resolver problemas en estos dominios se basan en técnicas de optimización que mapean las limitaciones en la \"función de utilidad de valores múltiples\"."
            ],
            "translated_text": "",
            "candidates": [
                "función de utilidad múltiple",
                "función de utilidad de valores múltiples"
            ],
            "error": []
        },
        "global utility": {
            "translated_key": "utilidad global",
            "is_in_text": true,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of <br>global utility</br>.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En lugar de encontrar una tarea que satisfaga todas las limitaciones, estos enfoques encuentran una tarea que produce un alto nivel de \"utilidad global\"."
            ],
            "translated_text": "",
            "candidates": [
                "utilidad global",
                "utilidad global"
            ],
            "error": []
        },
        "distribute constraint satisfaction and optimization": {
            "translated_key": "Distribuir la satisfacción y la optimización de restricciones",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "multi-agent coordination": {
            "translated_key": "coordinación de múltiples agentes",
            "is_in_text": false,
            "original_annotated_sentences": [
                "A Complete Distributed Constraint Optimization Method For Non-Traditional Pseudotree Arrangements∗ James Atlas Computer and Information Sciences University of Delaware Newark, DE 19716 atlas@cis.udel.edu Keith Decker Computer and Information Sciences University of Delaware Newark, DE 19716 decker@cis.udel.edu ABSTRACT Distributed Constraint Optimization (DCOP) is a general framework that can model complex problems in multi-agent systems.",
                "Several current algorithms that solve general DCOP instances, including ADOPT and DPOP, arrange agents into a traditional pseudotree structure.",
                "We introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements.",
                "Our algorithm correctly solves DCOP instances for pseudotrees that include edges between nodes in separate branches.",
                "The algorithm also solves instances with traditional pseudotree arrangements using the same procedure as DPOP.",
                "We compare our algorithm with DPOP using several metrics including the induced width of the pseudotrees, the maximum dimensionality of messages and computation, and the maximum sequential path cost through the algorithm.",
                "We prove that for some problem instances it is not possible to generate a traditional pseudotree using edge-traversal heuristics that will outperform a cross-edged pseudotree.",
                "We use multiple heuristics to generate pseudotrees and choose the best pseudotree in linear space-time complexity.",
                "For some problem instances we observe significant improvements in message and computation sizes compared to DPOP.",
                "Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent Systems General Terms Algorithms 1.",
                "INTRODUCTION Many historical problems in the AI community can be transformed into Constraint Satisfaction Problems (CSP).",
                "With the advent of distributed AI, multi-agent systems became a popular way to model the complex interactions and coordination required to solve distributed problems.",
                "CSPs were originally extended to distributed agent environments in [9].",
                "Early domains for distributed constraint satisfaction problems (DisCSP) included job shop scheduling [1] and resource allocation [2].",
                "Many domains for agent systems, especially teamwork coordination, distributed scheduling, and sensor networks, involve overly constrained problems that are difficult or impossible to satisfy for every constraint.",
                "Recent approaches to solving problems in these domains rely on optimization techniques that map constraints into multi-valued utility functions.",
                "Instead of finding an assignment that satisfies all constraints, these approaches find an assignment that produces a high level of global utility.",
                "This extension to the original DisCSP approach has become popular in multi-agent systems, and has been labeled the Distributed Constraint Optimization Problem (DCOP) [1].",
                "Current algorithms that solve complete DCOPs use two main approaches: search and dynamic programming.",
                "Search based algorithms that originated from DisCSP typically use some form of backtracking [10] or bounds propagation, as in ADOPT [3].",
                "Dynamic programming based algorithms include DPOP and its extensions [5, 6, 7].",
                "To date, both categories of algorithms arrange agents into a traditional pseudotree to solve the problem.",
                "It has been shown in [6] that any constraint graph can be mapped into a traditional pseudotree.",
                "However, it was also shown that finding the optimal pseudotree was NP-Hard.",
                "We began to investigate the performance of traditional pseudotrees generated by current edge-traversal heuristics.",
                "We found that these heuristics often produced little parallelism as the pseudotrees tended to have high depth and low branching factors.",
                "We suspected that there could be other ways to arrange the pseudotrees that would provide increased parallelism and smaller message sizes.",
                "After exploring these other arrangements we found that cross-edged pseudotrees provide shorter depths and higher branching factors than the traditional pseudotrees.",
                "Our hypothesis was that these crossedged pseudotrees would outperform traditional pseudotrees for some problem types.",
                "In this paper we introduce an extension to the DPOP algorithm that handles an extended set of pseudotree arrangements which include cross-edged pseudotrees.",
                "We begin with a definition of 741 978-81-904262-7-5 (RPS) c 2007 IFAAMAS DCOP, traditional pseudotrees, and cross-edged pseudotrees.",
                "We then provide a summary of the original DPOP algorithm and introduce our DCPOP algorithm.",
                "We discuss the complexity of our algorithm as well as the impact of pseudotree generation heuristics.",
                "We then show that our Distributed Cross-edged Pseudotree Optimization Procedure (DCPOP) performs significantly better in practice than the original DPOP algorithm for some problem instances.",
                "We conclude with a selection of ideas for future work and extensions for DCPOP. 2.",
                "PROBLEM DEFINITION DCOP has been formalized in slightly different ways in recent literature, so we will adopt the definition as presented in [6].",
                "A Distributed Constraint Optimization Problem with n nodes and m constraints consists of the tuple < X, D, U > where: • X = {x1,..,xn} is a set of variables, each one assigned to a unique agent • D = {d1,..,dn} is a set of finite domains for each variable • U = {u1,..,um} is a set of utility functions such that each function involves a subset of variables in X and defines a utility for each combination of values among these variables An optimal solution to a DCOP instance consists of an assignment of values in D to X such that the sum of utilities in U is maximal.",
                "Problem domains that require minimum cost instead of maximum utility can map costs into negative utilities.",
                "The utility functions represent soft constraints but can also represent hard constraints by using arbitrarily large negative values.",
                "For this paper we only consider binary utility functions involving two variables.",
                "Higher order utility functions can be modeled with minor changes to the algorithm, but they also substantially increase the complexity. 2.1 Traditional Pseudotrees Pseudotrees are a common structure used in search procedures to allow parallel processing of independent branches.",
                "As defined in [6], a pseudotree is an arrangement of a graph G into a rooted tree T such that vertices in G that share an edge are in the same branch in T. A back-edge is an edge between a node X and any node which lies on the path from X to the root (excluding Xs parent).",
                "Figure 1 shows a pseudotree with four nodes, three edges (A-B, B-C, BD), and one back-edge (A-C).",
                "Also defined in [6] are four types of relationships between nodes exist in a pseudotree: • P(X) - the parent of a node X: the single node higher in the pseudotree that is connected to X directly through a tree edge • C(X) - the children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through tree edges • PP(X) - the pseudo-parents of a node X: the set of nodes higher in the pseudotree that are connected to X directly through back-edges (In Figure 1, A = PP(C)) • PC(X) - the pseudo-children of a node X: the set of nodes lower in the pseudotree that are connected to X directly through back-edges (In Figure 1, C = PC(A)) Figure 1: A traditional pseudotree.",
                "Solid line edges represent parent-child relationships and the dashed line represents a pseudo-parent-pseudo-child relationship.",
                "Figure 2: A cross-edged pseudotree.",
                "Solid line edges represent parent-child relationships, the dashed line represents a pseudoparent-pseudo-child relationship, and the dotted line represents a branch-parent-branch-child relationship.",
                "The bolded node, B, is the merge point for node E. 2.2 Cross-edged Pseudotrees We define a cross-edge as an edge from node X to a node Y that is above X but not in the path from X to the root.",
                "A cross-edged pseudotree is a traditional pseudotree with the addition of cross-edges.",
                "Figure 2 shows a cross-edged pseudotree with a cross-edge (D-E).",
                "In a cross-edged pseudotree we designate certain edges as primary.",
                "The set of primary edges defines a spanning tree of the nodes.",
                "The parent, child, pseudo-parent, and pseudo-child relationships from the traditional pseudotree are now defined in the context of this primary edge spanning tree.",
                "This definition also yields two additional types of relationships that may exist between nodes: • BP(X) - the branch-parents of a node X: the set of nodes higher in the pseudotree that are connected to X but are not in the primary path from X to the root (In Figure 2, D = BP(E)) • BC(X) - the branch-children of a node X: the set of nodes lower in the pseudotree that are connected to X but are not in any primary path from X to any leaf node (In Figure 2, E = BC(D)) 2.3 Pseudotree Generation 742 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Current algorithms usually have a pre-execution phase to generate a traditional pseudotree from a general DCOP instance.",
                "Our DCPOP algorithm generates a cross-edged pseudotree in the same fashion.",
                "First, the DCOP instance < X, D, U > translates directly into a graph with X as the set of vertices and an edge for each pair of variables represented in U.",
                "Next, various heuristics are used to arrange this graph into a pseudotree.",
                "One common heuristic is to perform a guided depth-first search (DFS) as the resulting traversal is a pseudotree, and a DFS can easily be performed in a distributed fashion.",
                "We define an edge-traversal based method as any method that produces a pseudotree in which all parent/child pairs share an edge in the original graph.",
                "This includes DFS, breadth-first search, and best-first search based traversals.",
                "Our heuristics that generate cross-edged pseudotrees use a distributed best-first search traversal. 3.",
                "DPOP ALGORITHM The original DPOP algorithm operates in three main phases.",
                "The first phase generates a traditional pseudotree from the DCOP instance using a distributed algorithm.",
                "The second phase joins utility hypercubes from children and the local node and propagates them towards the root.",
                "The third phase chooses an assignment for each domain in a top down fashion beginning with the agent at the root node.",
                "The complexity of DPOP depends on the size of the largest computation and utility message during phase two.",
                "It has been shown that this size directly corresponds to the induced width of the pseudotree generated in phase one [6].",
                "DPOP uses polynomial time heuristics to generate the pseudotree since finding the minimum induced width pseudotree is NP-hard.",
                "Several distributed edgetraversal heuristics have been developed to find low width pseudotrees [8].",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, and pseudo-children. 3.1 Utility Propagation Agents located at leaf nodes in the pseudotree begin the process by calculating a local utility hypercube.",
                "This hypercube at node X contains summed utilities for each combination of values in the domains for P(X) and PP(X).",
                "This hypercube has dimensional size equal to the number of pseudo-parents plus one.",
                "A message containing this hypercube is sent to P(X).",
                "Agents located at non-leaf nodes wait for all messages from children to arrive.",
                "Once the agent at node Y has all utility messages, it calculates its local utility hypercube which includes domains for P(Y), PP(Y), and Y.",
                "The local utility hypercube is then joined with all of the hypercubes from the child messages.",
                "At this point all utilities involving node Y are known, and the domain for Y may be safely eliminated from the joined hypercube.",
                "This elimination process chooses the best utility over the domain of Y for each combination of the remaining domains.",
                "A message containing this hypercube is now sent to P(Y).",
                "The dimensional size of this hypercube depends on the number of overlapping domains in received messages and the local utility hypercube.",
                "This dynamic programming based propagation phase continues until the agent at the root node of the pseudotree has received all messages from its children. 3.2 Value Propagation Value propagation begins when the agent at the root node Z has received all messages from its children.",
                "Since Z has no parents or pseudo-parents, it simply combines the utility hypercubes received from its children.",
                "The combined hypercube contains only values for the domain for Z.",
                "At this point the agent at node Z simply chooses the assignment for its domain that has the best utility.",
                "A value propagation message with this assignment is sent to each node in C(Z).",
                "Each other node then receives a value propagation message from its parent and chooses the assignment for its domain that has the best utility given the assignments received in the message.",
                "The node adds its domain assignment to the assignments it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen an assignment for their domain. 4.",
                "DCPOP ALGORITHM Our extension to the original DPOP algorithm, shown in Algorithm 1, shares the same three phases.",
                "The first phase generates the cross-edged pseudotree for the DCOP instance.",
                "The second phase merges branches and propagates the utility hypercubes.",
                "The third phase chooses assignments for domains at branch merge points and in a top down fashion, beginning with the agent at the root node.",
                "For the first phase we generate a pseudotree using several distributed heuristics and select the one with lowest overall complexity.",
                "The complexity of the computation and utility message size in DCPOP does not directly correspond to the induced width of the cross-edged pseudotree.",
                "Instead, we use a polynomial time method for calculating the maximum computation and utility message size for a given cross-edged pseudotree.",
                "A description of this method and the pseudotree selection process appears in Section 5.",
                "At the end of the first phase, each agent knows its parent, children, pseudo-parents, pseudo-children, branch-parents, and branch-children. 4.1 Merging Branches and Utility Propagation In the original DPOP algorithm a node X only had utility functions involving its parent and its pseudo-parents.",
                "In DCPOP, a node X is allowed to have a utility function involving a branch-parent.",
                "The concept of a branch can be seen in Figure 2 with node E representing our node X.",
                "The two distinct paths from node E to node B are called branches of E. The single node where all branches of E meet is node B, which is called the merge point of E. Agents with nodes that have branch-parents begin by sending a utility propagation message to each branch-parent.",
                "This message includes a two dimensional utility hypercube with domains for the node X and the branch-parent BP(X).",
                "It also includes a branch information structure which contains the origination node of the branch, X, the total number of branches originating from X, and the number of branches originating from X that are merged into a single representation by this branch information structure (this number starts at 1).",
                "Intuitively when the number of merged branches equals the total number of originating branches, the algorithm has reached the merge point for X.",
                "In Figure 2, node E sends a utility propagation message to its branch-parent, node D. This message has dimensions for the domains of E and D, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "As in the original DPOP utility propagation phase, an agent at leaf node X sends a utility propagation message to its parent.",
                "In DCPOP this message contains dimensions for the domains of P(X) and PP(X).",
                "If node X also has branch-parents, then the utility propagation message also contains a dimension for the domain of X, and will include a branch information structure.",
                "In Figure 2, node E sends a utility propagation message to its parent, node C. This message has dimensions for the domains of E and C, and includes branch information with an origin of E, 2 total branches, and 1 merged branch.",
                "When a node Y receives utility propagation messages from all of The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 743 its children and branch-children, it merges any branches with the same origination node X.",
                "The merged branch information structure accumulates the number of merged branches for X.",
                "If the cumulative total number of merged branches equals the total number of branches, then Y is the merge point for X.",
                "This means that the utility hypercubes present at Y contain all information about the valuations for utility functions involving node X.",
                "In addition to the typical elimination of the domain of Y from the utility hypercubes, we can now safely eliminate the domain of X from the utility hypercubes.",
                "To illustrate this process, we will examine what happens in the second phase for node B in Figure 2.",
                "In the second phase Node B receives two utility propagation messages.",
                "The first comes from node C and includes dimensions for domains E, B, and A.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "The second comes from node D and includes dimensions for domains E and B.",
                "It also has a branch information structure with origin of E, 2 total branches, and 1 merged branch.",
                "Node B then merges the branch information structures from both messages because they have the same origination, node E. Since the number of merged branches originating from E is now 2 and the total branches originating from E is 2, node B now eliminates the dimensions for domain E. Node B also eliminates the dimension for its own domain, leaving only information about domain A. Node B then sends a utility propagation message to node A, containing only one dimension for the domain of A.",
                "Although not possible in DPOP, this method of utility propagation and dimension elimination may produce hypercubes at node Y that do not share any domains.",
                "In DCPOP we do not join domain independent hypercubes, but instead may send multiple hypercubes in the utility propagation message sent to the parent of Y.",
                "This lazy approach to joins helps to reduce message sizes. 4.2 Value Propagation As in DPOP, value propagation begins when the agent at the root node Z has received all messages from its children.",
                "At this point the agent at node Z chooses the assignment for its domain that has the best utility.",
                "If Z is the merge point for the branches of some node X, Z will also choose the assignment for the domain of X.",
                "Thus any node that is a merge point will choose assignments for a domain other than its own.",
                "These assignments are then passed down the primary edge hierarchy.",
                "If node X in the hierarchy has branch-parents, then the value assignment message from P(X) will contain an assignment for the domain of X.",
                "Every node in the hierarchy adds any assignments it has chosen to the ones it received and passes the set of assignments to its children.",
                "The algorithm is complete when all nodes have chosen or received an assignment for their domain. 4.3 Proof of Correctness We will prove the correctness of DCPOP by first noting that DCPOP fully extends DPOP and then examining the two cases for value assignment in DCPOP.",
                "Given a traditional pseudotree as input, the DCPOP algorithm execution is identical to DPOP.",
                "Using a traditional pseudotree arrangement no nodes have branch-parents or branch-children since all edges are either back-edges or tree edges.",
                "Thus the DCPOP algorithm using a traditional pseudotree sends only utility propagation messages that contain domains belonging to the parent or pseudo-parents of a node.",
                "Since no node has any branch-parents, no branches exist, and thus no node serves as a merge point for any other node.",
                "Thus all value propagation assignments are chosen at the node of the assignment domain.",
                "For DCPOP execution with cross-edged pseudotrees, some nodes serve as merge points.",
                "We note that any node X that is not a merge point assigns its value exactly as in DPOP.",
                "The local utility hypercube at X contains domains for X, P(X), PP(X), and BC(X).",
                "As in DPOP the value assignment message received at X includes the values assigned to P(X) and PP(X).",
                "Also, since X is not a merge point, all assignments to BC(X) must have been calculated at merge points higher in the tree and are in the value assignment message from P(X).",
                "Thus after eliminating domains for which assignments are known, only the domain of X is left.",
                "The agent at node X can now correctly choose the assignment with maximum utility for its own domain.",
                "If node X is a merge point for some branch-child Y, we know that X must be a node along the path from Y to the root, and from P(Y) and all BP(Y) to the root.",
                "From the algorithm, we know that Y necessarily has all information from C(Y), PC(Y), and BC(Y) since it waits for their messages.",
                "Node X has information about all nodes below it in the tree, which would include Y, P(Y), BP(Y), and those PP(Y) that are below X in the tree.",
                "For any PP(Y) above X in the tree, X receives the assignment for the domain of PP(Y) in the value assignment message from P(X).",
                "Thus X has utility information about all of the utility functions of which Y is a part.",
                "By eliminating domains included in the value assignment message, node X is left with a local utility hypercube with domains for X and Y.",
                "The agent at node X can now correctly choose the assignments with maximum utility for the domains of X and Y. 4.4 Complexity Analysis The first phase of DCPOP sends one message to each P(X), PP(X), and BP(X).",
                "The second phase sends one value assignment message to each C(X).",
                "Thus, DCPOP produces a linear number of messages with respect to the number of edges (utility functions) in the cross-edged pseudotree and the original DCOP instance.",
                "The actual complexity of DCPOP depends on two additional measurements: message size and computation size.",
                "Message size and computation size in DCPOP depend on the number of overlapping branches as well as the number of overlapping back-edges.",
                "It was shown in [6] that the number of overlapping back-edges is equal to the induced width of the pseudotree.",
                "In a poorly constructed cross-edged pseudotree, the number of overlapping branches at node X can be as large as the total number of descendants of X.",
                "Thus, the total message size in DCPOP in a poorly constructed instance can be space-exponential in the total number of nodes in the graph.",
                "However, in practice a well constructed cross-edged pseudotree can achieve much better results.",
                "Later we address the issue of choosing well constructed crossedged pseudotrees from a set.",
                "We introduce an additional measurement of the maximum sequential path cost through the algorithm.",
                "This measurement directly relates to the maximum amount of parallelism achievable by the algorithm.",
                "To take this measurement we first store the total computation size for each node during phase two and three.",
                "This computation size represents the number of individual accesses to a value in a hypercube at each node.",
                "For example, a join between two domains of size 4 costs 4 ∗ 4 = 16.",
                "Two directed acyclic graphs (DAG) can then be drawn; one with the utility propagation messages as edges and the phase two costs at nodes, and the other with value assignment messages and the phase three costs at nodes.",
                "The maximum sequential path cost is equal to the sum of the longest path on each DAG from the root to any leaf node. 5.",
                "HEURISTICS In our assessment of complexity in DCPOP we focused on the worst case possibly produced by the algorithm.",
                "We acknowledge 744 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Algorithm 1 DCPOP Algorithm 1: DCPOP(X; D; U) Each agent Xi executes: Phase 1: pseudotree creation 2: elect leader from all Xj ∈ X 3: elected leader initiates pseudotree creation 4: afterwards, Xi knows P(Xi), PP(Xi), BP(Xi), C(Xi), BC(Xi) and PC(Xi) Phase 2: UTIL message propagation 5: if |BP(Xi)| > 0 then 6: BRANCHXi ← |BP(Xi)| + 1 7: for all Xk ∈BP(Xi) do 8: UTILXi (Xk) ←Compute utils(Xi, Xk) 9: Send message(Xk,UTILXi (Xk),BRANCHXi ) 10: if |C(Xi)| = 0(i.e.",
                "Xi is a leaf node) then 11: UTILXi (P(Xi)) ← Compute utils(P(Xi),PP(Xi)) for all PP(Xi) 12: Send message(P(Xi), UTILXi (P(Xi)),BRANCHXi ) 13: Send message(PP(Xi), empty UTIL, empty BRANCH) to all PP(Xi) 14: activate UTIL Message handler() Phase 3: VALUE message propagation 15: activate VALUE Message handler() END ALGORITHM UTIL Message handler(Xk,UTILXk (Xi), BRANCHXk ) 16: store UTILXk (Xi),BRANCHXk (Xi) 17: if UTIL messages from all children and branch children arrived then 18: for all Bj ∈BRANCH(Xi) do 19: if Bj is merged then 20: join all hypercubes where Bj ∈UTIL(Xi) 21: eliminate Bj from the joined hypercube 22: if P(Xi) == null (that means Xi is the root) then 23: v ∗ i ← Choose optimal(null) 24: Send VALUE(Xi, v ∗ i) to all C(Xi) 25: else 26: UTILXi (P(Xi)) ← Compute utils(P(Xi), PP(Xi)) 27: Send message(P(Xi),UTILXi (P(Xi)), BRANCHXi (P(Xi))) VALUE Message handler(VALUEXi ,P(Xi)) 28: add all Xk ← v ∗ k ∈VALUEXi ,P(Xi) to agent view 29: Xi ← v ∗ i =Choose optimal(agent view) 30: Send VALUEXl , Xi to all Xl ∈C(Xi) that in real world problems the generation of the pseudotree has a significant impact on the actual performance.",
                "The problem of finding the best pseudotree for a given DCOP instance is NP-Hard.",
                "Thus a heuristic is used for generation, and the performance of the algorithm depends on the pseudotree found by the heuristic.",
                "Some previous research focused on finding heuristics to generate good pseudotrees [8].",
                "While we have developed some heuristics that generate good cross-edged pseudotrees for use with DCPOP, our focus has been to use multiple heuristics and then select the best pseudotree from the generated pseudotrees.",
                "We consider only heuristics that run in polynomial time with respect to the number of nodes in the original DCOP instance.",
                "The actual DCPOP algorithm has worst case exponential complexity, but we can calculate the maximum message size, computation size, and sequential path cost for a given cross-edged pseudotree in linear space-time complexity.",
                "To do this, we simply run the algorithm without attempting to calculate any of the local utility hypercubes or optimal value assignments.",
                "Instead, messages include dimensional and branch information but no utility hypercubes.",
                "After each heuristic completes its generation of a pseudotree, we execute the measurement procedure and propagate the measurement information up to the chosen root in that pseudotree.",
                "The root then broadcasts the total complexity for that heuristic to all nodes.",
                "After all heuristics have had a chance to complete, every node knows which heuristic produced the best pseudotree.",
                "Each node then proceeds to begin the DCPOP algorithm using its knowledge of the pseudotree generated by the best heuristic.",
                "The heuristics used to generate traditional pseudotrees perform a distributed DFS traversal.",
                "The general distributed algorithm uses a token passing mechanism and a linear number of messages.",
                "Improved DFS based heuristics use a special procedure to choose the root node, and also provide an ordering function over the neighbors of a node to determine the order of path recursion.",
                "The DFS based heuristics used in our experiments come from the work done in [4, 8]. 5.1 The best-first cross-edged pseudotree heuristic The heuristics used to generate cross-edged pseudotrees perform a best-first traversal.",
                "A general distributed best-first algorithm for node expansion is presented in Algorithm 2.",
                "An evaluation function at each node provides the values that are used to determine the next best node to expand.",
                "Note that in this algorithm each node only exchanges its best value with its neighbors.",
                "In our experiments we used several evaluation functions that took as arguments an ordered list of ancestors and a node, which contains a list of neighbors (with each neighbors placement depth in the tree if it was placed).",
                "From these we can calculate branchparents, branch-children, and unknown relationships for a potential node placement.",
                "The best overall function calculated the value as ancestors−(branchparents+branchchildren) with the number of unknown relationships being a tiebreak.",
                "After completion each node has knowledge of its parent and ancestors, so it can easily determine which connected nodes are pseudo-parents, branchparents, pseudo-children, and branch-children.",
                "The complexity of the best-first traversal depends on the complexity of the evaluation function.",
                "Assuming a complexity of O(V ) for the evaluation function, which is the case for our best overall function, the best-first traversal is O(V · E) which is at worst O(n3 ).",
                "For each v ∈ V we perform a place operation, and find the next node to place using the getBestNeighbor operation.",
                "The place operation is at most O(V ) because of the sent messages.",
                "Finding the next node uses recursion and traverses only already placed The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 745 Algorithm 2 Distributed Best-First Search Algorithm root ← electedleader next(root, ∅) place(node, parent) node.parent ← parent node.ancestors ← parent.ancestors ∪ parent send placement message (node, node.ancestors) to all neighbors of node next(current, previous) if current is not placed then place(current, previous) next(current, ∅) else best ← getBestNeighbor(current, previous) if best = ∅ then if previous = ∅ then terminate, all nodes are placed next(previous, ∅) else next(best, current) getBestNeighbor(current, previous) best ← ∅; score ← 0 for all n ∈ current.neighbors do if n! = previous then if n is placed then nscore ← getBestNeighbor(n, current) else nscore ← evaluate(current, n) if nscore > score then score ← nscore best ← n return best, score nodes, so it has O(V ) recursions.",
                "Each recursion performs a recursive getBestNeighbor operation that traverses all placed nodes and their neighbors.",
                "This operation is O(V · E), but results can be cached using only O(V ) space at each node.",
                "Thus we have O(V ·(V +V +V ·E)) = O(V 2 ·E).",
                "If we are smart about evaluating local changes when each node receives placement messages from its neighbors and cache the results the getBestNeighbor operation is only O(E).",
                "This increases the complexity of the place operation, but for all placements the total complexity is only O(V · E).",
                "Thus we have an overall complexity of O(V ·E+V ·(V +E)) = O(V ·E). 6.",
                "COMPARISON OF COMPLEXITY IN DPOP AND DCPOP We have already shown that given the same input, DCPOP performs the same as DPOP.",
                "We also have shown that we can accurately predict performance of a given pseudotree in linear spacetime complexity.",
                "If we use a constant number of heuristics to generate the set of pseudotrees, we can choose the best pseudotree in linear space-time complexity.",
                "We will now show that there exists a DCOP instance for which a cross-edged pseudotree outperforms all possible traditional pseudotrees (based on edge-traversal heuristics).",
                "In Figure 3(a) we have a DCOP instance with six nodes.",
                "This is a bipartite graph with each partition fully connected to the other (a) (b) (c) Figure 3: (a) The DCOP instance (b) A traditional pseudotree arrangement for the DCOP instance (c) A cross-edged pseudotree arrangement for the DCOP instance partition.",
                "In Figure 3(b) we see a traditional pseudotree arrangement for this DCOP instance.",
                "It is easy to see that any edgetraversal based heuristic cannot expand two nodes from the same partition in succession.",
                "We also see that no node can have more than one child because any such arrangement would be an invalid pseudotree.",
                "Thus any traditional pseudotree arrangement for this DCOP instance must take the form of Figure 3(b).",
                "We can see that the back-edges F-B and F-A overlap node C. Node C also has a parent E, and a back-edge with D. Using the original DPOP algorithm (or DCPOP since they are identical in this case), we find that the computation at node C involves five domains: A, B, C, D, and E. In contrast, the cross-edged pseudotree arrangement in Figure 3(c) requires only a maximum of four domains in any computation during DCPOP.",
                "Since node A is the merge point for branches from both B and C, we can see that each of the nodes D, E, and F have two overlapping branches.",
                "In addition each of these nodes has node A as its parent.",
                "Using the DCPOP algorithm we find that the computation at node D (or E or F) involves four domains: A, B, C, and D (or E or F).",
                "Since no better traditional pseudotree arrangement can be created using an edge-traversal heuristic, we have shown that DCPOP can outperform DPOP even if we use the optimal pseudotree found through edge-traversal.",
                "We acknowledge that pseudotree arrangements that allow parent-child relationships without an actual constraint can solve the problem in Figure 3(a) with maximum computation size of four domains.",
                "However, current heuristics used with DPOP do not produce such pseudotrees, and such a heuristic would be difficult to distribute since each node would require information about nodes with which it has no constraint.",
                "Also, while we do not prove it here, cross-edged pseudotrees can produce smaller message sizes than such pseudotrees even if the computation size is similar.",
                "In practice, since finding the best pseudotree arrangement is NP-Hard, we find that heuristics that produce cross-edged pseudotrees often produce significantly smaller computation and message sizes. 7.",
                "EXPERIMENTAL RESULTS 746 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) Existing performance metrics for DCOP algorithms include the total number of messages, synchronous clock cycles, and message size.",
                "We have already shown that the total number of messages is linear with respect to the number of constraints in the DCOP instance.",
                "We also introduced the maximum sequential path cost (PC) as a measurement of the maximum amount of parallelism achievable by the algorithm.",
                "The maximum sequential path cost is equal to the sum of the computations performed on the longest path from the root to any leaf node.",
                "We also include as metrics the maximum computation size in number of dimensions (CD) and maximum message size in number of dimensions (MD).",
                "To analyze the relative complexity of a given DCOP instance, we find the minimum induced width (IW) of any traditional pseudotree produced by a heuristic for the original DPOP. 7.1 Generic DCOP instances For our initial tests we randomly generated two sets of problems with 3000 cases in each.",
                "Each problem was generated by assigning a random number (picked from a range) of constraints to each variable.",
                "The generator then created binary constraints until each variable reached its maximum number of constraints.",
                "The first set uses 20 variables, and the best DPOP IW ranges from 1 to 16 with an average of 8.5.",
                "The second set uses 100 variables, and the best DPOP IW ranged from 2 to 68 with an average of 39.3.",
                "Since most of the problems in the second set were too complex to actually compute the solution, we took measurements of the metrics using the techniques described earlier in Section 5 without actually solving the problem.",
                "Results are shown for the first set in Table 1 and for the second set in Table 2.",
                "For the two problem sets we split the cases into low density and high density categories.",
                "Low density cases consist of those problems that have a best DPOP IW less than or equal to half of the total number of nodes (e.g.",
                "IW ≤ 10 for the 20 node problems and IW ≤ 50 for the 100 node problems).",
                "High density problems consist of the remainder of the problem sets.",
                "In both Table 1 and Table 2 we have listed performance metrics for the original DPOP algorithm, the DCPOP algorithm using only cross-edged pseudotrees (DCPOP-CE), and the DCPOP algorithm using traditional and cross-edged pseudotrees (DCPOP-All).",
                "The pseudotrees used for DPOP were generated using 5 heuristics: DFS, DFS MCN, DFS CLIQUE MCN, DFS MCN DSTB, and DFS MCN BEC.",
                "These are all versions of the guided DFS traversal discussed in Section 5.",
                "The cross-edged pseudotrees used for DCPOP-CE were generated using 5 heuristics: MCN, LCN, MCN A-B, LCN A-B, and LCSG A-B.",
                "These are all versions of the best-first traversal discussed in Section 5.",
                "For both DPOP and DCPOP-CE we chose the best pseudotree produced by their respective 5 heuristics for each problem in the set.",
                "For DCPOP-All we chose the best pseudotree produced by all 10 heuristics for each problem in the set.",
                "For the CD and MD metrics the value shown is the average number of dimensions.",
                "For the PC metric the value shown is the natural logarithm of the maximum sequential path cost (since the actual value grows exponentially with the complexity of the problem).",
                "The final row in both tables is a measurement of improvement of DCPOP-All over DPOP.",
                "For the CD and MD metrics the value shown is a reduction in number of dimensions.",
                "For the PC metric the value shown is a percentage reduction in the maximum sequential path cost (% = DP OP −DCP OP DCP OP ∗ 100).",
                "Notice that DCPOPAll outperforms DPOP on all metrics.",
                "This logically follows from our earlier assertion that given the same input, DCPOP performs exactly the same as DPOP.",
                "Thus given the choice between the pseudotrees produced by all 10 heuristics, DCPOP-All will always outLow Density High Density Algorithm CD MD PC CD MD PC DPOP 7.81 6.81 3.78 13.34 12.34 5.34 DCPOP-CE 7.94 6.73 3.74 12.83 11.43 5.07 DCPOP-All 7.62 6.49 3.66 12.72 11.36 5.05 Improvement 0.18 0.32 13% 0.62 0.98 36% Table 1: 20 node problems Low Density High Density Algorithm CD MD PC CD MD PC DPOP 33.35 32.35 14.55 58.51 57.50 19.90 DCPOP-CE 33.49 29.17 15.22 57.11 50.03 20.01 DCPOP-All 32.35 29.57 14.10 56.33 51.17 18.84 Improvement 1.00 2.78 104% 2.18 6.33 256% Table 2: 100 node problems Figure 4: Computation Dimension Size Figure 5: Message Dimension Size The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07) 747 Figure 6: Path Cost DCPOP Improvement Ag Mtg Vars Const IW CD MD PC 10 4 12 13.5 2.25 -0.01 -0.01 5.6% 30 14 44 57.6 3.63 0.09 0.09 10.9% 50 24 76 101.3 4.17 0.08 0.09 10.7% 100 49 156 212.9 5.04 0.16 0.20 30.0% 150 74 236 321.8 5.32 0.21 0.23 35.8% 200 99 316 434.2 5.66 0.18 0.22 29.5% Table 3: Meeting Scheduling Problems perform DPOP.",
                "Another trend we notice is that the improvement is greater for high density problems than low density problems.",
                "We show this trend in greater detail in Figures 4, 5, and 6.",
                "Notice how the improvement increases as the complexity of the problem increases. 7.2 Meeting Scheduling Problem In addition to our initial generic DCOP tests, we ran a series of tests on the Meeting Scheduling Problem (MSP) as described in [6].",
                "The problem setup includes a number of people that are grouped into departments.",
                "Each person must attend a specified number of meetings.",
                "Meetings can be held within departments or among departments, and can be assigned to one of eight time slots.",
                "The MSP maps to a DCOP instance where each variable represents the time slot that a specific person will attend a specific meeting.",
                "All variables that belong to the same person have mutual exclusion constraints placed so that the person cannot attend more than one meeting during the same time slot.",
                "All variables that belong to the same meeting have equality constraints so that all of the participants choose the same time slot.",
                "Unary constraints are placed on each variable to account for a persons valuation of each meeting and time slot.",
                "For our tests we generated 100 sample problems for each combination of agents and meetings.",
                "Results are shown in Table 3.",
                "The values in the first five columns represent (in left to right order), the total number of agents, the total number of meetings, the total number of variables, the average total number of constraints, and the average minimum IW produced by a traditional pseudotree.",
                "The last three columns show the same metrics we used for the generic DCOP instances, except this time we only show the improvements of DCPOP-All over DPOP.",
                "Performance is better on average for all MSP instances, but again we see larger improvements for more complex problem instances. 8.",
                "CONCLUSIONS AND FUTURE WORK We presented a complete, distributed algorithm that solves general DCOP instances using cross-edged pseudotree arrangements.",
                "Our algorithm extends the DPOP algorithm by adding additional utility propagation messages, and introducing the concept of branch merging during the utility propagation phase.",
                "Our algorithm also allows value assignments to occur at higher level merge points for lower level nodes.",
                "We have shown that DCPOP fully extends DPOP by performing the same operations given the same input.",
                "We have also shown through some examples and experimental data that DCPOP can achieve greater performance for some problem instances by extending the allowable input set to include cross-edged pseudotrees.",
                "We placed particular emphasis on the role that edge-traversal heuristics play in the generation of pseudotrees.",
                "We have shown that the performance penalty is minimal to generate multiple heuristics, and that we can choose the best generated pseudotree in linear space-time complexity.",
                "Given the importance of a good pseudotree for performance, future work will include new heuristics to find better pseudotrees.",
                "Future work will also include adapting existing DPOP extensions [5, 7] that support different problem domains for use with DCPOP. 9.",
                "REFERENCES [1] J. Liu and K. P. Sycara.",
                "Exploiting problem structure for distributed constraint optimization.",
                "In V. Lesser, editor, Proceedings of the First International Conference on Multi-Agent Systems, pages 246-254, San Francisco, CA, 1995.",
                "MIT Press. [2] P. J. Modi, H. Jung, M. Tambe, W.-M. Shen, and S. Kulkarni.",
                "A dynamic distributed constraint satisfaction approach to resource allocation.",
                "Lecture Notes in Computer Science, 2239:685-700, 2001. [3] P. J. Modi, W. Shen, M. Tambe, and M. Yokoo.",
                "An asynchronous complete method for distributed constraint optimization.",
                "In AAMAS 03, 2003. [4] A. Petcu.",
                "Frodo: A framework for open/distributed constraint optimization.",
                "Technical Report No. 2006/001 2006/001, Swiss Federal Institute of Technology (EPFL), Lausanne (Switzerland), 2006. http://liawww.epfl.ch/frodo/. [5] A. Petcu and B. Faltings.",
                "A-dpop: Approximations in distributed optimization.",
                "In poster in CP 2005, pages 802-806, Sitges, Spain, October 2005. [6] A. Petcu and B. Faltings.",
                "Dpop: A scalable method for multiagent constraint optimization.",
                "In IJCAI 05, pages 266-271, Edinburgh, Scotland, Aug 2005. [7] A. Petcu, B. Faltings, and D. Parkes.",
                "M-dpop: Faithful distributed implementation of efficient social choice problems.",
                "In AAMAS 06, pages 1397-1404, Hakodate, Japan, May 2006. [8] G. Ushakov.",
                "Solving meeting scheduling problems using distributed pseudotree-optimization procedure.",
                "Masters thesis, ´Ecole Polytechnique F´ed´erale de Lausanne, 2005. [9] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "Distributed constraint satisfaction for formalizing distributed problem solving.",
                "In International Conference on Distributed Computing Systems, pages 614-621, 1992. [10] M. Yokoo, E. H. Durfee, T. Ishida, and K. Kuwabara.",
                "The distributed constraint satisfaction problem: Formalization and algorithms.",
                "Knowledge and Data Engineering, 10(5):673-685, 1998. 748 The Sixth Intl.",
                "Joint Conf. on Autonomous Agents and Multi-Agent Systems (AAMAS 07)"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}