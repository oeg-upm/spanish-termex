{
    "id": "J-32",
    "original_text": "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents. When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs. It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem. In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees. This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games. The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently. Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time. We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium. We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2. Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree. We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2. It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable). Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1. INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players. The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games. A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players. The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree. The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time. This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves. It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1. During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2). The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V . The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue. The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk. By the end of the upstream pass, all children of the root have computed their best response policies. In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice. It also selects a strategy for each child. A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root. The equilibrium then propagates downstream, with each vertex selecting its childrens actions. The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent. To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid. The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect. In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game. In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output. Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ). This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.) We can improve the running time of the generic algorithm using the ideas of [9]. In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary). We obtain the following theorem THEOREM 1. There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path. There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game. In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem. THEOREM 2. There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2. In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree. Even when the tree has bounded degree, the running time can be exponential. We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies. In particular, we show the following. THEOREM 3. There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space. It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths. It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1. This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8. In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth. We prove the following theorem. THEOREM 4. Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete. Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria. To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2. PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree. Each vertex has two actions, which are denoted by 0 and 1. A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1. Fur the purposes of the algorithm, the tree is rooted arbitrarily. For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child. This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function. Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1. Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}. Typically, W is the parent of V , and this is just referred to as the best response policy for V . The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}. The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root. With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child. The root selects any pair (w, v) from B(W, V ). It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive. When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3. ALGORITHM OF LITTMAN ET AL. The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex. As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium. This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1]. We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1. In [9], it is suggested that we can select the breakpoint policy in a particular way. Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt. The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1. We say such a breakpoint policy has t − 1 breakpoints. The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk. The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child. Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl. Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t. P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies. The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1]. It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl. The authors then claim that any such cover can be transformed into a breakpoint policy for V . Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5). They illustrate their approach in a figure, which is reproduced as Figure 1 here. In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7. The thick connected path is the corresponding breakpoint policy. It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right. To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U. Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise. Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1). Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2. The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0. The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back). The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3. Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium. For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2. The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).) In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1. The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible. Any other trimming would be just as bad. For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1. The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9. The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0. We conclude that the LKS algorithm does not always find a Nash equilibrium. In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium. For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2. Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees. In the next section, we show that it runs in polynomial time on a path. 4. FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}. We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point. THEOREM 5. For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles. Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ). PROOF. For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly. Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A. We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points. To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game. For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true. Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively. The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}. Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111. If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy. Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0. In this case, P0 > P1 if and only if A1u + A0 < 0. If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true. Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1. Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}. By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points. For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies. To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1. The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0. Assume for now that A1 > 0; the other two cases can be treated similarly. In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1. Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅. Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1). Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle. Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1. Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 . Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α. Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1]. The set B(W, V )|V =1 can be described in a similar manner. By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points. Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4. Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0. In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously. Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1. For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1]. Sometimes we drop the subscript V when it is clear from the context. LEMMA 1. For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u). PROOF. Fix an arbitrary v ∈ (0, 1). Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies. Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w). Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1. Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies. As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1). Choose u = vj−1; by construction, u ∈ pbrU (v). Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1. However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy. Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0. LEMMA 2. For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w). PROOF. Consider an arbitrary u0 ∈ pbrU (0). If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0). Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w). The argument for the case B(u0) < 0 is similar. Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours. Note that for any such vector we have vj−1 ∈ pbrU (0). By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru. Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}. In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1. The argument for ˆf(1) is similar. Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 . It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time. Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U). If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle. Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles. Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2). Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems. For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles. The case limu→u∗− f(u) = −∞ is similar. As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles. Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each. We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles. Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U). Hence, B(W, V ) has at most 2j + 4 event points. The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm. The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ). However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game. In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1. Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies. While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has. Definition 3. A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U). We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union. Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments. Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1. As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium. Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6]. THEOREM 6. For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5. NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2. A graph having maximum degree 2 is, of course, a union of paths and cycles. Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles. Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies. For i ≤ k let vi denote the probability that Vi plays 1. The first search can be done as follows. For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1. Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2. Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3. Apply the upstream pass to P 4. Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5. Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.) For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1). Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1). Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 . Choose any vertex Vi. We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game. If the equation is non-trivial it has at most 2 solutions in (0, 1). For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1). For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1). If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria. The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6. FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children. We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ). Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj). Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively. Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments. Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments. Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1. For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}. As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial. In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments. Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time. In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail. S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy. In the rest of this subsection, we describe this construction. Consider the tree Tn given by Figure 5; let Vn be the root of this tree. For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2. It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1. The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6. LEMMA 3. Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively. Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments. Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}. PROOF. The proof proceeds by induction on k. For k = 0, the statement is obvious. Now, suppose it is true for B(Vk, Vk−1). One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk). Let us examine them in turn. To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2. Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}. For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2]. We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}. Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}. Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk). It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk). Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis. Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint. Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}. Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other. We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma. To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies. We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables. Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree. Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}. Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk. LEMMA 4. Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk). The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 . The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments. However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified. More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ). This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ). Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj). This implies Theorem 3. THEOREM 7. For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0. We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6]. We proceed by induction. For j = 1, the argument is similar to that in Section 3. For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7. PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time. We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j. The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1. The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree). For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview. Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems. A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input. In a total search problem, there is a guarantee that at least one solution exists for any input. Nashs theorem assures us that the problem of finding Nash equilibria is total. A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS. Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets. Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem. Definition 4. END OF THE LINE. Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n . Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x. S and P can be thought of as standing for successor and predecessor. Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE. END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3. Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows. Definition 5. 3-DIMENSIONAL BROUWER. Input: a circuit C having 3n input bits and 2 output bits. The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision. The output represents one of four colours assigned by C to a cubelet. C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube. A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours. The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint. The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH. To prove the theorem, we begin with some preliminary results as follows. Each player has 2 actions, denoted 0 and 1. For a player at vertex V let p[V ] denote the probability that the player plays 1. LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ]. COROLLARY 1. There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ]. PROOF. Make a chain of n copies of Gshift in Lemma 5. Each subset of vertices in the path decomposition is the vertices in a copy of Gshift. Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false. The following uses gadgets from [7, 4]. COROLLARY 2. There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]). PROOF OF THEOREM 4. Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER. Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1. The probability that V plays 1 is denoted p[V ]. G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube. G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER. For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0. Construct V (i) C from V (i−1) C using Corollary 2. Let G(i) be the graphical game that does this. Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ). Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n). Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz]. Similarly to [4], the output of GC affects Vx, Vy and Vz as follows. Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1). We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points. That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex). This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]). Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]). At a Nash equilibrium the outputs of each copy will cancel each other out. The pathwidth of the whole game is at most M times the pathwidth GC. 8. OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time. Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space. However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed. In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively. Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1. It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial. In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn. For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them. Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}. Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1. Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts. Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi]. Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments? If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment? It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0. This implies that even for a caterpillar, the best response policy can be exponentially large. However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size. If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9. REFERENCES [1] H. Bodlaender and T. Kloks. Efficient and constructive algorithms for the pathwidth and treewidth of graphs. Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete. Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng. Settling the complexity of 2-player Nash equilibrium. Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou. The complexity of computing a Nash equilibrium. In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou. Three-player games are hard. Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg. Nash equilibria in graphical games on trees revisited. Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou. Reducibility among equilibrium problems. In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh. Graphical models for game theory. In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh. An efficient exact algorithm for singly connected graphical games. In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns. Nash propagation for loopy graphical games. In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou. On the complexity of the parity argument and other inefficient proofs of existence. J. Comput. Syst. Sci., 48(3):498-532, 1994. 109",
    "original_translation": "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed asUn modelo teórico de juego de redes distribuidas a gran escala de agentes no cooperativos. Cuando el número de jugadores es grande, y el gráfico subyacente tiene un grado bajo, proporcionan una forma concisa de representar a los pagos de los jugadores. Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico general de grado-3 con dos acciones por jugador está completo para el PPAD de la clase de complejidad, lo que indica que es poco probable que haya algún algoritmo de tiempo polinómico para este problema. En este artículo, estudiamos la complejidad de los juegos gráficos con dos acciones por jugador en árboles de grado límite. Este entorno fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un algoritmo dinámico basado en programación que calcula todos los equilibrios NASH de tales juegos. El tiempo de ejecución de su algoritmo es exponencial, aunque los equilibrios aproximados se pueden calcular de manera eficiente. Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un único equilibrio de Nash en el tiempo polinomial. Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un equilibrio de Nash. Luego proponemos un nuevo algoritmo que se basa en las ideas de Kearns et al.y calcula todos los equilibrios NASH en tiempo cuadrático si el gráfico de entrada es una ruta, y en el tiempo polinomial si es un gráfico arbitrario de máximo grado 2. Además, nuestro algoritmo se puede utilizar para calcular los equilibrios NASH de los juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol ha limitado el grado. Mostramos que esto es inevitable: cualquier algoritmo de este tipo tomará un tiempo exponencial, incluso en árboles de grado limitado con Vaño de Ruta 2. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinomial en gráficos con el viento de ruta 1, pero mostramos que encontrar un equilibrio NASH para un juego gráfico de 2 acciones en el que el gráfico subyacente tiene un grado máximo 3 y una vía de ruta constante es PPAD-complete (es poco probable que sea manejable). Categorías y descriptores de sujetos F.2 [Teoría de la computación]: Análisis de algoritmos y complejidad del problema;J.4 [Aplicaciones informáticas]: Ciencias sociales y conductuales-economía Algoritmos de términos generales, Economía, Teoría 1. Introducción Los juegos gráficos se introdujeron en los documentos de Kearns et al.[8] y Littman et al.[9] Como una representación sucinta de juegos con una gran cantidad de jugadores. La representación clásica de forma normal (o forma de matriz) tiene un tamaño que es exponencial en el número de jugadores, lo que la hace inadecuada para juegos distribuidos a gran escala. Un juego gráfico asocia a cada jugador con un vértice de un gráfico subyacente G, y la recompensa a ese jugador es una función de las acciones elegidas por él y sus vecinos en G;Si G tiene bajo grado, esta es una forma concisa de representar un juego con muchos jugadores. Los documentos [8, 9] dan un algoritmo de programación dinámica para encontrar equilibrios de Nash en juegos gráficos donde hay dos acciones por jugador y G es un árbol. El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula las aproximaciones a todos los equilibrios de NASH en el tiempo de tiempo en el tamaño de entrada y la calidad de aproximación, o como un algoritmo de tiempo exponencial quePermite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en el tiempo polinomial. Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil.1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el pase aguas arriba y el pase aguas abajo;1 El primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas. Se supone que cada jugador tiene dos estrategias puras (acciones), que se denotan por 0 y 1;Se deduce que cualquier estrategia mixta puede representarse como un número único x ∈ [0, 1], donde x es la probabilidad de que el jugador seleccione 1. Durante el pase aguas arriba, cada vértice V calcula el conjunto de sus mejores respuestas potenciales a cada estrategia mixta W de su padre W;Una estrategia V es una mejor respuesta potencial a W si 1 nota que la terminología aguas arriba y aguas abajo se invierte en [8, 9]: nuestros árboles están enraizados en la parte superior.100 Hay un equilibrio de Nash en el juego gráfico aguas abajo de V (inclusive) dado que W juega W (para una definición más técnica, se remite al lector a la Sección 2). La salida de esta etapa se puede ver como una Tabla (continua) T (W, V), donde t (W, V) = 1 si y solo si V es una mejor respuesta potencial a W;Nos referimos a esta tabla como la mejor política de respuesta para V. El algoritmo genérico no aborda el problema de representar la mejor política de respuesta;De hecho, la diferencia más importante entre las dos instancias del algoritmo genérico descrito en [8] está en su enfoque de este problema. El cálculo se realiza inductivamente: la mejor política de respuesta para V se calcula en función de las mejores políticas de respuesta de V S Children U1 ,..., Reino Unido. Al final del pase aguas arriba, todos los niños de la raíz han calculado sus mejores políticas de respuesta. Al comienzo del pase posterior, la raíz selecciona su estrategia e informa a sus hijos sobre su elección. También selecciona una estrategia para cada niño. Una condición necesaria y suficiente para que el algoritmo continúe es que la estrategia de la raíz es una mejor respuesta a las estrategias de sus hijos y, para cada niño, la estrategia elegida es una de las mejores respuestas potenciales precomputadas a la estrategia elegidade la raíz. El equilibrio luego se propaga aguas abajo, con cada vértice seleccionando sus acciones infantiles. La acción del niño se elige para ser cualquier estrategia de las mejores respuestas potenciales precomputadas a la estrategia elegida de los padres. Para limitar el tiempo de ejecución de este algoritmo, el documento [8] muestra que cualquier política de mejor respuesta puede representarse como una unión de un número exponencial de rectángulos;El algoritmo de aproximación de tiempo polinomial se obtiene combinando esta representación con una cuadrícula de tamaño polinomial. La idea principal de [9] es que no es necesario realizar un seguimiento de todos los rectángulos en las mejores políticas de respuesta;Más bien, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinomial de la política correspondiente (en [9], este subconjunto se llama política de punto de interrupción) y aún así asegurarse de que el pase posterior pueda proceder con éxito (Una condición suficiente para esto es que el subconjunto de la mejor política de respuesta para V almacenada por el algoritmo contiene una ruta continua de W = 0 a W = 1).1.2 Nuestros resultados Una de las principales contribuciones de nuestro artículo es mostrar que el algoritmo propuesto por [9] es incorrecto. En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] genera un vector de estrategias que no constituye un equilibrio NASH del juego subyacente. En las secciones 4, 5 y 6 mostramos cómo arreglar el algoritmo de [9] para que siempre produce una salida correcta. La Sección 4 considera el caso en el que el gráfico subyacente es una ruta de longitud n.Para este caso, mostramos que el número de rectángulos en cada una de las mejores políticas de respuesta es O (N2). Esto nos da un algoritmo O (N3) para encontrar un equilibrio de Nash, y para calcular una representación de todos los equilibrios de Nash.(Este algoritmo es un caso especial del algoritmo genérico de [8]: mostramos que se ejecuta en tiempo polinomial cuando el gráfico subyacente es una ruta). Podemos mejorar el tiempo de ejecución del algoritmo genérico utilizando las ideas de [9]. En particular, damos un algoritmo O (N2) para encontrar un equilibrio NASH de un juego gráfico en un camino de longitud n.En lugar de almacenar las mejores políticas de respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, después de [9], llamamos políticas de punto de interrupción (modificando la definición según sea necesario). Obtenemos el siguiente teorema del teorema 1. Hay un algoritmo O (N2) que encuentra un equilibrio NASH de un juego gráfico con dos acciones por jugador en una ruta N-Vértice. Hay un algoritmo O (N3) que calcula una representación de todos los equilibrios de Nash de dicho juego. En la Sección 5 extendemos los resultados de los gráficos de la Sección 4 a General de grado2, obteniendo el siguiente teorema. Teorema 2. Hay un algoritmo de tiempo polinómico que encuentra un equilibrio NASH de un juego gráfico con dos acciones por jugador en un gráfico con el máximo grado 2. En la Sección 6 ampliamos nuestro algoritmo para que pueda usarse para encontrar un equilibrio NASH de un juego gráfico en un árbol arbitrario. Incluso cuando el árbol tiene un grado limitado, el tiempo de ejecución puede ser exponencial. Mostramos que esto es inevitable al construir una familia de juegos gráficos en árboles de grados limitados para los cuales las mejores políticas de respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de TWOPass (es decir, un algoritmo que es similar en el espíritu de [8]) tiene que almacenar casi todos los puntos de las mejores políticas de respuesta. En particular, mostramos lo siguiente. Teorema 3. Hay una familia infinita de juegos gráficos en árboles de grados limitados con el ancho de ruta 2, de modo que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales. Es interesante observar que los árboles utilizados en la prueba del teorema 3 tienen el camino de ruta 2, es decir, están muy cerca de ser caminos. Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinomial para gráficos de vía de ruta 1. Esta pregunta puede verse como una generalización de un problema de geometría computacional muy natural: la describimos con más detalle en la Sección 8. En la Sección 7, damos un resultado de la intratabilidad teórica de complejidad para el problema de encontrar un equilibrio NASH de un juego gráfico en un gráfico con un pequeño ancho de ruta. Probamos el siguiente teorema. Teorema 4. Considere el problema de encontrar un equilibrio de Nash para un juego gráfico en el que el gráfico subyacente tiene el máximo grado 3 y el ancho de ruta k.Hay una K constante de tal manera que este problema es complete PPAD. El teorema 4 limita la medida en que podemos explotar las propiedades similares a la ruta del gráfico subyacente, para encontrar equilibrios de Nash. Para probar el teorema 4, utilizamos resultados recientes de completidad de PPAD para juegos, en particular los documentos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en los juegos gráficos de grado D (para d ≥ 3) es computacionalmente equivalente alProblema de resolver juegos de forma normal del jugador R (para R ≥ 4), los cuales son completos PPAD.2. Preliminares y notación consideramos juegos gráficos en los que el gráfico subyacente G es un árbol N-Vértice. Cada vértice tiene dos acciones, que se denotan por 0 y 1. Una estrategia mixta viene dada por un solo número x ∈ [0, 1], que denota la probabilidad de que el jugador seleccione la acción 1. Fur Los propósitos del algoritmo, el árbol está arbitrariamente arbitrariamente. Por conveniencia, suponemos sin pérdida de generalidad que la raíz tiene un solo hijo, y que su recompensa es independiente de la acción elegida por el niño. Esto se puede lograr eligiendo primero una raíz arbitraria del árbol, y luego agregando un padre ficticio de esta raíz, dando al nuevo padre una función de pago constante. Dado un borde (v, w) del árbol g, y una estrategia mixta w para w, deje que g (v, w), w = w sea la instancia obtenida de g al (1) eliminar todos los nodos z que están separados deV Por W (es decir, todos los nodos z de tal manera que la ruta de Z a V pasa a través de W), y (2) restringiendo la instancia para que W esté obligado a jugar estrategia mixta W.Definición 1. Supongamos que (V, W) es un borde del árbol, que V es una estrategia mixta para V y que W es una estrategia mixta para w.101 Decimos que V es una mejor respuesta potencial a W (denotada por V ∈ PBRV (W)) Si hay un equilibrio en la instancia G (V, W), W = W en la que V tiene una estrategia mixta v. DefinimosLa mejor política de respuesta para V, dada W, como B (W, V) = {(W, V) |v ∈ PBRV (W), W ∈ [0, 1]}. Por lo general, W es el padre de V, y esto se conoce como la mejor política de respuesta para V. La expresión B (W, V) | V = V se usa para denotar el conjunto B (W, V) ∩ [0, 1] × {V}. El pase aguas arriba del algoritmo genérico de [8] calcula la mejor política de respuesta para V para cada nodo V que no sea la raíz. Con los supuestos anteriores sobre la raíz, el pase aguas abajo es sencillo: deje que W denote la raíz y v denote a su hijo. La raíz selecciona cualquier par (W, V) de B (W, V). Decide tocar la estrategia mixta W y le indica a V que reproduce la estrategia mixta v. El resto del pase descendente es recursivo. Cuando su padre le instruye a un nodo V para que adopte la estrategia mixta V, hace lo siguiente para cada niño u, encuentra un par (v, u) ∈ B (v, u) (con el mismo valor V que se le diopor su padre) y te indica que te toces.3. Algoritmo de Littman et al. El algoritmo de [9] se basa en la siguiente observación: para calcular un solo equilibrio de Nash por un algoritmo de dos pasos, no es necesario construir toda la mejor política de respuesta para cada vértice. Mientras, en cada paso del pase aguas abajo, el vértice bajo consideración puede seleccionar un vector de estrategias para todos sus hijos para que cada estrategia de cada niño sea una mejor respuesta potencial a la estrategia de los padres, el algoritmo tiene éxito en producir un equilibrio NASH. Esto se puede lograr si, al comienzo del pase aguas abajo, tenemos una estructura de datos en la que cada vértice V con el padre w almacena un conjunto ˆb (w, v) ⊆ b (w, v) (llamada política de punto de ruptura) queCubre todos los posibles w ∈ [0, 1]. Más tarde mostraremos que una condición suficiente para la construcción de dicha estructura de datos es el invariante que, en cada nivel del pase aguas arriba, ˆb (W, V) contiene un camino continuo de W = 0 a W = 1. En [9], se sugiere que podemos seleccionar la política de punto de interrupción de una manera particular. A saber, el documento usa la siguiente definición: Definición 2. (cf. [9]) Una política de punto de interrupción para un nodo V con el padre w consiste en un conjunto ordenado de w -breakpoints w0 = 0 <w1 <w2 <· · · <<WT -1 <WT = 1 y un conjunto asociado de Values V V1 ,..., Vt. La interpretación es que para cualquier w ∈ [0, 1], si wi - 1 <w <wi para algunos índices i y w juega w, entonces v jugará vi;y si w = wi para algún índice i, V jugará cualquier valor entre vi y vi+1. Decimos que tal política de punto de ruptura tiene puntos de interrupción T - 1. Luego, el documento afirma que cualquier vértice V puede calcular su política de punto de interrupción con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1 ,..., Reino Unido. La prueba se realiza ordenando los puntos de interrupción de los niños (es decir, los valores respectivos de V) de izquierda a derecha (se puede suponer sin pérdida de generalidad que todos estos puntos de interrupción son distintos) y considerarlos a su vez;cada uno de esos puntos vl ∈ {v1 ,..., VL} corresponde a una elección fija de estrategias para niños k - 1 y un intervalo de estrategias admisibles para un niño. Suponga por conveniencia que este niño es U1 y su intervalo de estrategias admisibles en VL es [A, B];Suponga también que para UJ, J = 2 ,..., K, sus respectivas políticas de punto de ruptura los prescriben para jugar UJ en respuesta a VL. Sea p i (u, w), i = 0, 1, la recompensa esperada para V cuando v juega i, u1 juega u, cada UJ, j = 2 ,..., k, juega UJ, y W juega w, y considere el conjunto wl = {w ∈ [0, 1] |∃u ∈ [A, B] S.T. P 0 (u, w) = p1 (u, w)};Tenga en cuenta que para cualquier w ∈ Wl tenemos vl ∈ PBRV (W).V1 V2 V3 V4 V5 V6 V7 V W Figura 1: LKS: recorte para encontrar políticas de punto de interrupción. Los autores muestran que para cualquier punto de interrupción VL, el conjunto WL está vacío, un solo intervalo o una unión de dos intervalos no flotantes (un intervalo no flota si uno de sus puntos finales es 0 o 1);Además, la unión de todos los conjuntos WL, L = 1 ,..., L, cubre el intervalo [0, 1]. Se deduce fácilmente que uno puede cubrir [0, 1] con los intervalos L+2, cada uno de los cuales es un subconjunto de algún WL. Luego, los autores afirman que cualquier cobertura puede transformarse en una política de punto de ruptura para V. A saber, dicen que para dos intervalos WL1 y WL2 en la cubierta, cualquier superposición entre WL1 y WL2 puede ser asignada arbitrariamente la cobertura por WL1 y WL2 recortada en consecuencia (cf. [9], p. 5). Ilustran su enfoque en una figura, que se reproduce como la Figura 1 aquí. En la figura, las líneas horizontales discontinuas representan los puntos de interrupción V1, V2 ,..., V7 y los intervalos sólidos a lo largo de estos puntos de interrupción son los conjuntos W1, W2 ,..., W7. La ruta conectada gruesa es la política de punto de ruptura correspondiente. Se elige de la siguiente manera: comience a la izquierda y siempre salte al intervalo, lo que permite el mayor progreso a la derecha. Para ver por qué este enfoque no funciona en general, considere una ruta de longitud 4 que consiste en una raíz indiferente R, su hijo W, W S Child V y V S Child U. Supongamos que recibe una recompensa de 1 si juega de manera diferente a V y 0 de lo contrario. Por lo tanto, si V denota la estrategia mixta de V (es decir, V juega 1 con probabilidad V), entonces la recompensa esperada que U deriva de jugar 0 viene dada por P0 (u) = V y la recompensa esperada que U deriva de jugar 1P1 (u) = 1 - v. Suponga que V no deriva el pago de la jugada 1 (entonces p1 (v) = 0) y que su matriz de pago para jugar 0 es 1 −9 9 −1, por lo que si u denotaLa estrategia mixta de U y W denota la estrategia mixta de W, la recompensa esperada que V deriva de jugar 0 viene dada por P0 (v) = (1 - u) (1 - w) + (1 - u) W (−9) + U (1 - W) 9 + UW (−1). Usando las técnicas de [8] (o, alternativamente, las de la Sección 4), no es difícil verificar que las mejores políticas de respuesta para U y V (como en la definición 1) estén dadas por los gráficos en la Figura 2. La mejor política de respuesta para U es una política de punto de ruptura para U (como en la definición 2) con V -BreakPoints V0 = 0, V1 = 1/2 y V2 = 1 con valores asociados U1 = 1 y U2 = 0. La mejor política de respuesta para V no es una política de punto de ruptura (debido a cómo la curva de W = 0 a W = 1 se duplica). El algoritmo LKS recortaría para obtener una política de punto de interrupción, como la de la Figura 3. Tenga en cuenta que esta política de punto de interrupción ˆB (W, V) no es válida en el sentido de que no satisface ˆB (W, V) ⊆ B (W, V).102 1 10.5 0.5 1 10.1 0.9 U V V W Figura 2: Mejores políticas de respuesta para U y V.0.1 0.9 1 0.5 1 V W Figura 3: Una política recortada para V El punto es que la matriz de pago de W ahora se puede elegir para evitar que el algoritmo LKS encuentre un equilibrio de Nash. Por ejemplo, suponga que los pagos se dan de modo que P0 (W) = V y P1 (W) = (1 - V) 2. La mejor política de respuesta para W es una línea horizontal en W = .1 (este es el valor de W que permite v = 2/3 - ver Figura 2, que hace p0 (w) = p1 (w).). En el paso hacia abajo, los valores elegidos son w = .1, entonces, desde el recorte, v = 0 y u = 1, que no es un equilibrio de Nash ya que W prefiere la acción 1. El fracaso del algoritmo no es causado por el hecho de que la política de recorte va lo más posible a la derecha. Cualquier otro recorte sería igual de malo. Por ejemplo, suponga que la política de punto de interrupción para V tiene V = 0 hasta algún punto w ∗ <.9 y luego salta a V = 1. El algoritmo es derrotado por la matriz de pago con p 0 (w) = 2v y p1 (w) = (1 - v) en la que la mejor política de respuesta para W es una línea horizontal en W = .9. El algoritmo luego da w = .9, v = 1 y u = 0, que no es un equilibrio de Nash ya que W prefiere la acción 0. Concluimos que el algoritmo LKS no siempre encuentra un equilibrio de Nash. En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un equilibrio de Nash. Para el algoritmo modificado, tenemos que extender la definición de política de punto de interrupción (ver definición 3) para que incluya políticas de punto de ruptura, como la mejor política de respuesta para V en la Figura 2. Desafortunadamente, dicha política de punto de interrupción puede tener un tamaño exponencial (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinomial en todos los árboles. En la siguiente sección, mostramos que se ejecuta en tiempo polinomial en un camino.4. Encontrar equilibrios en una ruta en esta sección, nos enfocamos en el caso cuando el gráfico subyacente es una ruta, es decir, su conjunto de vértices es {V1 ,..., Vn}, y su conjunto de borde es {(vj, vj+1) |j = 1 ,..., n - 1}. Mostramos que en este caso la mejor política de respuesta para cada vértice puede representarse como una unión de un número polinomial de rectángulos, donde un rectángulo está definido por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos en IV ×Iu;Puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto. Teorema 5. Para cualquier j = 1 ,..., n, el conjunto B (VJ, VJ - 1) puede representarse como una unión disjunta de los rectángulos de 2 (j + 4) 2. Además, dada dicha representación de B (VJ, VJ - 1), se puede calcular una representación de B (VJ+1, VJ) en el tiempo O (J2). PRUEBA. Para cualquier conjunto A ⊆ [0, 1] 2 que se represente como una unión de un número finito de rectángulos, decimos que un punto u ∈ [0, 1] en el eje U es un punto de evento U de un IF ifu = 0 o u = 1 o a contiene un rectángulo de la forma IV × IU y U es un punto final de IU;Los puntos de eventos V se definen de manera similar. Observe que para cualquier u ∈ [0, 1], el número de componentes conectados de [0, 1] × {u} ∩ a es como máximo el número de puntos de eventos V de A. Utilizamos la inducción en J para mostrar que para cada VJ la declaración del teorema se mantiene y, además, cada B (VJ, VJ - 1) tiene como máximo los puntos de evento 2J + 4. Para simplificar el estuche base, modificamos el juego gráfico agregando un vértice ficticio V0 al comienzo de la ruta: el único vecino de V0 es V1, los pagos de V0 siempre son iguales a 0, y los pagos de todos los demás vértices ((incluyendo V1) son los mismos que en el juego original. Para J = 0, tenemos B (V1, V0) = [0, 1] 2, por lo que la declaración del teorema es trivialmente verdadera. Ahora, supongamos que j> 0, establece v = vj y deje u = vj - 1 y w = vj+1 sean los vértices que preceden y siguen a V, respectivamente. Los pagos a V se describen mediante una matriz 2 × 2 × 2 P: Pxyz es la recompensa que V recibe cuando U juega x, V juega y y w juega z, donde x, y, z ∈ {0, 1}. Supongamos que U juega 1 con probabilidad U y W juega 1 con probabilidad w.Entonces V S El recompensa esperado de jugar 0 es P0 = (1 - U) (1 - W) P000+(1 - U) WP001+U (1 - W) P100+UWP101, mientras que su recompensa esperado de jugar 1 es P1 = (((1 - u) (1 - W) P010+(1 - u) WP011+U (1 - W) P110+UWP111. Si P 0> P1, V prefiere estrictamente jugar 0, si P0 <P1, V prefiere estrictamente jugar 1, y si P0 = P1, V es indiferente, es decir, puede jugar cualquier estrategia (mixta). Dado que P0 y P1 son lineales en W y U, existen algunas constantes A1, A0, B1 y B0 que dependen de la matriz P, pero no de U y W, de modo que P0 - P1 = W (B1U + B0) - -(A1U + A0).(1) Dependiendo de los valores de A1, A0, B1 y B0, subdividimos el resto de la prueba en los siguientes casos.• B1 = 0, B0 = 0. En este caso, p0> p1 si y solo si a1u + a0 <0. Si también a1 = 0, a0 = 0, claramente, b (w, v) = [0, 1] 2, y la declaración del teorema es trivialmente verdadera. De lo contrario, el vértice V es indiferente entre 0 y 1 si y solo si a1 = 0 y u = −a0/a1. Sea V = {V |v ∈ (0, 1), −a0/a1 ∈ Pbru (v)}. Por la hipótesis inductiva, V consiste en como máximo 2 (j - 1) + 4 segmentos y puntos aislados. Para cualquier v ∈ V, tenemos B (W, V) | V = V = [0, 1]: No importa lo que juegue W, siempre y cuando u esté jugando −a0/a1, V está contento de jugar V.la otra mano, para cualquier v ∈ (0, 1) \\ V tenemos B (W, V) | V = V = ∅: Cuando V juega V, solo puede responder con U = −a0/a1, en cuyo casoV puede beneficiarse de cambiar a una de las estrategias puras. Para completar la descripción de B (W, V), queda para analizar los casos V = 0 y V = 1. El vértice V prefiere jugar 0 si a1> 0 y u ≤ −a0/a1, o a1 <0 y u ≥ −a0/a1, o 103 a1 = 0 y a0 <0. Suponga por ahora que a1> 0;Los otros dos casos pueden tratarse de manera similar. En este caso 0 ∈ PBRV (W) para algunos w ∈ [0, 1] si y solo si existe una u ∈ PBru (0) de modo que U ≤ −a0/a1: si no existe tal u, siempre que V juega 0La respuesta estadounidense no está en PBRU (0) o V puede mejorar su recompensa jugando 1. Por lo tanto, B (W, V) | V = 0 = [0, 1] o B (W, V) | V = 0 = ∅. Del mismo modo, B (W, V) | V = 1 es igual a [0, 1] o ∅, dependiendo de PBRU (1). Por lo tanto, el conjunto B (W, V) consiste en como máximo 2J + 4 ≤ (j + 4) 2 rectángulos: B (W, V) ∩ [0, 1] × (0, 1) = [0, 1]× V contribuye como máximo 2J + 2 rectángulos, y cada uno de los conjuntos B (W, V) | V = 0 y B (W, V) | V = 1 contribuye como máximo un rectángulo. Del mismo modo, su número total de puntos de eventos es como máximo 2J + 4: los únicos puntos de eventos W son 0 y 1, cada punto de eventos V de B (W, V) es un punto de eventos V de B (V, U), y hay como máximo 2J + 2 de ellos.• B1U + B0 ≡ 0, A1 = αB1, A0 = αB0 para algunos α ∈ R. En este caso, V es indiferente entre 0 y 1 si y solo si W = α, o B1 = 0 y U = −B0/B1= −a0/a1. De manera similar al caso anterior, podemos mostrar que B (W, V) ∩ [0, 1] × (0, 1) consiste en el rectángulo {α} × [0, 1] y como máximo rectángulos 2J + 2 delFormulario [0, 1] × IV, donde cada IV corresponde a un componente conectado de B (V, U) | U = −B0/B1. Además, V prefiere jugar 0 si B1U + B0> 0 y W ≥ α o B1U + B0 <0 y W ≤ α. Por lo tanto, si b1u ∗ + b0> 0 para algunos u ∗ ∈ Pbru (0), entonces b (w, v) | v = 0 contiene [α, + ∞) ∩ [0, 1] y si b1u ∗∗ + b0<0 para algunos u ∗∗ ∈ Pbru (0), entonces b (w, v) | v = 0 contiene [−∞, α] ∩ [0, 1];Si tanto u ∗ y u ∗∗, b (w, v) | v = 0 = [0, 1]. El conjunto B (W, V) | V = 1 se puede describir de manera similar. Por la hipótesis inductiva, B (V, U) tiene como máximo los puntos de evento 2J + 2;Como al menos dos de estos son puntos de evento U, tiene como máximo los puntos de eventos de 2J V. Dado que cada punto de eventos V de B (W, V) es un punto de vegent de B (V, U) y B (W, V) tiene como máximo 3 puntos de eventos W (0, 1 y α), su totalEl número de puntos de eventos es como máximo 2J + 3 <2J +4. Además, de manera similar al caso anterior, se deduce que B (W, V) consta de como máximo 2J + 4 <(j + 4) 2 rectángulos.• B1U + B0 ≡ 0, α (B1U + B0) ≡ A1u + A0. En este caso, se puede definir la función de indiferencia f (·) como f (u) = a (u) b (u) = a1u+a0 b1u+b0, donde a (u) y b (u) nunca se convierten en cerosimultáneamente. Observe que cada vez que w = f (u) y u, w ∈ [0, 1], V es indiferente entre jugar 0 y 1. Para cualquiera a ⊆ [0, 1] 2, definimos una función ˆfv por ˆfv (a) = {(f (u), v) |(v, u) ∈ A};Tenga en cuenta que ˆFV mapea subconjuntos de [0, 1] 2 a subconjuntos de R × [0, 1]. A veces dejamos caer el subíndice V cuando está claro desde el contexto. Lema 1. Para cualquier (W, V) ∈ [0, 1] × (0, 1) tenemos (W, V) ∈ B (W, V) si y solo si existe una u ∈ [0, 1] tal que (V (V, u) ∈ B (V, U) y W = F (U). PRUEBA. FIJA UN ARBITRARIO V ∈ (0, 1). Supongamos que U juega algunos u ∈ PBru (V), w = f (u) satisface w ∈ [0, 1] y w juega w.Existe un vector de estrategias V1 ,..., VJ - 1 = U, VJ = V tal que para cada VK, k <j, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Como W = F (U), V es indiferente entre jugar 0 y 1;En particular, puede jugar v. Por lo tanto, si definimos VJ+1 = W, el vector de estrategias (V1, ..., VJ+1) satisfará las condiciones en la definición de la mejor respuesta potencial, es decir, tenemosv ∈ PBRV (W). Por el contrario, suponga que v ∈ PBRV (W) para algunos w ∈ [0, 1], v = 0, 1. Luego existe un vector de estrategias v1 ,..., VJ - 1, VJ = V, VJ+1 = W de tal manera que para cada VK, K ≤ J, su estrategia es una mejor respuesta a las estrategias de sus vecinos. Como V = 0, 1, V es, de hecho, indiferente entre jugar 0 y 1, lo cual solo es posible si W = F (VJ - 1). Elegir u = vj - 1;por construcción, u ∈ Pbru (v). Lemma 1 describe las situaciones en que V es indiferente entre jugar 0 y jugar 1. Sin embargo, para caracterizar completamente B (W, V), también necesitamos saber cuándo V prefiere una estrategia pura. Definir ˆf (0) = ∪u∈Pbru (0) Ru, donde ru = ´ [f (u), +∞) × {0} si b (u)> 0, (−∞, f (u)] ×{0} si b (u) <0. y ˆf (1) = ∪u∈Pbru (1) ru, donde ru = ´ [f (u), +∞) × {1} si b (u) <0, (−∞, f (u)] × {1} si b (u)> 0. Lema 2. Para cualquier w ∈ [0, 1], tenemos (w, 0) ∈ ˆf (0) si y solo si 0 ∈ PBRV (W) y (w, 1) ∈ ˆf (1) si y solo si 1 ∈ PBRV(W). PRUEBA. Considere un U0 ∈ PBRU (0) arbitrario. Si b (u0)> 0, para u = u0 la desigualdad p0 ≥ p1 es equivalente a w ≥ f (u0). Por lo tanto, cuando U juega U0 y W juega w, w ≥ f (u0), V prefiere jugar 0;Como U0 ∈ PBru (U), se deduce que 0 ∈ PBRV (W). El argumento para el caso B (U0) <0 es similar. Por el contrario, si 0 ∈ PBRV (W) para algunos w ∈ [0, 1], existe un vector (V1, ..., VJ - 1, VJ = 0, VJ+1 = W) tal que para cada VK,K ≤ J, VK juega VK, y esta estrategia es una mejor respuesta a las estrategias de los vecinos de VKS. Tenga en cuenta que para cualquier vector tenemos vj - 1 ∈ PBRU (0). A modo de contradicción, suponga (w, 0) ∈ ë u∈Pbru (0) ru. Entonces debe ser el caso de que para cualquier u0 ∈ Pbru (0) F (u0) <w y ru0 = (−∞, f (u0)] × {0} o f (u0)> w y ru0 = [f(u0), +∞) × {0}. En ambos casos, cuando V juega 0, U juega U0, y V juega W, la desigualdad entre F (U0) y W es equivalente a P0 <P1, es decir, V se beneficiaría de cambiar a 1. El argumento para ˆf (1) es similar. Juntos, Lemma 1 y Lemma 2 describen completamente el conjunto B (W, V): tenemos B (W, V) = ˆf (0) ∪ ˆf (B (V, U)) ∪ ˆf (1) [0, 1] 2. Queda por mostrar que B (W, V) puede representarse como una unión de los rectángulos como máximo (j + 4) 2, tiene como máximo los puntos de evento 2J + 4 y se puede calcular en el tiempo O (J2). Establecer u ∗ = −b0/b1.2 Considere un rectángulo arbitrario R = [V1, V2] × [U1, U2] ⊆ B (V, U). Si u ∗ ∈ [u1, u2], la función f (·) es continua en [u1, u2] y, por lo tanto, ˆf (r) = [fmin, fmax] × [v1, v2], donde fmin = min {f (f (f (f (u1), f (u2)}, fmax = max {f (u1), f (u2)}, es decir, en este caso ˆf (r) ∩ [0, 1] 2 consiste en un solo rectángulo. Ahora, supongamos que R se cruza con la línea [0, 1] × {u ∗};Como se observó anteriormente, hay como máximo 2J+2 de estos rectángulos. Supongamos que limu → u ∗ - f (u) = +∞;Como f (·) es una función lineal fraccional, esto implica que Limu → U ∗+ F (u) = −∞ y también F (u1)> f (u2). Dado que f (·) es continuo en [u1, u ∗) y (u ∗, u2], es fácil ver que ˆf ([v1, v2] × [u1, u ∗)) = [f (u1),+∞) × [V1, V2] 2 El caso B1 = 0 no causa problemas especiales. Para completar, configure U ∗ para ser cualquier valor fuera de [0, 1] en este caso.104 v u v u* 1 f (0) f (a) f (b) f (1) a b (0, 0) w v 2 V (0, 0) 1 1 V 2 V 1 1 Figura 4: F está aumentando (−∞, u ∗) y (u ∗, +∞).y ˆF ([V1, V2] × (U ∗, U2]) = (−∞, F (U2)] × [V1, V2], es decir, en este caso ˆf (R) ∩ [0, 1] 2 consistede la mayoría de los dos rectángulos. El caso limu → u ∗ - f (u) = −∞ es similar. Como ˆf (b (v, u)) = ë r⊂b (v, u) ˆf (r), se deduce que ˆf (b (v, u)) consiste en como máximo (j + 3) 2 + 2j +2 rectángulos. Además, es fácil ver que tanto ˆf (0) como ˆf (1) consisten en la mayoría de los 2 segmentos de línea cada uno. Concluimos que B (W, V) puede representarse como una unión de la mayoría de los rectángulos como máximo (j + 3) 2 + 2j + 6 <(j + 4) 2. Además, si V es un punto de evento V de B (W, V), entonces V es un punto de vegents de B (V, U) (esto incluye los casos v = 0 y V = 1, como 0 y 1 son V V =-Sevent Puntos de b (v, u)) y si w es un punto de evento w de b (w, v), entonces w = 0 o w = 1 o existe algunos u ∈ [0, 1] de modo quew = f (u) y u es un punto de evento U de b (v, u). Por lo tanto, B (W, V) tiene como máximo los puntos de evento 2J + 4. El O (J2) atado en el tiempo de ejecución en el Teorema 5 se deduce de nuestra descripción del algoritmo. Sigue la O (N3) en el tiempo de ejecución general para encontrar un equilibrio de Nash (y una representación de todos los equilibrios de Nash).4.1 Encontrar un solo equilibrio de Nash en el tiempo O (N2) El límite superior en el tiempo de ejecución de nuestro algoritmo es apretado, al menos suponiendo la implementación directa, en la que cada B (VJ+1, VJ) se almacena como una unión de rectángulos: No es difícil construir un ejemplo en el que el tamaño de B (VJ+1, VJ) es Ω (J2). Sin embargo, en algunos casos no es necesario representar todos los equilibrios de Nash;Más bien, el objetivo es encontrar un equilibrio arbitrario del juego. En esta sección, mostramos que este problema se puede resolver en tiempo cuadrático, obteniendo así una prueba del teorema 1. Nuestra solución se basa en la idea de [9], es decir, trabajar con subconjuntos de las mejores políticas de respuesta en lugar de las mejores políticas de respuesta en sí;Después de [9], nos referiremos a subconjuntos como políticas de punto de interrupción. Si bien no siempre es posible construir una política de punto de ruptura como se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una política de punto de interrupción;Además, demostramos que para un gráfico de ruta, la política de punto de interrupción de cualquier vértice se puede almacenar en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice. Definición 3. Una política de punto de interrupción ˆB (V, U) para un vértice u cuyo padre es V es una curva no interna de la forma x1 ∪ y1 ∪ · · · ∪ ym-1 xm, donde xi = [vi-1,vi] × {ui}, yi = {vi} × [ui, ui+1] y ui, vi ∈ [0, 1] para i = 0 ,..., m.Decimos que una política de punto de interrupción es válida si v0 = 0, vm = 1 y ˆb (v, u) ⊆ b (v, u). A veces abusaremos de la notación al referirnos a ˆB (V, U) como una colección de segmentos xi, yi en lugar de su unión. Tenga en cuenta que no requerimos que vi ≤ vi+1 o ui ≤ ui+1;En consecuencia, en cualquier argumento que involucre políticas de punto de interrupción, todos los segmentos deben tratarse como segmentos dirigidos. Observe que cualquier política de punto de ruptura válida ˆB (V, U) puede verse como un mapeo 1-1 continuo γ (t) = (γv (t), γu (t)), γ: [0, 1] → [0,1] 2, donde γ (0) = (0, u1), γ (1) = (1, um) y existen algunos t0 = 0, t1 ,..., t2m - 2 = 1 tal que {γ (t) |t2k ≤ t ≤ t2k+1} = xk+1, {γ (t) |t2k+1 ≤ t ≤ t2k+2} = yk+1. Como se explica en la Sección 3, podemos usar una política de punto de interrupción válida en lugar de la mejor política de respuesta durante el pase posterior, y aún así garantizar que al final, generaremos un equilibrio de Nash. El teorema 6 muestra que uno puede calcular inductivamente políticas de punto de interrupción válidas para todos los vértices en la ruta;La prueba de este teorema se puede encontrar en la versión completa de este documento [6]. Teorema 6. Para cualquier V = VJ, uno puede encontrar en el tiempo polinomial una política de punto de interrupción válida ˆB (W, V) que consiste en la mayoría de los segmentos 2J + 1.5. Equilibrios de Nash en gráficos con el máximo grado 2 En esta sección, mostramos cómo se puede aplicar el algoritmo para rutas para resolver un juego en cualquier gráfico cuyos vértices tienen un título como máximo 2. Un gráfico que tiene el máximo grado 2 es, por supuesto, una unión de caminos y ciclos. Dado que cada componente conectado se puede manejar de forma independiente, para obtener una prueba del Teorema 2, solo necesitamos mostrar cómo lidiar con los ciclos. Dado un ciclo con vértices V1 ,..., VK (en orden cíclico), hacemos dos búsquedas separadas para un equilibrio de Nash: primero buscamos un equilibrio de Nash donde algunos vértices juegan una estrategia pura, luego buscamos un equilibrio NASH completamente mixto, donde todos los vértices juegan estrategias mixtas. Para I ≤ k, vi vi denotar la probabilidad de que VI juegue 1. La primera búsqueda se puede hacer de la siguiente manera. Para cada i ∈ {1 ,..., k} y cada b ∈ {0, 1}, haga lo siguiente.1. Deje que P sea la ruta (VI+1, VI+2 ..., VK, V1, ..., VI - 1, VI) 2. Deje que la recompensa a VI+1 se base en poner VI = B (por lo que depende solo de VI+1 y VI+2.) 3. Aplique el pase aguas arriba a P 4. Poner vi = b;Aplique el pase aguas abajo para cada vértice, VJ, realice un seguimiento de todas las estrategias mixtas posibles VJ 5. Compruebe si VI+1 tiene alguna respuesta que sea consistente con VI = B;Si es así, tenemos un equilibrio de Nash.(De lo contrario, no hay un equilibrio de Nash de la forma deseada). Para la segunda búsqueda, tenga en cuenta que si VI juega una estrategia mixta, entonces VI + 1 y VI - 1 satisfacen una ecuación de la forma VI + 1 = (A0 + A1VI - 1)/(B0 + B1VI - 1). Dado que todos los vértices en el ciclo juegan estrategias mixtas, tenemos VI+3 = (A0+A1VI+1)/(B0+B1VI+1). Componiendo las dos transformaciones fraccionales lineales, obtenemos VI +3 = (A0 +A1 VI - 1)/(B0 +B1 VI - 1).Para algunas constantes nuevas A0, A1, B0, B1. Elija cualquier vértice VI. Podemos expresar VI en términos de VI+2, luego VI+4, VI+6, etc. y, en última instancia, VI para obtener una ecuación cuadrática (para VI) que es fácil de obtener de los pagos en el juego. Si la ecuación no es trivial, tiene como máximo 2 soluciones en (0, 1). Para un ciclo de longitud impar, todos los demás VJ son derivables de esas soluciones, y si existe un equilibrio NASH completamente mixto, todo el VJ debería ser números reales en el rango (0, 1). Para un ciclo de longitud uniforme, obtenemos dos ecuaciones cuadráticas, una para VI y otra para 105 VI+1, y podemos probar de la misma manera que alguna solución a estos valores de rendimiento para el otro VJ, todos los cuales se encuentran ((0, 1). Si la ecuación cuadrática es trivial, hay potencialmente un continuo de equilibrios totalmente mezclados. Los valores para VI que pueden ocurrir en un equilibrio de Nash son aquellos para los cuales todos los valores de VJ dependientes se encuentran en (0, 1);La última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo las transformaciones lineales fraccionales respectivas.6. Encontrar equilibrios en un árbol (arbitrario) para árboles arbitrarios, la estructura general del algoritmo sigue siendo el mismo, es decir, se puede construir una mejor política de respuesta (o, alternativamente, una política de punto de ruptura) para cualquier vértice basado en las mejores políticas de respuesta desus hijos. Suponemos que el grado de cada vértice está limitado por una constante K, es decir, la matriz de pago para cada vértice es de tamaño O (2K). Considere un vértice V cuyos hijos son U1 ,..., Reino Unido y cuyo padre es W;La mejor política de respuesta de cada UJ es B (V, UJ). De manera similar a la sección anterior, podemos calcular los pagos esperados de V S P0 y P1 para jugar 0 o 1, respectivamente. A saber, cuando cada uno de los UJ juega UJ y W juega w, tenemos p0 = l0 (u1, ..., Reino Unido, w), p 1 = l1 (u1, ..., Reino Unido, w), donde las funcionesL0 (·, ..., ·), L1 (·, ..., ·) son lineales en todos sus argumentos. Por lo tanto, la desigualdad p0> p1 puede reescribirse como wb (u1, ..., Reino Unido)> a (u1, .., Reino Unido), donde tanto a (·, ..., ·) como b (·,,.., ·) Son lineales en todos sus argumentos. Establecer u = (u1, ..., Reino Unido) y defina la función de indiferencia f: [0, 1] k → [0, 1] como f (u) = a (u)/b (u);Claramente, si cada UJ juega UJ, W juega W y W = F (U), V es indiferente entre jugar 0 y 1. Para cualquier x = x1 × · · · × xk, donde xi ⊆ [0, 1] 2 Define ˆf (x) = {(f (u), v) |(v, ui) ∈ Xi, i = 1 ,..., k} también, establecer ˆf (0) = {(w, 0) |∃u S.T.ui ∈ Pbrui (0) y wb (u) ≥ a (u)} y ˆf (1) = {(w, 1) |∃u S.T.ui ∈ Pbrui (1) y wb (u) ≤ a (u)}. Como en la sección anterior, podemos mostrar que B (W, V) es igual a ˆf (0) ∪ ˆf (B (V, U1) × · · · × B (V, Reino Unido)) ∪ ˆf (1) [0, 1] 2;Además, cualquier ruta de W = 0 a W = 1 que sea un subconjunto de B (W, V) constituye una política de punto de ruptura válida.6.1 Política de punto de interrupción del tamaño exponencial Si bien el algoritmo de la Sección 4 puede generalizarse para árboles limitados, su tiempo de ejecución ya no es polinomio. De hecho, lo contrario es cierto: podemos construir una familia de árboles y matrices de pago para todos los jugadores para que las mejores políticas de respuesta para algunos de los jugadores consistan en un número exponencial de segmentos. Además, en nuestro ejemplo, las políticas de punto de interrupción coinciden con las mejores políticas de respuesta, lo que significa que incluso encontrar un solo equilibrio de Nash utilizando el enfoque de [8, 9] tomará exponencialmente mucho tiempo. De hecho, una declaración más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de las mejores políticas de respuesta para este gráfico, podemos elegir los pagos de los vértices para que el pase posterior de este algoritmofallará. S 1 1 T S N - 1 00 0000 11 1111 00 0000 11 1111 0000 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0000 111111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 1111111111111111111111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 N - 1 N 2 N 1 N - 12 N-Size Política de punto de interrupción. En el resto de esta subsección, describimos esta construcción. Considere el árbol TN dado por la Figura 5;Deje que VN sea la raíz de este árbol. Por cada k = 1 ,..., n, deje que los pagos de SK y TK sean los mismos que los de U y V descritos en la Sección 3;Recuerde que las políticas de punto de interrupción para U y V se muestran en la Figura 2. No es difícil ver que la función de indiferencia para TK viene dada por f (s) = .8s+.1. El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 de lo contrario;La Política de mejor respuesta de V0 viene dada por la Figura 6. Lema 3. Fix K <n, y dejar U, T, V y W denotar las estrategias de VK - 1, TK, VK y VK+1, respectivamente. Supongamos que VK prefiere jugar 0 a jugar 1 si y solo si .5t + .1u + .2> w.Entonces B (VK+1, VK) consta de al menos 3k segmentos. Además, {(V, W) |(v, w) ∈ B (vk+1, vk), 0 ≤ w ≤ .2} = [0, .2] × {0} y {(v, w) |(V, W) ∈ B (VK+1, VK), .8 ≤ W ≤ 1} = [.8, 1] × {1}. PRUEBA. La prueba procede por inducción en k.Para k = 0, la declaración es obvia. Ahora, supongamos que es cierto para B (VK, VK - 1). Se puede ver B (VK+1, VK) como una unión de siete componentes: ˆf (0) ∩ [0, 1] × {0}, ˆf (1) ∩ [0, 1] × {1} y cincoComponentes que corresponden a los segmentos de B (VK, TK). Examinamos a su vez. Para describir ˆf (0) ∩ [0, 1] × {0}, tenga en cuenta que f (u, t) = .5t+.1u+.2 es monótono en t y u y satisface f (0, 0) = .2. Además, tenemos pBRVK - 1 (0) = {0} y pBrtk (0) = {0}. Para cualquier w ∈ [0, 1] tenemos f (0, 0) ≥ w si y solo si w ∈ [0, .2]. Concluimos que ˆf (0) ∩ [0, 1] × {0} = [0, .2] × {0}. Del mismo modo, se deduce que ˆf (1) ∩ [0, 1] × {1} = [.8, 1] × {1}. Definir s1 = {(f (u, 0), v) |(V, u) ∈ B (VK, VK - 1) ∩ [0, .9] × [0, 1]}, S2 = {(f (U, .5), V) |(V, u) ∈ B (VK, VK - 1) ∩ [.1, .9] × [0, 1]}, S3 = {(f (U, 1), V) |(V, u) ∈ B (VK, VK - 1) ∩ [.1, 1] × [0, 1]};Estos conjuntos corresponden a segmentos horizontales de B (VK, TK). Es fácil ver que S1, S2, S3 ⊂ B (VK+1, VK). Dado que F es una función continua, el número de segmentos en cada SI es al menos el número de segmentos en B (VK, VK - 1) ∩ [.1, .9] × [0, 1], que es al menos 3K−1 por hipótesis de inducción. Además, como F es monótono en U y F (1, 0) <f (0, .5) <f (1, .5) <f (0, 1), todos Si, i = 1, 2, 3,son disjuntos. Finalmente, el conjunto B (VK+1, VK) contiene dos segmentos que corresponden a los segmentos verticales de B (VK, Tk), es decir, S4 = {(F (0, T), .1) |t ∈ [.5, 1]) = [.45, .7] × {.1} y s5 = {(f (1, t), .9) |t ∈ [0, .5]) = [.3, .55] × {.9}. Claramente, S4 conecta S2 y S3, S5 conecta S1 y S2, y S4 y S5 no se cruzan entre sí. Concluimos que B (Vk+1, VK) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V v 21 10 1 10.Figura 6: Políticas de punto de interrupción para V0 y V1.es una línea continua que consiste en al menos 3k segmentos y satisface la condición del lema. Para completar la construcción, debemos demostrar que podemos diseñar la matriz de pago para VK para que prefiera jugar 0 a jugar 1 si y solo si .5t + .1u + .2> w.Con este fin, demostramos una declaración más general, a saber, que la función de indiferencia de un vértice puede ser una función multilineal fraccional arbitraria de sus estrategias de descendientes. Decimos que una función de las variables K es multilineal si se puede representar como una suma de monomiales y cada uno de estos monomiales es lineal en todas sus variables. Tenga en cuenta que esta definición es diferente de una más estándar en el sentido de que no requerimos que todos los monomiales tengan el mismo grado. Recuerde que los pagos de un vértice con vecinos K + 1 son descritos por las matrices P0 y P1, donde PJ I0i1 ... IK es la recompensa que V recibe cuando juega J, y sus vecinos juegan i0 ,..., IK, y J, i0 ,..., ik ∈ {0, 1}. Sea P [J] = P [J] (W, U1, ..., Reino Unido) el pago esperado obtenido por este vértice cuando juega J y las estrategias (mixtas) de sus vecinos están dadas por un vector (W,U1, ..., Reino Unido), es decir, p [j] = e [p j i0i1 ... ik] donde i0 ,..., son variables aleatorias independientes de Bernoulli, cada una de las cuales es 1 con las probabilidades respectivas W, U1 ,..., Reino Unido. Lema 4. Dado un árbol vértice V cuyo padre es w y cuyos hijos son U1 ,..., Reino Unido, para cualquier función F = F (U1, ..., Reino Unido) que puede representarse como una relación de dos funciones multilineales F1, F2, es decir, F = F1 (U1, ..., Reino Unido) F2 (U1, ..., Reino Unido), existen matrices de pago P0 y P1 para V tal que P [0] - P [1] = WF2 (U1, ..., Reino Unido) - F1 (U1, .., Reino Unido). La prueba de este lema se basa en el hecho de que cada monomio de la forma como (u0) s0...(Reino Unido) SK, S1 ,..., sk ∈ {0, 1}, puede representarse como t = t0 ... tk∈σk+1 ct (u0) t0 (1 - u0) 1 - t0...(Reino Unido) Tk (1 - Reino Unido) 1 - Tk para algunos CT, t ∈ {0, 1} K+1. Los detalles se pueden encontrar en la versión completa de este documento [6].6.2 Irreducibilidad de la mejor política de respuesta para TN Si bien la mejor política de respuesta construida en la subsección anterior tiene un tamaño exponencial, no está claro `a priori que es necesario realizar un seguimiento de todos sus segmentos de línea en lugar de concentrarse en un pequeñosubconjunto de estos segmentos. Sin embargo, resulta que para los algoritmos de dos pasos, como el algoritmo de [8], la mejor política de respuesta no puede simplificarse. Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasos si 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1 1 1 1 11 1 00000000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de interrupción para V2.• A consiste en un pase aguas arriba y un pase aguas abajo.• Durante el pase ascendente, para cada vértice V con el padre W, A construye un conjunto BB (W, V) ⊆ B (W, V). Este conjunto se produce a partir de los conjuntos {BB (V, U) |U es un hijo de V} aplicando el procedimiento desde el comienzo de la Sección 6 (sustituyendo BB (V, UJ) por B (V, UJ) para todos los niños UJ de V), y luego posiblemente omitiendo algunos de los puntos de los puntos delConjunto resultante (que luego se almacena explícitamente).• El pase aguas abajo es idéntico al paso aguas abajo de [8] como se describe en la Sección 2, excepto que funciona en los conjuntos BB (W, V) en lugar de en los conjuntos B (W, V). Teorema 7 demuestra que cualquier algoritmo de dos pasos fallará durante el pase posterior en TN si hay un índice j tal que el conjunto BB (VJ+1, VJ) omite cualquier punto interior de cualquiera de los (al menos 3J) de los segmentos deB (VJ+1, VJ). Esto implica el Teorema 3. Teorema 7. Para cualquier algoritmo de dos pasos A para el que existe un índice j, j ∈ [1, n/4], un segmento S de B (VJ, VJ-1) y un punto interior (x, y) de S.Que BB (VJ, VJ - 1) no contiene (x, y), podemos elegir matrices de pago de los vértices VJ ,..., VN para que el pase posterior de A falle y, además, pagos a V4J ,..., VN es idénticamente 0. Dibujamos la prueba del teorema 7;Los detalles se pueden encontrar en la versión completa de este documento [6]. Procedemos por inducción. Para J = 1, el argumento es similar al de la Sección 3. Para el paso inductivo, la idea principal es que podemos acercarnos a cualquier parte de una mejor política de respuesta (¡incluida la parte que se omitió!) Al usar una función de indiferencia apropiada;Esto nos permite reducir el caso J = J0 a J = J0 - 1. 7. PPAD-Completación de juegos gráficos de ancho de ruta limitado En la sección anterior, demostramos que para los juegos gráficos en árboles que son casi pero no del todo los algoritmos de dos pasos no pueden encontrar el equilibrio Nash en el tiempo polinomial. A continuación, mostramos que una propiedad gráfica de ruta más leve nos permite construir juegos gráficos para los cuales es poco probable que cualquier algoritmo de tiempo polinómico encuentre equilibrios de Nash.7.1 Awidth de ruta Una descomposición de la ruta de un gráfico G = (V, E) es una secuencia de subset Si (V) ⊆ V tal que para cada borde (V, V) ∈ E, V, V ∈ Si (V) para algunos i, y además, para cada v ∈ V, si v ∈ Si (V) y V ∈ Sj (V) para J> I, entonces V ∈ Sk (V) para todos los I ≤ K ≤ J. La descomposición de la ruta tiene ancho k si todos los conjuntos Si (V) tienen cardinalidad como máximo K + 1. El ancho de ruta de G es el ancho mínimo de cualquier descomposición de la ruta de G. 107 El ancho de la ruta es una restricción del ancho de árbol (en el que uno buscaría un árbol cuyos vértices eran los sets si (v), y los conjuntos que contienen algún vértice tendrían que formarun subárbol). Para cualquier K constante, se puede decidir en tiempo polinomial si un gráfico tiene un ancho de ruta (o ancho de árbol) k.Además, muchos problemas teóricos gráficos parecen más fáciles de resolver en el tiempo polinomial, cuando se limitan al ancho de árbol fijo, o el ancho de ruta, gráficos, consulte [1] para una descripción general. Tenga en cuenta que una ruta tiene el ancho de ruta 1 y un ciclo tiene un ancho de ruta 2. 7.2 PPAD-Completimiento Revisamos algunas definiciones básicas de la teoría de la complejidad computacional de los problemas de búsqueda. Un problema de búsqueda asocia cualquier entrada (aquí, un juego gráfico) con un conjunto de soluciones (aquí, los equilibrios nash del juego de entrada), donde la longitud de descripción de cualquier solución debe estar limitada polinomialmente en función de la longitud de descripción de suaporte. En un problema de búsqueda total, existe una garantía de que existe al menos una solución para cualquier entrada. El teorema de Nashs nos asegura que el problema de encontrar equilibrios de Nash es total. Una reducción de los problemas de búsqueda a los problemas s es un mecanismo que muestra que cualquier algoritmo de tiempo polinómico para S implica un algoritmo de tiempo polinomial para S. consiste en funciones F y G, computables en tiempo polinomial, donde F mapas de las entradas de Sa las entradas de S y G mapas soluciones de S a soluciones de S, de tal manera que si es una entrada a S, y SS es una solución a F (IS), entonces G (SS) es una solución a IS. Observe que los problemas de búsqueda totales no permiten las reducciones anteriores de problemas como el SAT del circuito (donde la entrada es un circuito booleano, y las soluciones son vectores de entrada que hacen que la salida sea verdadera) debido al hecho de que el circuito SAT y otros problemas completos de NP completanTener entradas con conjuntos de soluciones vacías. En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un equilibrio de Nash [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema. Definición 4. FINAL DE LA LÍNEA. Entrada: Circuitos booleanos S y P, cada uno con n de entrada y N bits de salida, donde P (0n) = 0n y S (0n) = 0n. Solución: x ∈ {0, 1} n tal que s (x) = x, o alternativamente x ∈ {0, 1} n tal que p (s (x)) = x. S y P pueden considerarse como un sucesor y predecesor. Observe que calculando Si (0n) (para i = 0, 1, 2, ...) y comparando con P (Si+1 (0n)), eventualmente debemos encontrar una solución al final de la línea. El final de la línea caracteriza el PPAD de la clase de complejidad (defender el argumento de paridad en un gráfico, la versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda es complete PPAD si el final de la línea se reduce a S. Otros PPAD-Los problemas completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para obtener descripciones más detalladas de estos problemas).Nash 3 gráficos es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo gráfico tiene el grado 3. Daskalakis et al.[4] Muestra PPAD-completidad de NASH 3 gráficos por una reducción de Brouwer tridimensional, introducido en [4] y definido de la siguiente manera. Definición 5. Brouwer tridimensional. Entrada: un circuito c que tiene 3n bits de entrada y 2 bits de salida. Los bits de entrada definen una cubeleta del cubo de la unidad, que consiste en las 3 coordenadas de sus puntos, dadas a N bits de precisión. La salida representa uno de los cuatro colores asignados por C a una cubeleta. C está restringido para asignar el color 1 a las cubeletas adyacentes al plano (y, z), color 2 a las cubeletas restantes adyacentes al plano (x, z), color 3 a las cubeletas restantes en (x, y)-Plane y color de 0 a todas las demás cubeletas en la superficie del cubo de la unidad. Una solución es un vértice pancromático, un vértice adyacente a las cubeletas que tienen 4 colores distintos. La razón por la cual se garantiza que existirá una solución es que se puede construir una función Brouwer asociada φ, es decir, una función continua desde el cubo de la unidad hasta sí mismo, de modo que los vértices pancromáticos corresponden a puntos fijos de φ.El teorema de Brouwers Fixpoint promete la existencia de un punto de fijación. La prueba del teorema 4 utiliza una modificación de la reducción de [4] de Brouwer tridimensional a NASH de 3 gráficos. Para probar el teorema, comenzamos con algunos resultados preliminares de la siguiente manera. Cada jugador tiene 2 acciones, denotadas 0 y 1. Para un jugador en Vertex V, permita que P [v] denote la probabilidad de que el jugador juegue 1. Lema 5. [7] Existe un juego gráfico GShift de tamaño fijo que tiene vértices V, V donde P [V] es la parte fraccional de 2p [V]. Corolario 1. Existe un juego gráfico Gn -thift de tamaño θ (n) de urbano de ruta constante, con vértices v, vn donde p [vn] es la parte fraccional de 2n .p [v]. PRUEBA. Haga una cadena de n copias de Gshift en Lemma 5. Cada subconjunto de vértices en la descomposición de la ruta son los vértices en una copia de GShift. Deje que (x) denote el n-th bit de la expansión binaria de x, donde interpretamos 1 como verdadero y 0 como falso. Los siguientes usan gadgets de [7, 4]. Corolario 2. Existe k de tal manera que para todos los n, y para todos los n1, n2, n3 ≤ n, existe un juego gráfico de tamaño o (n) con vía kidth k, que tiene vértices v1, v2, v3 donde p [v3] = p [V1] + 2 - n3 (in1 p [v1] ∧ in2 p [v2]). Prueba del teorema 4. Sea C el circuito booleano que describe una instancia de Brouwer tridimensional. Deja que G1 ,..., GP (n) sean las puertas de C indexadas de tal manera que las entradas a cualquier puerta son la (s) salida (s) de puertas de baja indexación.G1 ,..., G3n serán las entradas 3n a C. Todos los jugadores en el juego gráfico G construido en [4] tienen 2 acciones denotadas 0 y 1. La probabilidad de que V juegue 1 se denota P [V]. G tiene 3 jugadores VX, VY y VZ para los cuales P [VX], P [VY] y P [VZ] representan las coordenadas de un punto en el Cubo de la Unidad. G está diseñado para incentivar VX, VY y VZ para ajustar sus probabilidades en las direcciones dadas por una función Brouwer que está especificada por el circuito C. en un equilibrio Nash, P [VX], P [VY] y P [VZ] representandoCoordenadas de un punto de fijación de una función que pertenece a la clase de funciones representadas por Brouwer tridimensional. Para 1 ≤ i ≤ p (n) introducimos un vértice V (i) c de modo que para 1 ≤ j ≤ i, ij (p [v (i) c]) es la salida de la puerta GJ;Para i <j ≤ p (n), ij (p [v (i) c]) es 0. Construya V (I) C de V (I - 1) C usando Corolario 2. Deje que G (i) sea el juego gráfico que hace esto. Sea S1 (G (i)) ,..., Sn (g (i)) ser una descomposición de longitud n de ruta de G (i), donde v (i - 1) c ∈ S1 (g (i)) y v (i) c ∈ Sn (g (i)). Luego, se obtiene una descomposición de la ruta de ∪1≤i≤p (n) g (i) tomando la unión de las descomposiciones de la ruta separada, junto con Sn (g (i - 1)) ∪ S1 (g (i))para 2 ≤ i ≤ p (n). Deje que GC sea el juego gráfico anterior que simula C. GC tiene entradas 3N, que consiste en los primeros n bits de las expansiones binarias de P [VX], P [VY] y P [VZ]. De manera similar a [4], la salida de GC afecta a VX, VY y VZ de la siguiente manera. El color 0 incentiva VX, VY y VZ 108 para ajustar sus probabilidades P [VX], P [VY] y P [VZ] en la dirección (−1, −1, −1);El color 2 los incentiva para que se muevan en dirección (1, 0, 0);color 2, dirección (0, 1, 0);Color 3, dirección (0, 0, 1). Necesitamos asegurarnos de que en los puntos en los límites de las cubeletas adyacentes, el cambio de dirección será aproximadamente el promedio de las direcciones de los puntos circundantes. De esa manera, los cuatro colores/direcciones deben estar cerca para que puedan cancelarse mutuamente (y estamos en un vértice pancromático). Esto se logra utilizando el mismo truco que [4], en el que hacemos un número constante de copias de GC, que difieren en que cada copia agrega un pequeño vector de desplazamiento a sus copias de P [VX], P [Vy] yp [vz] (que se derivan del original utilizando el dispositivo de adición de [7]). Usando los dispositivos de adición y multiplicación de [7] promedimos las direcciones y agregamos un pequeño múltiplo de este promedio a (P [VX], P [VY], P [VZ]). En un equilibrio de Nash, las salidas de cada copia se cancelarán entre sí. El ancho de ruta de todo el juego es, como máximo, M veces el camino de ruta GC.8. Problemas abiertos El problema más importante que dejó este documento es si es posible encontrar un equilibrio NASH de un juego gráfico en un árbol de grados limitados en tiempo polinómico. Nuestra construcción muestra que cualquier algoritmo de dos pasos que almacene explícitamente las políticas de punto de interrupción necesita tiempo y espacio exponenciales. Sin embargo, no impide la existencia de un algoritmo que se basa en una idea similar, pero, en lugar de calcular toda la política de punto de interrupción para cada vértice, utiliza un pequeño número de pases adicionales a través del gráfico para decidir qué (tamaño polinomial)Se deben calcular partes de cada política de punto de interrupción. En particular, dicho algoritmo puede basarse en el algoritmo de aproximación de [8], donde el valor de se elige adaptivamente. Otra pregunta intrigante está relacionada con el hecho de que el gráfico para el que construimos una política de punto de interrupción de tamaño exponencial tiene el ancho de ruta 2, mientras que nuestros resultados positivos son para una ruta, es decir, un gráfico de viento de ruta 1. No está claro si para algún gráfico de gráfico de ruta limitado 1 el tiempo de ejecución de (la versión basada en políticas de punto de interrupción de) nuestro algoritmo será polinomio. En particular, es instructivo considerar un gráfico de oruga, es decir, el gráfico que se puede obtener de TN eliminando los vértices S1 ,..., Sn. Para este gráfico, se obtiene la mejor política de respuesta de un vértice VK en la columna vertebral de la oruga combinando la mejor política de respuesta de su predecesor en la columna vertebral VK - 1 y su otro hijo TK;Dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1] 2, [0, 1] × {0}, o [0, 1] × {1}) o consta de dos horizontalessegmentos y un segmento vertical de la forma {α} × [0, 1] que los conecta. Suponiendo por conveniencia que b (vk, tk) = [0, α] × {0} ∪ {α} × [0, 1] ∪ [α, 1] × {1}, y F es la función de indiferencia para VK,Observamos que la mejor política de respuesta para VK consta de 5 componentes: ˆf (0), ˆf (1) y tres componentes que corresponden a [0, α] × {0}, {α} × [0, 1],y [α, 1] × {1}. Por lo tanto, se puede pensar en construir B (VK+1, VK) como el siguiente proceso: Turn B (VK, VK - 1) por π/2, córtelo a lo largo de la línea (ahora horizontal) VK = α, aplique una fraccionadaTransformación lineal a la coordenada horizontal de ambas partes y vuelva a conectarlas usando la imagen del segmento {α} × [0, 1] bajo f.Esto implica que el problema de limitar el tamaño de la mejor política de respuesta (o, alternativamente, la política de punto de interrupción), puede verse como una generalización del siguiente problema de geometría computacional, que creemos que puede ser de interés independiente: el problema 1. Dada una colección de segmentos de eje paralelo en R2, considere la siguiente operación: elija una línea de eje paralelo LI (ya sea vertical u horizontal), corte el plano a lo largo de esta línea y cambie una de las dos partes resultantes por una cantidad arbitraria Δi;Como resultado, algunos segmentos se dividirán en dos partes. Vuelva a conectar estas partes, es decir, para cada segmento de la forma [A, B] × {C} que se transformó en [A, T] × {C + ΔI} y [T, B] × {C}, introduce un segmento{T} × [C, C+ΔI]. ¿Es posible comenzar con el segmento [0, 1] y después de N, las operaciones obtienen un conjunto que no puede representarse como una unión de segmentos de línea de poli (n)? En caso afirmativo, ¿puede ser el caso de que en este conjunto no haya una ruta con un número polinomial de giros que conecta los puntos finales del segmento original? Resulta que, en general, la respuesta a la primera pregunta es positiva, es decir, después de n pasos, es posible obtener un conjunto que consiste en segmentos θ (CN) para algunos C> 0. Esto implica que incluso para una oruga, la mejor política de respuesta puede ser exponencialmente grande. Sin embargo, en nuestro ejemplo (que se omite a partir de esta versión del documento debido a limitaciones de espacio), existe una ruta de tamaño polinomial a través de la mejor política de respuesta, es decir, no prueba que la política de punto de interrupción sea necesariamente exponencial de tamaño. Si uno puede probar que este es siempre el caso, puede ser posible adaptar esta prueba para demostrar que puede haber una brecha exponencial entre los tamaños de las mejores políticas de respuesta y las políticas de punto de ruptura.9. Referencias [1] H. Bodlaender y T. Kloks. Algoritmos eficientes y constructivos para el ancho de ruta y el ancho de árbol de los gráficos. Journal of Algorithms, 21: 358-402, 1996. [2] X. Chen y X. Deng.3-NASH es PPAD-COMPLETO. Informe técnico TR-05-134, Coloquio electrónico en complejidad computacional, 2005. [3] X. Chen y X. Deng. Liquidando la complejidad del equilibrio NASH de 2 jugadores. Informe técnico TR-05-140, Coloquio electrónico en complejidad computacional, 2005. [4] C. Daskalakis, P. Goldberg y C. Papadimitriou. La complejidad de calcular un equilibrio de Nash. En Actas del 38º Simposio ACM sobre la teoría de la computación, 2006. [5] C. Daskalakis y C. Papadimitriou. Los juegos de tres jugadores son difíciles. Informe técnico TR-05-139, Coloquio electrónico en complejidad computacional, 2005. [6] E. Elkind, L. Goldberg y P. Goldberg. Equilibrios de Nash en juegos gráficos en árboles revisitados. Informe técnico TR-06-005, Coloquio electrónico en complejidad computacional, 2006. [7] P. Goldberg y C. Papadimitriou. Reducibilidad entre problemas de equilibrio. En Actas del 38º Simposio ACM sobre Teoría de la Computación, 2006. [8] M. Kearns, M. Littman y S. Singh. Modelos gráficos para la teoría de juegos. En Actas de la 17ª Conferencia sobre Incertidumbre en Inteligencia Artificial, 2001. [9] M. Littman, M. Kearns y S. Singh. Un algoritmo exacto eficiente para juegos gráficos conectados individualmente. En Actas de la 15ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2001. [10] L. Ortiz y M. Kearns. Propagación de Nash para juegos gráficos de Loopy. En Actas de la 17ª Conferencia Anual sobre Sistemas de Procesamiento de Información Neural, 2003. [11] C. Papadimitriou. Sobre la complejidad del argumento de paridad y otras pruebas de existencia ineficientes. J. Comput. Syst. Sci., 48 (3): 498-532, 1994. 109",
    "original_sentences": [
        "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
        "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
        "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
        "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
        "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
        "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
        "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
        "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
        "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
        "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
        "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
        "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
        "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
        "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
        "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
        "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
        "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
        "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
        "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
        "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
        "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
        "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
        "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
        "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
        "By the end of the upstream pass, all children of the root have computed their best response policies.",
        "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
        "It also selects a strategy for each child.",
        "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
        "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
        "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
        "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
        "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
        "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
        "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
        "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
        "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
        "We can improve the running time of the generic algorithm using the ideas of [9].",
        "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
        "We obtain the following theorem THEOREM 1.",
        "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
        "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
        "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
        "THEOREM 2.",
        "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
        "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
        "Even when the tree has bounded degree, the running time can be exponential.",
        "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
        "In particular, we show the following.",
        "THEOREM 3.",
        "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
        "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
        "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
        "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
        "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
        "We prove the following theorem.",
        "THEOREM 4.",
        "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
        "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
        "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
        "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
        "Each vertex has two actions, which are denoted by 0 and 1.",
        "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
        "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
        "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
        "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
        "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
        "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
        "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
        "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
        "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
        "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
        "The root selects any pair (w, v) from B(W, V ).",
        "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
        "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
        "ALGORITHM OF LITTMAN ET AL.",
        "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
        "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
        "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
        "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
        "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
        "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
        "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
        "We say such a breakpoint policy has t − 1 breakpoints.",
        "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
        "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
        "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
        "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
        "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
        "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
        "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
        "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
        "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
        "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
        "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
        "The thick connected path is the corresponding breakpoint policy.",
        "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
        "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
        "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
        "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
        "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
        "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
        "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
        "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
        "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
        "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
        "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
        "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
        "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
        "Any other trimming would be just as bad.",
        "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
        "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
        "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
        "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
        "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
        "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
        "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
        "In the next section, we show that it runs in polynomial time on a path. 4.",
        "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
        "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
        "THEOREM 5.",
        "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
        "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
        "PROOF.",
        "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
        "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
        "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
        "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
        "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
        "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
        "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
        "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
        "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
        "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
        "In this case, P0 > P1 if and only if A1u + A0 < 0.",
        "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
        "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
        "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
        "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
        "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
        "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
        "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
        "Assume for now that A1 > 0; the other two cases can be treated similarly.",
        "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
        "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
        "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
        "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
        "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
        "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
        "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
        "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
        "The set B(W, V )|V =1 can be described in a similar manner.",
        "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
        "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
        "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
        "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
        "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
        "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
        "Sometimes we drop the subscript V when it is clear from the context.",
        "LEMMA 1.",
        "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
        "PROOF.",
        "Fix an arbitrary v ∈ (0, 1).",
        "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
        "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
        "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
        "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
        "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
        "Choose u = vj−1; by construction, u ∈ pbrU (v).",
        "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
        "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
        "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
        "LEMMA 2.",
        "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
        "PROOF.",
        "Consider an arbitrary u0 ∈ pbrU (0).",
        "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
        "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
        "The argument for the case B(u0) < 0 is similar.",
        "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
        "Note that for any such vector we have vj−1 ∈ pbrU (0).",
        "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
        "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
        "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
        "The argument for ˆf(1) is similar.",
        "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
        "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
        "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
        "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
        "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
        "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
        "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
        "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
        "The case limu→u∗− f(u) = −∞ is similar.",
        "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
        "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
        "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
        "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
        "Hence, B(W, V ) has at most 2j + 4 event points.",
        "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
        "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
        "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
        "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
        "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
        "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
        "Definition 3.",
        "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
        "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
        "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
        "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
        "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
        "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
        "THEOREM 6.",
        "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
        "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
        "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
        "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
        "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
        "For i ≤ k let vi denote the probability that Vi plays 1.",
        "The first search can be done as follows.",
        "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
        "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
        "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
        "Apply the upstream pass to P 4.",
        "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
        "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
        "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
        "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
        "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
        "Choose any vertex Vi.",
        "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
        "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
        "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
        "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
        "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
        "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
        "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
        "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
        "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
        "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
        "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
        "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
        "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
        "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
        "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
        "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
        "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
        "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
        "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
        "In the rest of this subsection, we describe this construction.",
        "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
        "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
        "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
        "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
        "LEMMA 3.",
        "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
        "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
        "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
        "PROOF.",
        "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
        "Now, suppose it is true for B(Vk, Vk−1).",
        "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
        "Let us examine them in turn.",
        "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
        "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
        "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
        "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
        "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
        "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
        "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
        "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
        "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
        "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
        "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
        "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
        "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
        "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
        "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
        "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
        "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
        "LEMMA 4.",
        "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
        "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
        "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
        "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
        "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
        "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
        "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
        "This implies Theorem 3.",
        "THEOREM 7.",
        "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
        "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
        "We proceed by induction.",
        "For j = 1, the argument is similar to that in Section 3.",
        "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
        "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
        "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
        "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
        "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
        "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
        "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
        "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
        "In a total search problem, there is a guarantee that at least one solution exists for any input.",
        "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
        "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
        "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
        "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
        "Definition 4.",
        "END OF THE LINE.",
        "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
        "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
        "S and P can be thought of as standing for successor and predecessor.",
        "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
        "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
        "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
        "Definition 5. 3-DIMENSIONAL BROUWER.",
        "Input: a circuit C having 3n input bits and 2 output bits.",
        "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
        "The output represents one of four colours assigned by C to a cubelet.",
        "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
        "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
        "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
        "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
        "To prove the theorem, we begin with some preliminary results as follows.",
        "Each player has 2 actions, denoted 0 and 1.",
        "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
        "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
        "COROLLARY 1.",
        "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
        "PROOF.",
        "Make a chain of n copies of Gshift in Lemma 5.",
        "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
        "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
        "The following uses gadgets from [7, 4].",
        "COROLLARY 2.",
        "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
        "PROOF OF THEOREM 4.",
        "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
        "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
        "The probability that V plays 1 is denoted p[V ].",
        "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
        "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
        "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
        "Construct V (i) C from V (i−1) C using Corollary 2.",
        "Let G(i) be the graphical game that does this.",
        "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
        "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
        "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
        "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
        "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
        "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
        "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
        "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
        "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
        "At a Nash equilibrium the outputs of each copy will cancel each other out.",
        "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
        "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
        "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
        "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
        "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
        "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
        "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
        "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
        "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
        "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
        "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
        "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
        "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
        "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
        "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
        "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
        "This implies that even for a caterpillar, the best response policy can be exponentially large.",
        "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
        "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
        "REFERENCES [1] H. Bodlaender and T. Kloks.",
        "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
        "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
        "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
        "Settling the complexity of 2-player Nash equilibrium.",
        "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
        "The complexity of computing a Nash equilibrium.",
        "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
        "Three-player games are hard.",
        "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
        "Nash equilibria in graphical games on trees revisited.",
        "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
        "Reducibility among equilibrium problems.",
        "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
        "Graphical models for game theory.",
        "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
        "An efficient exact algorithm for singly connected graphical games.",
        "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
        "Nash propagation for loopy graphical games.",
        "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
        "On the complexity of the parity argument and other inefficient proofs of existence.",
        "J. Comput.",
        "Syst.",
        "Sci., 48(3):498-532, 1994. 109"
    ],
    "error_count": 0,
    "keys": {
        "graphical game": {
            "translated_key": "juego gráfico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 <br>graphical game</br> with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action <br>graphical game</br> in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A <br>graphical game</br> associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the <br>graphical game</br> downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a <br>graphical game</br> on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a <br>graphical game</br> with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a <br>graphical game</br> with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a <br>graphical game</br> on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a <br>graphical game</br> on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a <br>graphical game</br> in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the <br>graphical game</br> by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a <br>graphical game</br>) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a <br>graphical game</br> whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a <br>graphical game</br> Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a <br>graphical game</br> Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a <br>graphical game</br> of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the <br>graphical game</br> G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the <br>graphical game</br> that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above <br>graphical game</br> that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a <br>graphical game</br> on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un \"juego gráfico\" de grado general-3 con dos acciones por jugador está completo para la clase de complejidad PPAD, lo que indica que es poco probable que haya un algoritmo de tiempo polinómico para estoproblema.",
                "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinómico en gráficos con el viento de ruta 1, pero mostramos que encontrar un equilibrio NASH para un \"juego gráfico\" de 2-acción en el que el gráfico subyacente tiene un grado máximo 3 y un itivio de ruta constante es PPAD-Completa (es poco probable que sea manejable).",
                "Un \"juego gráfico\" asocia a cada jugador con un vértice de un gráfico G subyacente, y la recompensa a ese jugador es una función de las acciones elegidas por él y sus vecinos en G;Si G tiene bajo grado, esta es una forma concisa de representar un juego con muchos jugadores.",
                "Durante el pase aguas arriba, cada vértice V calcula el conjunto de sus mejores respuestas potenciales a cada estrategia mixta W de su padre W;Una estrategia V es una mejor respuesta potencial a W si 1 nota que la terminología aguas arriba y aguas abajo se invierte en [8, 9]: nuestros árboles están enraizados en la parte superior.100 Hay un equilibrio de Nash en el \"juego gráfico\" aguas abajo de V (inclusive) dado que W juega W (para una definición más técnica, el lector se remite a la Sección 2).",
                "En particular, damos un algoritmo O (N2) para encontrar un equilibrio NASH de un \"juego gráfico\" en un camino de longitud n.En lugar de almacenar las mejores políticas de respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, después de [9], llamamos políticas de punto de interrupción (modificando la definición según sea necesario).",
                "Hay un algoritmo O (N2) que encuentra un equilibrio NASH de un \"juego gráfico\" con dos acciones por jugador en una ruta N-Vertex.",
                "Hay un algoritmo de tiempo polinómico que encuentra un equilibrio NASH de un \"juego gráfico\" con dos acciones por jugador en un gráfico con el máximo grado 2.",
                "En la Sección 6 ampliamos nuestro algoritmo para que pueda usarse para encontrar un equilibrio NASH de un \"juego gráfico\" en un árbol arbitrario.",
                "En la Sección 7, damos un resultado de la intratabilidad teórica de complejidad para el problema de encontrar un equilibrio NASH de un \"juego gráfico\" en un gráfico con un pequeño ancho de ruta.",
                "Considere el problema de encontrar un equilibrio de Nash para un \"juego gráfico\" en el que el gráfico subyacente tiene el máximo grado 3 y el ancho de ruta k.Hay una K constante de tal manera que este problema es complete PPAD.",
                "Para simplificar el caso base, modificamos el \"juego gráfico\" al agregar un vértice ficticio V0 al comienzo del camino: el único vecino de V0 es V1, los pagos de V0 siempre son iguales a 0, y los pagos de todos los demásLos vértices (incluido V1) son los mismos que en el juego original.",
                "Un problema de búsqueda asocia cualquier entrada (aquí, un \"juego gráfico\") con un conjunto de soluciones (aquí, los equilibrios NASH del juego de entrada), donde la longitud de descripción de cualquier solución debe estar limitada polinomialmente en función de la longitud de descripciónde su entrada.",
                "El final de la línea caracteriza el PPAD de la clase de complejidad (defender el argumento de paridad en un gráfico, la versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda es complete PPAD si el final de la línea se reduce a S. Otros PPAD-Los problemas completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para obtener descripciones más detalladas de estos problemas).Nash 3 gráficos es el problema de encontrar un equilibrio de Nash para un \"juego gráfico\" cuyo gráfico tiene un grado 3.",
                "Lemma 5. [7] Existe un \"juego gráfico\" Gshift de tamaño fijo que tiene vértices V, V donde P [V] es la parte fraccional de 2p [V].",
                "Existe un \"juego gráfico\" Gn -thift de tamaño θ (n) de urbano de ruta constante, que tiene vértices v, vn donde p [vn] es la parte fraccional de 2n .p [v].",
                "Existe k de tal manera que para todos N, y para todos los n1, n2, n3 ≤ n, existe un \"juego gráfico\" de tamaño o (n) con el itivio de ruta k, que tiene vértices v1, v2, v3 donde p [v3] =P [v1] + 2 - n3 (in1 p [v1] ∧ in2 p [v2]).",
                "Deja que G1 ,..., GP (n) sean las puertas de C indexadas de tal manera que las entradas a cualquier puerta son la (s) salida (s) de puertas de baja indexación.G1 ,..., G3n será las entradas 3n a C. Todos los jugadores en el \"juego gráfico\" G construido en [4] tienen 2 acciones denotadas 0 y 1.",
                "Deje que G (i) sea el \"juego gráfico\" que hace esto.",
                "Deje que GC sea el \"juego gráfico\" anterior que simula C. GC tiene entradas 3N, que consiste en los primeros n bits de las expansiones binarias de P [VX], P [VY] y P [VZ].",
                "Problemas abiertos El problema más importante que dejó este documento es si es posible encontrar un equilibrio NASH de un \"juego gráfico\" en un árbol de grados limitados en tiempo polinómico."
            ],
            "translated_text": "",
            "candidates": [
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "Juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "Juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "Juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico",
                "juego gráfico"
            ],
            "error": []
        },
        "large-scale distributed network": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of <br>large-scale distributed network</br>s of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed asUn modelo teórico de juego de \"redes distribuidas a gran escala\" de agentes no cooperativos."
            ],
            "translated_text": "",
            "candidates": [
                "red distribuida a gran escala",
                "redes distribuidas a gran escala"
            ],
            "error": []
        },
        "nash equilibrium": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single <br>nash equilibrium</br> in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a <br>nash equilibrium</br>.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a <br>nash equilibrium</br> for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single <br>nash equilibrium</br> in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a <br>nash equilibrium</br> in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a <br>nash equilibrium</br> of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a <br>nash equilibrium</br>, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a <br>nash equilibrium</br> of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a <br>nash equilibrium</br> of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a <br>nash equilibrium</br> of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a <br>nash equilibrium</br> of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a <br>nash equilibrium</br> of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a <br>nash equilibrium</br> for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single <br>nash equilibrium</br> by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a <br>nash equilibrium</br>.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a <br>nash equilibrium</br>.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a <br>nash equilibrium</br> since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a <br>nash equilibrium</br> since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a <br>nash equilibrium</br>.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a <br>nash equilibrium</br>.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a <br>nash equilibrium</br> (and a representation of all Nash equilibria) follows. 4.1 Finding a Single <br>nash equilibrium</br> in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a <br>nash equilibrium</br>.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a <br>nash equilibrium</br>: first we search for a <br>nash equilibrium</br> where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a <br>nash equilibrium</br>. (Otherwise, there is no <br>nash equilibrium</br> of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed <br>nash equilibrium</br> exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a <br>nash equilibrium</br> are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single <br>nash equilibrium</br> using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a <br>nash equilibrium</br> [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a <br>nash equilibrium</br> for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a <br>nash equilibrium</br>, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a <br>nash equilibrium</br> the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a <br>nash equilibrium</br> of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player <br>nash equilibrium</br>.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a <br>nash equilibrium</br>.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Más tarde, Littman, Kearns y Singh propusieron una modificación a este algoritmo que puede encontrar un solo \"equilibrio de Nash\" en tiempo polinomial.",
                "Mostramos que este algoritmo modificado es incorrecto: la salida no siempre es un \"equilibrio de Nash\".",
                "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinomial en gráficos con el viento de ruta 1, pero mostramos que encontrar un \"equilibrio de Nash\" para un juego gráfico de 2 acciones en el que el gráfico subyacente tiene un grado máximo 3 y un ancho de ruta constante es PPAD-Completa (es poco probable que sea manejable).",
                "El primero de estos documentos describe un algoritmo genérico para este problema que puede especializarse de dos maneras: como un algoritmo que calcula las aproximaciones a todos los equilibrios de NASH en el tiempo de tiempo en el tamaño de entrada y la calidad de aproximación, o como un algoritmo de tiempo exponencial quePermite el cálculo exacto de todos los equilibrios de Nash en G. En [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un solo \"equilibrio de Nash\" en el tiempo polinomial.",
                "Durante el pase aguas arriba, cada vértice V calcula el conjunto de sus mejores respuestas potenciales a cada estrategia mixta W de su padre W;Una estrategia V es una mejor respuesta potencial a W si 1 nota que la terminología aguas arriba y aguas abajo se invierte en [8, 9]: nuestros árboles están enraizados en la parte superior.100 Hay un \"equilibrio de Nash\" en el juego gráfico aguas abajo de V (inclusive) dado que W juega W (para una definición más técnica, el lector se remite a la Sección 2).",
                "En la Sección 3 describimos un ejemplo simple para el cual el algoritmo de [9] genera un vector de estrategias que no constituye un \"equilibrio NASH\" del juego subyacente.",
                "",
                "En particular, damos un algoritmo O (N2) para encontrar un \"equilibrio NASH\" de un juego gráfico en un camino de longitud n.En lugar de almacenar las mejores políticas de respuesta, este algoritmo almacena subconjuntos definidos adecuadamente, que, después de [9], llamamos políticas de punto de interrupción (modificando la definición según sea necesario).",
                "Hay un algoritmo O (N2) que encuentra un \"equilibrio NASH\" de un juego gráfico con dos acciones por jugador en una ruta N-Vértice.",
                "Hay un algoritmo de tiempo polinómico que encuentra un \"equilibrio NASH\" de un juego gráfico con dos acciones por jugador en un gráfico con máximo grado 2.",
                "En la Sección 6 ampliamos nuestro algoritmo para que pueda usarse para encontrar un \"equilibrio NASH\" de un juego gráfico en un árbol arbitrario.",
                "En la Sección 7, damos un resultado de la intratabilidad teórica de complejidad para el problema de encontrar un \"equilibrio NASH\" de un juego gráfico en un gráfico con un pequeño ancho de ruta.",
                "Considere el problema de encontrar un \"equilibrio de Nash\" para un juego gráfico en el que el gráfico subyacente tiene el máximo grado 3 y el ancho de ruta k.Hay una K constante de tal manera que este problema es complete PPAD.",
                "El algoritmo de [9] se basa en la siguiente observación: para calcular un solo \"equilibrio NASH\" por un algoritmo de dos pasos, no es necesario construir toda la mejor política de respuesta para cada vértice.",
                "Mientras, en cada paso del pase aguas abajo, el vértice bajo consideración puede seleccionar un vector de estrategias para todos sus hijos para que cada estrategia de cada niño sea una mejor respuesta potencial a la estrategia de los padres, el algoritmo logra producir un \"equilibrio de Nash\".",
                "Tenga en cuenta que esta política de punto de interrupción ˆB (W, V) no es válida en el sentido de que no satisface ˆB (W, V) ⊆ B (W, V).102 1 10.5 0.5 1 10.1 0.9 U V V W Figura 2: Mejores políticas de respuesta para U y V.0.1 0.9 1 0.5 1 V W Figura 3: Una política recortada para V El punto es que la matriz de pago de W ahora se puede elegir para evitar que el algoritmo LKS encuentre un \"equilibrio NASH\".",
                "En el pase hacia abajo, los valores elegidos son w = .1, entonces, desde el recorte, v = 0 y u = 1, que no es un \"equilibrio de Nash\" ya que W prefiere la acción 1.",
                "El algoritmo luego da w = .9, v = 1 y u = 0, que no es un \"equilibrio de Nash\" ya que W prefiere la acción 0.",
                "Concluimos que el algoritmo LKS no siempre encuentra un \"equilibrio de Nash\".",
                "En las Secciones 4 y 6 mostramos cómo modificar el algoritmo para que siempre encuentre un \"equilibrio Nash\".",
                "El O (N3) se une al tiempo de ejecución general para encontrar un \"equilibrio NASH\" (y una representación de todos los equilibrios de Nash) sigue.4.1 Encontrar un solo \"equilibrio de Nash\" en el tiempo O (N2) El límite superior en el tiempo de ejecución de nuestro algoritmo es apretado, al menos suponiendo la implementación directa, en la que cada B (VJ+1, VJ) se almacena como uniónde rectángulos: no es difícil construir un ejemplo en el que el tamaño de B (VJ+1, VJ) es Ω (J2).",
                "Como se explica en la Sección 3, podemos usar una política de punto de interrupción válida en lugar de la mejor política de respuesta durante el pase posterior, y aún así garantizar que al final, generaremos un \"equilibrio NASH\".",
                "Dado un ciclo con vértices V1 ,..., VK (en orden cíclico), hacemos dos búsquedas separadas para un \"equilibrio de Nash\": primero buscamos un \"equilibrio de Nash\" donde algún vértice juega una estrategia pura, luego buscamos un equilibrio de nash totalmente mixto, donde todos los vérticesJuega estrategias mixtas.",
                "",
                "Para un ciclo de longitud impar, todos los demás VJ son derivables de esas soluciones, y si existe un \"equilibrio Nash\" completamente mezclado, todo el VJ debería ser números reales en el rango (0, 1).",
                "Los valores para VI que pueden ocurrir en un \"equilibrio de Nash\" son aquellos para los cuales todos los valores de VJ dependientes se encuentran en (0, 1);La última condición es fácil de verificar calculando la imagen del intervalo (0, 1) bajo las transformaciones lineales fraccionales respectivas.6.",
                "Además, en nuestro ejemplo, las políticas de punto de ruptura coinciden con las mejores políticas de respuesta, lo que significa que incluso encontrar un solo \"equilibrio de Nash\" utilizando el enfoque de [8, 9] tomará exponencialmente mucho tiempo.",
                "En cambio, el trabajo reciente sobre la complejidad computacional de encontrar un \"equilibrio de Nash\" [7, 4, 5, 2, 3] lo ha relacionado con el siguiente problema.",
                "El final de la línea caracteriza el PPAD de la clase de complejidad (defender el argumento de paridad en un gráfico, la versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda es complete PPAD si el final de la línea se reduce a S. Otros PPAD-Los problemas completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para obtener descripciones más detalladas de estos problemas).Nash 3 gráficos es el problema de encontrar un \"equilibrio de Nash\" para un juego gráfico cuyo gráfico tiene grado 3.",
                "G está diseñado para incentivar VX, VY y VZ para ajustar sus probabilidades en las direcciones dadas por una función de Brouwer que está especificada por el circuito C. en un \"equilibrio NASH\", p [vx], p [vy] y p [vz] Representar coordenadas de un punto de fijación de una función que pertenece a la clase de funciones representadas por Brouwer tridimensional.",
                "En un \"equilibrio de Nash\", las salidas de cada copia se cancelarán entre sí.",
                "Problemas abiertos El problema más importante que dejó este documento es si es posible encontrar un \"equilibrio NASH\" de un juego gráfico en un árbol de grados limitados en tiempo polinomial.",
                "Estableciendo la complejidad del \"equilibrio NASH\" de 2 jugadores.",
                "La complejidad de calcular un \"equilibrio NASH\"."
            ],
            "translated_text": "",
            "candidates": [
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH",
                "Equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "Equilibrio de Nash",
                "equilibrio de Nash",
                "Equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "",
                "equilibrio Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio Nash",
                "Equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "Equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH",
                "equilibrio de Nash",
                "equilibrio NASH"
            ],
            "error": []
        },
        "degree": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low <br>degree</br>, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general <br>degree</br>-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-<br>degree</br> trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum <br>degree</br> 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded <br>degree</br>.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-<br>degree</br> trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum <br>degree</br> 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low <br>degree</br>, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum <br>degree</br> 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded <br>degree</br>, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-<br>degree</br> trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-<br>degree</br> trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum <br>degree</br> 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of <br>degree</br> d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM <br>degree</br> 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have <br>degree</br> at most 2.",
                "A graph having maximum <br>degree</br> 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the <br>degree</br> of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same <br>degree</br>.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has <br>degree</br> 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-<br>degree</br> tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-<br>degree</br> graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Cuando el número de jugadores es grande, y el gráfico subyacente tiene un \"grado\" bajo, proporcionan una forma concisa de representar los pagos de los jugadores.",
                "Recientemente se ha demostrado que el problema de encontrar equilibrios de Nash en un juego gráfico \"grado\" general con dos acciones por jugador está completo para la clase de complejidad PPAD, lo que indica que es poco probable que haya un algoritmo de tiempo polinómico para estoproblema.",
                "En este artículo, estudiamos la complejidad de los juegos gráficos con dos acciones por jugador en árboles limitados \"grado\".",
                "",
                "Además, nuestro algoritmo se puede usar para calcular los equilibrios NASH de los juegos gráficos en árboles arbitrarios, pero el tiempo de ejecución puede ser exponencial, incluso cuando el árbol ha limitado el \"grado\".",
                "",
                "Es una pregunta abierta si nuestro algoritmo se ejecuta en tiempo polinomial en gráficos con el viento de ruta 1, pero mostramos que encontrar un equilibrio NASH para un juego gráfico de 2 acciones en el que el gráfico subyacente tiene el máximo \"grado\" 3 y el ancho de ruta constante es PPAD-Completa (es poco probable que sea manejable).",
                "Un juego gráfico asocia a cada jugador con un vértice de un gráfico subyacente G, y la recompensa a ese jugador es una función de las acciones elegidas por él y sus vecinos en G;Si G tiene un \"grado\" bajo, esta es una forma concisa de representar un juego con muchos jugadores.",
                "",
                "Incluso cuando el árbol ha limitado el \"grado\", el tiempo de ejecución puede ser exponencial.",
                "Mostramos que esto es inevitable al construir una familia de juegos gráficos en árboles de \"grado\" limitados para los cuales las mejores políticas de respuesta de algunos de los vértices tienen un tamaño exponencial, y cualquier algoritmo de Twopass (es decir, un algoritmo que es similar en el espíritu a eso.de [8]) tiene que almacenar casi todos los puntos de las mejores políticas de respuesta.",
                "Hay una familia infinita de juegos gráficos en árboles limitados: \"grado\" con ancho de ruta 2, de modo que cualquier algoritmo de dos pasos para encontrar equilibrios de Nash en estos árboles requiere tiempo y espacio exponenciales.",
                "Considere el problema de encontrar un equilibrio de Nash para un juego gráfico en el que el gráfico subyacente tiene el máximo \"grado\" 3 y el ancho de ruta k.Hay una K constante de tal manera que este problema es complete PPAD.",
                "Para probar el teorema 4, utilizamos los resultados recientes de completidad de PPAD para los juegos, en particular los documentos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en juegos gráficos de \"grado\" d (para d ≥ 3) es computacionalmente equivalenteal problema de resolver juegos de forma normal del jugador R (para R ≥ 4), los cuales son completos PPAD.2.",
                "",
                "Un gráfico que tiene \"grado\" máximo 2 es, por supuesto, una unión de caminos y ciclos.",
                "Suponemos que el \"grado\" de cada vértice está limitado por una K constante, es decir, la matriz de pago para cada vértice es de tamaño O (2k).",
                "Tenga en cuenta que esta definición es diferente de una más estándar en que no requerimos que todos los monomiales tengan el mismo \"grado\".",
                "El final de la línea caracteriza el PPAD de la clase de complejidad (defender el argumento de paridad en un gráfico, la versión dirigida), introducida en Papadimitriou [11], y cualquier problema de búsqueda es complete PPAD si el final de la línea se reduce a S. Otros PPAD-Los problemas completos incluyen la búsqueda de un hiperplano de sándwich de jamón y encontrar equilibrios de mercado en una economía de intercambio (ver [11] para obtener descripciones más detalladas de estos problemas).Nash 3 gráficos es el problema de encontrar un equilibrio de Nash para un juego gráfico cuyo gráfico tiene \"grado\" 3.",
                "Problemas abiertos El problema más importante que dejó este documento es si es posible encontrar un equilibrio NASH de un juego gráfico en un árbol limitado: \"grado\" en tiempo polinómico.",
                "No está claro si para algún gráfico limitado-\"grado\" de la ruta 1 1 el tiempo de ejecución de (la versión basada en políticas de punto de interrupción de) nuestro algoritmo será polinomio."
            ],
            "translated_text": "",
            "candidates": [
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "",
                "grado",
                "grado",
                "grado",
                "",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "Grado",
                "grado",
                "",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "Grado",
                "grado",
                "grado",
                "grado",
                "grado",
                "grado"
            ],
            "error": []
        },
        "dynamic programming-based algorithm": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a <br>dynamic programming-based algorithm</br> that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Este entorno fue considerado por primera vez por Kearns, Littman y Singh, quienes propusieron un \"algoritmo dinámico basado en programación\" que calcula todos los equilibrios NASH de tales juegos."
            ],
            "translated_text": "",
            "candidates": [
                "Algoritmo dinámico basado en la programación",
                "algoritmo dinámico basado en programación"
            ],
            "error": []
        },
        "ppad-completeness": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent <br>ppad-completeness</br> results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "<br>ppad-completeness</br> OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 <br>ppad-completeness</br> We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show <br>ppad-completeness</br> of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Para probar el Teorema 4, utilizamos resultados recientes de \"PPAD-Completitud\" para juegos, en particular los documentos [7, 4] que muestran que el problema de encontrar equilibrios de Nash en los juegos gráficos de grado D (para D ≥ 3) es computacionalmente equivalenteal problema de resolver juegos de forma normal del jugador R (para R ≥ 4), los cuales son completos PPAD.2.",
                "\"PPAD-Completitud\" de los juegos gráficos acotados de ancho de ruta en la sección anterior, demostramos que para los juegos gráficos en árboles que son casi pero no del todo los algoritmos de dos pasos no pueden encontrar equilibrios Nash en el tiempo polinomial.",
                "Tenga en cuenta que una ruta tiene el ancho de ruta 1 y un ciclo tiene un ancho de ruta 2. 7.2 \"PPAD-Completimiento\" revisamos algunas definiciones básicas de la teoría de la complejidad computacional de los problemas de búsqueda.",
                "Daskalakis et al.[4] Muestra \"PPAD-Completitud\" de NASH de 3 gráficos por una reducción de Brouwer tridimensional, introducido en [4] y definido de la siguiente manera."
            ],
            "translated_text": "",
            "candidates": [
                "PPAD-COMPLETIDAD",
                "PPAD-Completitud",
                "PPAD-COMPLETIDAD",
                "PPAD-Completitud",
                "PPAD-COMPLETIDAD",
                "PPAD-Completimiento",
                "PPAD-COMPLETIDAD",
                "PPAD-Completitud"
            ],
            "error": []
        },
        "bounded-degree tree": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a <br>bounded-degree tree</br> in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Problemas abiertos El problema más importante que dejó este documento es si es posible encontrar un equilibrio NASH de un juego gráfico en un \"árbol de grado limitado\" en tiempo polinómico."
            ],
            "translated_text": "",
            "candidates": [
                "Árbol de grados limitados",
                "árbol de grado limitado"
            ],
            "error": []
        },
        "generic algorithm": {
            "translated_key": "algoritmo genérico",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a <br>generic algorithm</br> for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The <br>generic algorithm</br> of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The <br>generic algorithm</br> does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the <br>generic algorithm</br> described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the <br>generic algorithm</br> of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the <br>generic algorithm</br> using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the <br>generic algorithm</br> of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El primero de estos documentos describe un \"algoritmo genérico\" para este problema que puede especializarse de dos maneras: como un algoritmo que calcula las aproximaciones a todos los equilibrios de NASH en el polinomio de tiempo en el tamaño de entrada y la calidad de aproximación, o como un tiempo exitoso.Algoritmo que permite el cálculo exacto de todos los equilibrios de Nash en G. en [9], los autores proponen una modificación al último algoritmo que tiene como objetivo encontrar un único equilibrio de Nash en el tiempo polinomial.",
                "Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil.1.1 Antecedentes El \"algoritmo genérico\" de [8] consta de dos fases a las que nos referiremos como el pase aguas arriba y el pase aguas abajo;1 El primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas.",
                "El \"algoritmo genérico\" no aborda el problema de representar la mejor política de respuesta;De hecho, la diferencia más importante entre las dos instancias del \"algoritmo genérico\" descrito en [8] está en su enfoque de este problema.",
                "Esto nos da un algoritmo O (N3) para encontrar un equilibrio de Nash, y para calcular una representación de todos los equilibrios de Nash.(Este algoritmo es un caso especial del \"algoritmo genérico\" de [8]: mostramos que se ejecuta en tiempo polinomial cuando el gráfico subyacente es una ruta.)",
                "Podemos mejorar el tiempo de ejecución del \"algoritmo genérico\" utilizando las ideas de [9].",
                "El pase aguas arriba del \"algoritmo genérico\" de [8] calcula la mejor política de respuesta para V para cada nodo V que no sea la raíz."
            ],
            "translated_text": "",
            "candidates": [
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "Algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico",
                "algoritmo genérico"
            ],
            "error": []
        },
        "response policy": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best <br>response policy</br> for V .",
                "The generic algorithm does not address the problem of representing the best <br>response policy</br>; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best <br>response policy</br> for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best <br>response policy</br> can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best <br>response policy</br> for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best <br>response policy</br> for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best <br>response policy</br> for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best <br>response policy</br> for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best <br>response policy</br> for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best <br>response policy</br> for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best <br>response policy</br> for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best <br>response policy</br> for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best <br>response policy</br> for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best <br>response policy</br> for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best <br>response policy</br> for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best <br>response policy</br> during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best <br>response policy</br> (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best <br>response policy</br> of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best <br>response policy</br> is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best <br>response policy</br> for Tn While the best <br>response policy</br> constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best <br>response policy</br> cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best <br>response policy</br> (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best <br>response policy</br> of a vertex Vk in the spine of the caterpillar is obtained by combining the best <br>response policy</br> of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best <br>response policy</br> for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best <br>response policy</br> (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best <br>response policy</br> can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best <br>response policy</br>, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La salida de esta etapa se puede ver como una Tabla (continua) T (W, V), donde t (W, V) = 1 si y solo si V es una mejor respuesta potencial a W;Nos referimos a esta tabla como la mejor \"política de respuesta\" para v.",
                "El algoritmo genérico no aborda el problema de representar la mejor \"política de respuesta\";De hecho, la diferencia más importante entre las dos instancias del algoritmo genérico descrito en [8] está en su enfoque de este problema.",
                "El cálculo se realiza inductivamente: la mejor \"política de respuesta\" para V se calcula en función de las mejores políticas de respuesta de V S Children U1 ,..., Reino Unido.",
                "Para limitar el tiempo de ejecución de este algoritmo, el documento [8] muestra que cualquier mejor \"política de respuesta\" puede representarse como una unión de un número exponencial de rectángulos;El algoritmo de aproximación de tiempo polinomial se obtiene combinando esta representación con una cuadrícula de tamaño polinomial.",
                "La idea principal de [9] es que no es necesario realizar un seguimiento de todos los rectángulos en las mejores políticas de respuesta;Más bien, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinomial de la política correspondiente (en [9], este subconjunto se llama política de punto de interrupción) y aún así asegurarse de que el pase posterior pueda proceder con éxito (Una condición suficiente para esto es que el subconjunto de la mejor \"política de respuesta\" para V almacenada por el algoritmo contiene una ruta continua de W = 0 a W = 1).1.2 Nuestros resultados Una de las principales contribuciones de nuestro artículo es mostrar que el algoritmo propuesto por [9] es incorrecto.",
                "Supongamos que (V, W) es un borde del árbol, que V es una estrategia mixta para V y que W es una estrategia mixta para w.101 Decimos que V es una mejor respuesta potencial a W (denotada por V ∈ PBRV (W)) Si hay un equilibrio en la instancia G (V, W), W = W en la que V tiene una estrategia mixta v. DefinimosLa mejor \"política de respuesta\" para V, dada W, como B (W, V) = {(W, V) |v ∈ PBRV (W), W ∈ [0, 1]}.",
                "Por lo general, W es el padre de V, y esto se conoce como la mejor \"política de respuesta\" para V.",
                "El pase aguas arriba del algoritmo genérico de [8] calcula la mejor \"política de respuesta\" para V para cada nodo V que no sea la raíz.",
                "El algoritmo de [9] se basa en la siguiente observación: para calcular un solo equilibrio de Nash por un algoritmo de dos pasos, no es necesario construir toda la mejor \"política de respuesta\" para cada vértice.",
                "La mejor \"política de respuesta\" para U es una política de punto de ruptura para U (como en la definición 2) con V -breakPoints v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados U1 = 1 y U2 = 0.",
                "La mejor \"política de respuesta\" para V no es una política de punto de ruptura (debido a cómo la curva de W = 0 a W = 1 se duplica).",
                "La mejor \"política de respuesta\" para W es una línea horizontal en w = .1 (este es el valor de W que permite v = 2/3 - ver Figura 2, que hace p0 (w) = p1 (w).)",
                "El algoritmo es derrotado por la matriz de pago con p 0 (w) = 2v y p1 (w) = (1 - v) en la que la mejor \"política de respuesta\" para W es una línea horizontal en w = .9.",
                "Para el algoritmo modificado, tenemos que extender la definición de política de punto de interrupción (ver definición 3) para que incluya políticas de punto de ruptura, como la mejor \"política de respuesta\" para V en la Figura 2.",
                "Mostramos que en este caso la mejor \"política de respuesta\" para cada vértice puede representarse como una unión de un número polinómico de rectángulos, donde un rectángulo se define por un par de intervalos cerrados (IV, IU) y consiste en todos los puntos enIV × IU;Puede ser el caso de que uno o ambos de los intervalos IV e IU consistan en un solo punto.",
                "Como se explica en la Sección 3, podemos usar una política de punto de interrupción válida en lugar de la mejor \"política de respuesta\" durante el pase posterior, y aún así garantizar que al final, generaremos un equilibrio de Nash.",
                "Encontrar equilibrios en un árbol (arbitrario) para árboles arbitrarios, la estructura general del algoritmo sigue siendo el mismo, es decir, uno puede construir una mejor \"política de respuesta\" (o, alternativamente, una política de punto de ruptura) para cualquier vértice basado en la mejor respuestaPolíticas de sus hijos.",
                "Considere un vértice V cuyos hijos son U1 ,..., Reino Unido y cuyo padre es W;La mejor \"política de respuesta\" de cada UJ es B (V, UJ).",
                "El pago de V0 es 1 si V1 selecciona la misma acción que V0 y 0 de lo contrario;La mejor \"política de respuesta\" de V0S viene dada por la Figura 6.",
                "Los detalles se pueden encontrar en la versión completa de este documento [6].6.2 La irreductibilidad de la mejor \"política de respuesta\" para TN, mientras que la mejor \"política de respuesta\" construida en la subsección anterior tiene un tamaño exponencial, no está claro \"a priori que es necesario realizar un seguimiento de todos sus segmentos de línea en lugar deConcéntrese en un pequeño subconjunto de estos segmentos.",
                "Sin embargo, resulta que para los algoritmos de dos pasos, como el algoritmo de [8], la mejor \"política de respuesta\" no puede simplificarse.",
                "Para el paso inductivo, la idea principal es que podemos ampliar cualquier parte de una mejor \"política de respuesta\" (¡incluida la parte que se omitió!) Al usar una función de indiferencia apropiada;Esto nos permite reducir el caso J = J0 a J = J0 - 1. 7.",
                "Para este gráfico, la mejor \"política de respuesta\" de un vértice VK en la columna vertebral de la oruga se obtiene combinando la mejor \"política de respuesta\" de su predecesor en la columna vertebral VK - 1 y su otro hijo TK;Dado que este último es una hoja, su mejor política de respuesta es trivial (es decir, [0, 1] 2, [0, 1] × {0}, o [0, 1] × {1}) o consta de dos horizontalessegmentos y un segmento vertical de la forma {α} × [0, 1] que los conecta.",
                "Suponiendo por conveniencia que b (vk, tk) = [0, α] × {0} ∪ {α} × [0, 1] ∪ [α, 1] × {1}, y F es la función de indiferencia para VK,Observamos que la mejor \"política de respuesta\" para VK consta de 5 componentes: ˆf (0), ˆf (1) y tres componentes que corresponden a [0, α] × {0}, {α} × [0, 1], y [α, 1] × {1}.",
                "Por lo tanto, se puede pensar en construir B (VK+1, VK) como el siguiente proceso: Turn B (VK, VK - 1) por π/2, córtelo a lo largo de la línea (ahora horizontal) VK = α, aplique una fraccionadaTransformación lineal a la coordenada horizontal de ambas partes y vuelva a conectarlas usando la imagen del segmento {α} × [0, 1] bajo f.Esto implica que el problema de limitar el tamaño de la mejor \"política de respuesta\" (o, alternativamente, la política de punto de interrupción), puede verse como una generalización del siguiente problema de geometría computacional, que creemos que puede ser de interés independiente: Problema 1.",
                "Esto implica que incluso para una oruga, la mejor \"política de respuesta\" puede ser exponencialmente grande.",
                "Sin embargo, en nuestro ejemplo (que se omite a partir de esta versión del documento debido a las limitaciones de espacio), existe una ruta de tamaño polinómico a través de la mejor \"política de respuesta\", es decir, no prueba que la política de punto de interrupción sea necesariamente exponencial entamaño."
            ],
            "translated_text": "",
            "candidates": [
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Respuestapolítica",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "Política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta",
                "política de respuesta"
            ],
            "error": []
        },
        "downstream pass": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the <br>downstream pass</br>; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the <br>downstream pass</br>, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a breakpoint policy), and still ensure that the <br>downstream pass</br> can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the <br>downstream pass</br> is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the <br>downstream pass</br>, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the <br>downstream pass</br>, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a breakpoint policy) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the breakpoint policy in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A breakpoint policy for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a breakpoint policy has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its breakpoint policy with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a breakpoint policy for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding breakpoint policy.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a breakpoint policy for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a breakpoint policy (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a breakpoint policy such as the one in Figure 3.",
                "Note that this breakpoint policy ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the breakpoint policy for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of breakpoint policy (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a breakpoint policy may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a breakpoint policy as defined in [9], we show how to modify this definition so as to ensure that a breakpoint policy always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A breakpoint policy ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a breakpoint policy is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid breakpoint policy ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid breakpoint policy instead of the best response policy during the <br>downstream pass</br>, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid breakpoint policy ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the <br>downstream pass</br> For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a breakpoint policy) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid breakpoint policy. 6.1 Exponential Size Breakpoint Policy While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the <br>downstream pass</br> of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size breakpoint policy.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: Breakpoint policy for V2. • A consists of an upstream pass and a <br>downstream pass</br>. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The <br>downstream pass</br> is identical to the <br>downstream pass</br> of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the <br>downstream pass</br> on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the <br>downstream pass</br> of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire breakpoint policy for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each breakpoint policy should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized breakpoint policy has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the breakpoint policy), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the breakpoint policy is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Esto no funciona del todo, como mostramos en la Sección 3, aunque introduce una idea útil.1.1 Antecedentes El algoritmo genérico de [8] consta de dos fases a las que nos referiremos como el pase aguas arriba y el \"pase aguas abajo\";1 El primero comienza en las hojas del árbol y termina en la raíz, mientras que el segundo comienza en la raíz y termina en las hojas.",
                "Al comienzo del \"pase posterior\", la raíz selecciona su estrategia e informa a sus hijos sobre su elección.",
                "La idea principal de [9] es que no es necesario realizar un seguimiento de todos los rectángulos en las mejores políticas de respuesta;Más bien, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinomial de la política correspondiente (en [9], este subconjunto se llama política de punto de interrupción), y aún así asegurarse de que el \"pase posterior\" pueda procedercon éxito (una condición suficiente para esto es que el subconjunto de la mejor política de respuesta para V almacenada por el algoritmo contiene una ruta continua de W = 0 a W = 1).1.2 Nuestros resultados Una de las principales contribuciones de nuestro artículo es mostrar que el algoritmo propuesto por [9] es incorrecto.",
                "Con los supuestos anteriores sobre la raíz, el \"pase aguas abajo\" es sencillo: deje que W denote la raíz y v denote a su hijo.",
                "Mientras, en cada paso del \"pase aguas abajo\", el vértice bajo consideración puede seleccionar un vector de estrategias para todos sus hijos para que cada estrategia de niños sea una mejor respuesta potencial a la estrategia de los padres, el algoritmo tiene éxito en producir un Nashequilibrio.",
                "Esto se puede lograr si, al comienzo del \"pase aguas abajo\", tenemos una estructura de datos en la que cada vértice V con el padre W almacena un conjunto ˆb (w, v) ⊆ b (w, v) (llamada política de punto de interrupción) que cubre todos los posibles w ∈ [0, 1].",
                "Como se explica en la Sección 3, podemos usar una política de punto de interrupción válida en lugar de la mejor política de respuesta durante el \"Pase aguas abajo\", y aún así garantizar que al final, generaremos un equilibrio de Nash.",
                "Poner vi = b;Aplique el \"pase aguas abajo\" para cada vértice, VJ, realice un seguimiento de todas las estrategias mixtas posibles VJ 5.",
                "De hecho, una declaración más fuerte es cierta: para cualquier algoritmo de dos pasos de tiempo polinómico (definido más adelante) que funcione con subconjuntos de las mejores políticas de respuesta para este gráfico, podemos elegir los pagos de los vértices para que el \"pase posterior\" deEste algoritmo fallará.",
                "Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasos si 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1 1 1 1 11 1 00000000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: Política de punto de interrupción para V2.• A consiste en un pase aguas arriba y un \"pase aguas abajo\".• Durante el pase ascendente, para cada vértice V con el padre W, A construye un conjunto BB (W, V) ⊆ B (W, V).",
                "Este conjunto se produce a partir de los conjuntos {BB (V, U) |U es un hijo de V} aplicando el procedimiento desde el comienzo de la Sección 6 (sustituyendo BB (V, UJ) por B (V, UJ) para todos los niños UJ de V), y luego posiblemente omitiendo algunos de los puntos de los puntos delConjunto resultante (que luego se almacena explícitamente).• El \"pase aguas abajo\" es idéntico al \"pase aguas abajo\" de [8] como se describe en la Sección 2, excepto que opera en los conjuntos BB (W, V) en lugar de en los conjuntos B (W, V).",
                "El teorema 7 demuestra que cualquier algoritmo de dos pasos fallará durante el \"pase aguas abajo\" en TN si hay un índice j tal que el conjunto BB (VJ+1, VJ) omite cualquier punto interior de cualquiera de los (al menos 3J)segmentos de B (VJ+1, VJ).",
                "Para cualquier algoritmo de dos pasos A para el que existe un índice j, j ∈ [1, n/4], un segmento S de B (VJ, VJ-1) y un punto interior (x, y) de S.Que BB (VJ, VJ - 1) no contiene (x, y), podemos elegir matrices de pago de los vértices VJ ,..., VN para que el \"pase aguas abajo\" de A falle y, además, pagos a V4J ,..., VN es idénticamente 0."
            ],
            "translated_text": "",
            "candidates": [
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase posterior",
                "pase aguas abajo",
                "pase posterior",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "Pase aguas abajo",
                "Pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase posterior",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "pase aguas abajo",
                "Pase aguas abajo",
                "pase aguas abajo"
            ],
            "error": []
        },
        "breakpoint policy": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Nash Equilibria in Graphical Games on Trees Revisited ∗ Edith Elkind University of Warwick Coventry, CV4 7AL, U.K. Leslie Ann Goldberg University of Warwick Coventry, CV4 7AL, U.K. Paul Goldberg University of Warwick Coventry, CV4 7AL, U.K. ABSTRACT Graphical games have been proposed as a game-theoretic model of large-scale distributed networks of non-cooperative agents.",
                "When the number of players is large, and the underlying graph has low degree, they provide a concise way to represent the players payoffs.",
                "It has recently been shown that the problem of finding Nash equilibria in a general degree-3 graphical game with two actions per player is complete for the complexity class PPAD, indicating that it is unlikely that there is any polynomial-time algorithm for this problem.",
                "In this paper, we study the complexity of graphical games with two actions per player on bounded-degree trees.",
                "This setting was first considered by Kearns, Littman and Singh, who proposed a dynamic programming-based algorithm that computes all Nash equilibria of such games.",
                "The running time of their algorithm is exponential, though approximate equilibria can be computed efficiently.",
                "Later, Littman, Kearns and Singh proposed a modification to this algorithm that can find a single Nash equilibrium in polynomial time.",
                "We show that this modified algorithm is incorrect - the output is not always a Nash equilibrium.",
                "We then propose a new algorithm that is based on the ideas of Kearns et al. and computes all Nash equilibria in quadratic time if the input graph is a path, and in polynomial time if it is an arbitrary graph of maximum degree 2.",
                "Moreover, our algorithm can be used to compute Nash equilibria of graphical games on arbitrary trees, but the running time can be exponential, even when the tree has bounded degree.",
                "We show that this is inevitable - any algorithm of this type will take exponential time, even on bounded-degree trees with pathwidth 2.",
                "It is an open question whether our algorithm runs in polynomial time on graphs with pathwidth 1, but we show that finding a Nash equilibrium for a 2-action graphical game in which the underlying graph has maximum degree 3 and constant pathwidth is PPAD-complete (so is unlikely to be tractable).",
                "Categories and Subject Descriptors F.2 [Theory of Computation]: Analysis of Algorithms and Problem Complexity; J.4 [Computer Applications]: Social and Behavioral Sciences-economics General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION Graphical games were introduced in the papers of Kearns et al. [8] and Littman et al. [9] as a succinct representation of games with a large number of players.",
                "The classical normal form (or matrix form) representation has a size that is exponential in the number of players, making it unsuitable for large-scale distributed games.",
                "A graphical game associates each player with a vertex of an underlying graph G, and the payoff to that player is a function of the actions chosen by himself and his neighbours in G; if G has low degree, this is a concise way to represent a game with many players.",
                "The papers [8, 9] give a dynamic-programming algorithm for finding Nash equilibria in graphical games where there are two actions per player and G is a tree.",
                "The first of these papers describes a generic algorithm for this problem that can be specialized in two ways: as an algorithm that computes approximations to all Nash equilibria in time polynomial in the input size and the approximation quality, or as an exponential-time algorithm that allows the exact computation of all Nash equilibria in G. In [9], the authors propose a modification to the latter algorithm that aims to find a single Nash equilibrium in polynomial time.",
                "This does not quite work, as we show in Section 3, though it introduces a useful idea. 1.1 Background The generic algorithm of [8] consists of two phases which we will refer to as the upstream pass and the downstream pass; 1 the former starts at the leaves of the tree and ends at the root, while the latter starts at the root and ends at the leaves.",
                "It is assumed that each player has two pure strategies (actions), which are denoted by 0 and 1; it follows that any mixed strategy can be represented as a single number x ∈ [0, 1], where x is the probability that the player selects 1.",
                "During the upstream pass, each vertex V computes the set of its potential best responses to every mixed strategy w of its parent W ; a strategy v is a potential best response to w if 1 Note that the terminology upstream and downstream are reversed in [8, 9] - our trees are rooted at the top. 100 there is a Nash equilibrium in the graphical game downstream of V (inclusive) given that W plays w (for a more technical definition, the reader is referred to Section 2).",
                "The output of this stage can be viewed as a (continuous) table T(w, v), where T(w, v) = 1 if and only if v is a potential best response to w; we refer to this table as the best response policy for V .",
                "The generic algorithm does not address the problem of representing the best response policy; in fact, the most important difference between the two instantiations of the generic algorithm described in [8] is in their approach to this issue.",
                "The computation is performed inductively: the best response policy for V is computed based on the best response policies of V s children U1, . . . , Uk.",
                "By the end of the upstream pass, all children of the root have computed their best response policies.",
                "In the beginning of the downstream pass, the root selects its strategy and informs its children about its choice.",
                "It also selects a strategy for each child.",
                "A necessary and sufficient condition for the algorithm to proceed is that the strategy of the root is a best response to the strategies of its children and, for each child, the chosen strategy is one of the pre-computed potential best responses to the chosen strategy of the root.",
                "The equilibrium then propagates downstream, with each vertex selecting its childrens actions.",
                "The action of the child is chosen to be any strategy from the pre-computed potential best responses to the chosen strategy of the parent.",
                "To bound the running time of this algorithm, the paper [8] shows that any best response policy can be represented as a union of an exponential number of rectangles; the polynomial time approximation algorithm is obtained by combining this representation with a polynomial-sized grid.",
                "The main idea of [9] is that it is not necessary to keep track of all rectangles in the best response policies; rather, at each step of the upstream pass, it is possible to select a polynomial-size subset of the corresponding policy (in [9], this subset is called a <br>breakpoint policy</br>), and still ensure that the downstream pass can proceed successfully (a sufficient condition for this is that the subset of the best response policy for V stored by the algorithm contains a continuous path from w = 0 to w = 1). 1.2 Our Results One of the main contributions of our paper is to show that the algorithm proposed by [9] is incorrect.",
                "In Section 3 we describe a simple example for which the algorithm of [9] outputs a vector of strategies that does not constitute a Nash equilibrium of the underlying game.",
                "In Sections 4, 5 and 6 we show how to fix the algorithm of [9] so that it always produces correct output.",
                "Section 4 considers the case in which the underlying graph is a path of length n. For this case, we show that the number of rectangles in each of the best response policies is O(n2 ).",
                "This gives us an O(n3 ) algorithm for finding a Nash equilibrium, and for computing a representation of all Nash equilibria. (This algorithm is a special case of the generic algorithm of [8] - we show that it runs in polynomial time when the underlying graph is a path.)",
                "We can improve the running time of the generic algorithm using the ideas of [9].",
                "In particular, we give an O(n2 ) algorithm for finding a Nash equilibrium of a graphical game on a path of length n. Instead of storing best response policies, this algorithm stores appropriately-defined subsets, which, following [9], we call breakpoint policies (modifying the definition as necessary).",
                "We obtain the following theorem THEOREM 1.",
                "There is an O(n2 ) algorithm that finds a Nash equilibrium of a graphical game with two actions per player on an n-vertex path.",
                "There is an O(n3 ) algorithm that computes a representation of all Nash equilibria of such a game.",
                "In Section 5 we extend the results of Section 4 to general degree2 graphs, obtaining the following theorem.",
                "THEOREM 2.",
                "There is a polynomial-time algorithm that finds a Nash equilibrium of a graphical game with two actions per player on a graph with maximum degree 2.",
                "In Section 6 we extend our algorithm so that it can be used to find a Nash equilibrium of a graphical game on an arbitrary tree.",
                "Even when the tree has bounded degree, the running time can be exponential.",
                "We show that this is inevitable by constructing a family of graphical games on bounded-degree trees for which best response policies of some of the vertices have exponential size, and any twopass algorithm (i.e., an algorithm that is similar in spirit to that of [8]) has to store almost all points of the best response policies.",
                "In particular, we show the following.",
                "THEOREM 3.",
                "There is an infinite family of graphical games on bounded-degree trees with pathwidth 2 such that any two-pass algorithm for finding Nash equilibria on these trees requires exponential time and space.",
                "It is interesting to note that the trees used in the proof of Theorem 3 have pathwidth 2, that is, they are very close to being paths.",
                "It is an open question whether our algorithm runs in polynomial time for graphs of pathwidth 1.",
                "This question can be viewed as a generalization of a very natural computational geometry problem - we describe it in more detail in Section 8.",
                "In Section 7, we give a complexity-theoretic intractability result for the problem of finding a Nash equilibrium of a graphical game on a graph with small pathwidth.",
                "We prove the following theorem.",
                "THEOREM 4.",
                "Consider the problem of finding a Nash equilibrium for a graphical game in which the underlying graph has maximum degree 3 and pathwidth k. There is a constant k such that this problem is PPAD-complete.",
                "Theorem 4 limits the extent to which we can exploit path-like properties of the underlying graph, in order to find Nash equilibria.",
                "To prove Theorem 4, we use recent PPAD-completeness results for games, in particular the papers [7, 4] which show that the problem of finding Nash equilibria in graphical games of degree d (for d ≥ 3) is computationally equivalent to the problem of solving r-player normal-form games (for r ≥ 4), both of which are PPAD-complete. 2.",
                "PRELIMINARIES AND NOTATION We consider graphical games in which the underlying graph G is an n-vertex tree.",
                "Each vertex has two actions, which are denoted by 0 and 1.",
                "A mixed strategy is given by a single number x ∈ [0, 1], which denotes the probability that the player selects action 1.",
                "Fur the purposes of the algorithm, the tree is rooted arbitrarily.",
                "For convenience, we assume without loss of generality that the root has a single child, and that its payoff is independent of the action chosen by the child.",
                "This can be achieved by first choosing an arbitrary root of the tree, and then adding a dummy parent of this root, giving the new parent a constant payoff function.",
                "Given an edge (V, W ) of the tree G, and a mixed strategy w for W , let G(V,W ),W =w be the instance obtained from G by (1) deleting all nodes Z which are separated from V by W (i.e., all nodes Z such that the path from Z to V passes through W ), and (2) restricting the instance so that W is required to play mixed strategy w. Definition 1.",
                "Suppose that (V, W ) is an edge of the tree, that v is a mixed strategy for V and that w is a mixed strategy for W . 101 We say that v is a potential best response to w (denoted by v ∈ pbrV (w)) if there is an equilibrium in the instance G(V,W ),W =w in which V has mixed strategy v. We define the best response policy for V , given W , as B(W, V ) = {(w, v) | v ∈ pbrV (w), w ∈ [0, 1]}.",
                "Typically, W is the parent of V , and this is just referred to as the best response policy for V .",
                "The expression B(W, V )|V =v is used to denote the set B(W, V ) ∩ [0, 1]×{v}.",
                "The upstream pass of the generic algorithm of [8] computes the best response policy for V for every node V other than the root.",
                "With the above assumptions about the root, the downstream pass is straightforward: Let W denote the root and V denote its child.",
                "The root selects any pair (w, v) from B(W, V ).",
                "It decides to play mixed strategy w and it instructs V to play mixed strategy v. The remainder of the downward pass is recursive.",
                "When a node V is instructed by its parent to adopt mixed strategy v, it does the following for each child U - It finds a pair (v, u) ∈ B(V, U) (with the same v value that it was given by its parent) and instructs U to play u. 3.",
                "ALGORITHM OF LITTMAN ET AL.",
                "The algorithm of [9] is based on the following observation: to compute a single Nash equilibrium by a two-pass algorithm, it is not necessary to construct the entire best response policy for each vertex.",
                "As long as, at each step of the downstream pass, the vertex under consideration can select a vector of strategies for all its children so that each childs strategy is a potential best response to the parents strategy, the algorithm succeeds in producing a Nash equilibrium.",
                "This can be achieved if, at the beginning of the downstream pass, we have a data structure in which each vertex V with parent W stores a set ˆB(W, V ) ⊆ B(W, V ) (called a <br>breakpoint policy</br>) which covers every possible w ∈ [0, 1].",
                "We will show later that a sufficient condition for the construction of such a data structure is the invariant that, at every level of the upstream pass, ˆB(W, V ) contains a continuous path from w = 0 to w = 1.",
                "In [9], it is suggested that we can select the <br>breakpoint policy</br> in a particular way.",
                "Namely, the paper uses the following definition: Definition 2. (cf. [9]) A <br>breakpoint policy</br> for a node V with parent W consists of an ordered set of W -breakpoints w0 = 0 < w1 < w2 < · · · < wt−1 < wt = 1 and an associated set of V -values v1, . . . , vt.",
                "The interpretation is that for any w ∈ [0, 1], if wi−1 < w < wi for some index i and W plays w, then V shall play vi; and if w = wi for some index i, then V shall play any value between vi and vi+1.",
                "We say such a <br>breakpoint policy</br> has t − 1 breakpoints.",
                "The paper then claims that any vertex V can compute its <br>breakpoint policy</br> with respect to its parent W given the breakpoint policies of its children U1, . . . , Uk.",
                "The proof proceeds by ordering the childrens breakpoints (i.e., the respective values of v) from left to right (it can be assumed without loss of generality that all these breakpoints are distinct) and considering them in turn; each such point vl ∈ {v1, . . . , vL} corresponds to a fixed choice of strategies for k − 1 children and an interval of admissible strategies for one child.",
                "Assume for convenience that this child is U1 and its interval of admissible strategies at vl is [a, b]; assume also that for Uj , j = 2, . . . , k, their respective breakpoint policies prescribe them to play uj in response to vl.",
                "Let P i (u, w), i = 0, 1, be the expected payoff for V when V plays i, U1 plays u, each Uj , j = 2, . . . , k, plays uj, and W plays w, and consider the set Wl = {w ∈ [0, 1] | ∃u ∈ [a, b] s.t.",
                "P 0 (u, w) = P1 (u, w)}; note that for any w ∈ Wl we have vl ∈ pbrV (w). v1 v2 v3 v4 v5 v6 v7 V W Figure 1: LKS: Trimming to find breakpoint policies.",
                "The authors show that for any breakpoint vl, the set Wl is either empty, a single interval, or a union of two non-floating intervals (an interval is non-floating if one of its endpoints is 0 or 1); moreover, the union of all sets Wl, l = 1, . . . , L, covers the interval [0, 1].",
                "It follows easily that one can cover [0, 1] with at most L+2 intervals, each of which is a subset of some Wl.",
                "The authors then claim that any such cover can be transformed into a <br>breakpoint policy</br> for V .",
                "Namely, they say that for any two intervals Wl1 and Wl2 in the cover, Any overlap between Wl1 and Wl2 can be arbitrarily assigned coverage by Wl1 and Wl2 trimmed accordingly (cf. [9], p. 5).",
                "They illustrate their approach in a figure, which is reproduced as Figure 1 here.",
                "In the figure, the dashed horizontal lines represent the breakpoints v1, v2, . . . , v7 and the solid intervals along these breakpoints are the sets W1, W2, . . . , W7.",
                "The thick connected path is the corresponding <br>breakpoint policy</br>.",
                "It is chosen as follows: begin on the left, and always jump to the interval allowing greatest progress to the right.",
                "To see why this approach does not work in general, consider a path of length 4 consisting of an indifferent root R, its child W , W s child V , and V s child U.",
                "Suppose that U receives a payoff of 1 if it plays differently to V and 0 otherwise.",
                "Thus, if v denotes the mixed strategy of V (i.e., V plays 1 with probability v), then the expected payoff that U derives from playing 0 is given by P0 (U) = v and the expected payoff that U derives from playing 1 is given by P1 (U) = 1 − v. Suppose that V derives no payoff from playing 1 (so P1 (V ) = 0) and that its payoff matrix for playing 0 is 1 −9 9 −1 , so if u denotes the mixed strategy of U and w denotes the mixed strategy of W , the expected payoff that V derives from playing 0 is given by P0 (V ) = (1 − u)(1 − w) + (1 − u)w(−9) + u(1 − w)9 + uw(−1).",
                "Using the techniques of [8] (or, alternatively, those of Section 4), it is not hard to verify that the best response policies for U and V (as in Definition 1) are given by the graphs in Figure 2.",
                "The best response policy for U is a <br>breakpoint policy</br> for U (as in Definition 2) with V -breakpoints v0 = 0, v1 = 1/2 and v2 = 1 with associated values u1 = 1 and u2 = 0.",
                "The best response policy for V is not a <br>breakpoint policy</br> (because of how the curve from w = 0 to w = 1 doubles back).",
                "The LKS algorithm would trim to get a <br>breakpoint policy</br> such as the one in Figure 3.",
                "Note that this <br>breakpoint policy</br> ˆB(W, V ) is invalid in the sense that it does not satisfy ˆB(W, V ) ⊆ B(W, V ). 102 1 10.5 0.5 1 10.1 0.9 u v v w Figure 2: Best response policies for U and V . 0.1 0.9 1 0.5 1 v w Figure 3: A trimmed policy for V The point is that the payoff matrix of W can now be chosen to prevent the LKS algorithm from finding a Nash equilibrium.",
                "For example, suppose the payoffs are given so that P0 (W ) = v and P1 (W ) = (1−v)2.",
                "The best response policy for W is a horizontal line at w = .1 (This is the value of w that allows v = 2/3 - see Figure 2, which makes P0 (W ) = P1 (W ).)",
                "In the downward pass, the chosen values are w = .1, then, from the trimming, v = 0 and u = 1, which is not a Nash equilibrium since W prefers action 1.",
                "The failure of the algorithm is not caused by the fact that the trimming policy goes as far to the right as possible.",
                "Any other trimming would be just as bad.",
                "For example, suppose the <br>breakpoint policy</br> for V has v = 0 until some point w∗ < .9 and then jumps to v = 1.",
                "The algorithm is then defeated by the payoff matrix with P 0 (W ) = 2v and P1 (W ) = (1 − v) in which the best response policy for W is a horizontal line at w = .9.",
                "The algorithm then gives w = .9, v = 1, and u = 0, which is not a Nash equilibrium since W prefers action 0.",
                "We conclude that the LKS algorithm does not always find a Nash equilibrium.",
                "In Sections 4 and 6 we show how to modify the algorithm so that it always finds a Nash equilibrium.",
                "For the modified algorithm, we have to extend the definition of <br>breakpoint policy</br> (see Definition 3) so that it includes breakpoint policies such as the best response policy for V in Figure 2.",
                "Unfortunately, such a <br>breakpoint policy</br> may be exponential in size (see Figure 7) so the corrected algorithm does not run in polynomial time on all trees.",
                "In the next section, we show that it runs in polynomial time on a path. 4.",
                "FINDING EQUILIBRIA ON A PATH In this section, we focus on the case when the underlying graph is a path, i.e., its vertex set is {V1, . . . , Vn}, and its edge set is {(Vj , Vj+1) | j = 1, . . . , n − 1}.",
                "We show that in this case the best response policy for each vertex can be represented as a union of a polynomial number of rectangles, where a rectangle is defined by a pair of closed intervals (IV , IU ) and consists of all points in IV × IU ; it may be the case that one or both of the intervals IV and IU consists of a single point.",
                "THEOREM 5.",
                "For any j = 1, . . . , n, the set B(Vj , Vj−1) can be represented as a disjoint union of at most (j + 4)2 rectangles.",
                "Moreover, given such representation of B(Vj , Vj−1), one can compute a representation of B(Vj+1, Vj) in time O(j2 ).",
                "PROOF.",
                "For any set A ⊆ [0, 1]2 that is represented as a union of a finite number of rectangles, we say that a point u ∈ [0, 1] on the U-axis is a U-event point of A if u = 0 or u = 1 or A contains a rectangle of the form IV × IU and u is an endpoint of IU ; V -event points are defined similarly.",
                "Observe that for any u ∈ [0, 1], the number of connected components of [0, 1]×{u} ∩ A is at most the number of V -event points of A.",
                "We use induction on j to show that for each Vj the statement of the theorem holds and, additionally, each B(Vj , Vj−1) has at most 2j + 4 event points.",
                "To simplify the base case, we modify the graphical game by appending a dummy vertex V0 to the beginning of the path: the only neighbour of V0 is V1, the payoffs of V0 are always equal to 0, and the payoffs of all other vertices (including V1) are the same as in the original game.",
                "For j = 0, we have B(V1, V0) = [0, 1]2 , so the statement of the theorem is trivially true.",
                "Now, suppose that j > 0, set V = Vj and let U = Vj−1 and W = Vj+1 be the vertices that precede and follow V , respectively.",
                "The payoffs to V are described by a 2×2×2 matrix P: Pxyz is the payoff that V receives when U plays x, V plays y, and W plays z, where x, y, z ∈ {0, 1}.",
                "Suppose that U plays 1 with probability u and W plays 1 with probability w. Then V s expected payoff from playing 0 is P0 =(1−u)(1−w)P000+(1−u)wP001+u(1−w)P100+uwP101, while its expected payoff from playing 1 is P1 =(1−u)(1−w)P010+(1−u)wP011+u(1−w)P110+uwP111.",
                "If P 0 > P1 , V strictly prefers to play 0, if P0 < P1 , V strictly prefers to play 1, and if P0 = P1 , V is indifferent, i.e., can play any (mixed) strategy.",
                "Since P0 and P1 are linear in w and u, there exist some constants A1, A0, B1, and B0 that depend on the matrix P, but not on u and w, such that P0 − P1 = w(B1u + B0) − (A1u + A0). (1) Depending on the values of A1, A0, B1, and B0, we subdivide the rest of the proof into the following cases. • B1 = 0, B0 = 0.",
                "In this case, P0 > P1 if and only if A1u + A0 < 0.",
                "If also A1 = 0, A0 = 0, clearly, B(W, V ) = [0, 1]2 , and the statement of the theorem is trivially true.",
                "Otherwise, the vertex V is indifferent between 0 and 1 if and only if A1 = 0 and u = −A0/A1.",
                "Let V = {v | v ∈ (0, 1), −A0/A1 ∈ pbrU (v)}.",
                "By the inductive hypothesis, V consists of at most 2(j − 1) + 4 segments and isolated points.",
                "For any v ∈ V, we have B(W, V )|V =v = [0, 1]: no matter what W plays, as long as U is playing −A0/A1, V is content to play v. On the other hand, for any v ∈ (0, 1) \\ V we have B(W, V )|V =v = ∅: when V plays v, U can only respond with u = −A0/A1, in which case V can benefit from switching to one of the pure strategies.",
                "To complete the description of B(W, V ), it remains to analyze the cases v = 0 and v = 1.",
                "The vertex V prefers to play 0 if A1 > 0 and u ≤ −A0/A1, or A1 < 0 and u ≥ −A0/A1, or 103 A1 = 0 and A0 < 0.",
                "Assume for now that A1 > 0; the other two cases can be treated similarly.",
                "In this case 0 ∈ pbrV (w) for some w ∈ [0, 1] if and only if there exists a u ∈ pbrU (0) such that u ≤ −A0/A1: if no such u exists, whenever V plays 0 either Us response is not in pbrU (0) or V can improve its payoff by playing 1.",
                "Therefore, either B(W, V )|V =0 = [0, 1] or B(W, V )|V =0 = ∅.",
                "Similarly, B(W, V )|V =1 is equal to either [0, 1] or ∅, depending on pbrU (1).",
                "Therefore, the set B(W, V ) consists of at most 2j + 4 ≤ (j + 4)2 rectangles: B(W, V ) ∩ [0, 1]×(0, 1) = [0, 1]×V contributes at most 2j + 2 rectangles, and each of the sets B(W, V )|V =0 and B(W, V )|V =1 contributes at most one rectangle.",
                "Similarly, its total number of event points is at most 2j + 4: the only W -event points are 0 and 1, each V -event point of B(W, V ) is a V -event point of B(V, U), and there are at most 2j + 2 of them. • B1u + B0 ≡ 0, A1 = αB1, A0 = αB0 for some α ∈ R. In this case, V is indifferent between 0 and 1 if and only if w = α, or B1 = 0 and u = −B0/B1 = −A0/A1.",
                "Similarly to the previous case, we can show that B(W, V )∩[0, 1]×(0, 1) consists of the rectangle {α}×[0, 1] and at most 2j + 2 rectangles of the form [0, 1]×IV , where each IV corresponds to a connected component of B(V, U)|U=−B0/B1 .",
                "Furthermore, V prefers to play 0 if B1u + B0 > 0 and w ≥ α or B1u + B0 < 0 and w ≤ α.",
                "Therefore, if B1u∗ + B0 > 0 for some u∗ ∈ pbrU (0), then B(W, V )|V =0 contains [α, +∞) ∩ [0, 1] and if B1u∗∗ + B0 < 0 for some u∗∗ ∈ pbrU (0), then B(W, V )|V =0 contains [−∞, α] ∩ [0, 1]; if both u∗ and u∗∗ exist, B(W, V )|V =0 = [0, 1].",
                "The set B(W, V )|V =1 can be described in a similar manner.",
                "By the inductive hypothesis, B(V, U) has at most 2j + 2 event points; as at least two of these are U-event points, it has at most 2j V -event points.",
                "Since each V -event point of B(W, V ) is a Vevent point of B(V, U) and B(W, V ) has at most 3 W -event points (0, 1, and α), its total number of event points is at most 2j + 3 < 2j +4.",
                "Also, similarly to the previous case it follows that B(W, V ) consists of at most 2j + 4 < (j + 4)2 rectangles. • B1u + B0 ≡ 0, α(B1u + B0) ≡ A1u + A0.",
                "In this case, one can define the indifference function f(·) as f(u) = A(u) B(u) = A1u+A0 B1u+B0 , where A(u) and B(u) never turn into zero simultaneously.",
                "Observe that whenever w = f(u) and u, w ∈ [0, 1], V is indifferent between playing 0 and 1.",
                "For any A ⊆ [0, 1]2 , we define a function ˆfV by ˆfV (A) = {(f(u), v) | (v, u) ∈ A}; note that ˆfV maps subsets of [0, 1]2 to subsets of R×[0, 1].",
                "Sometimes we drop the subscript V when it is clear from the context.",
                "LEMMA 1.",
                "For any (w, v) ∈ [0, 1]×(0, 1) we have (w, v) ∈ B(W, V ) if and only if there exists a u ∈ [0, 1] such that (v, u) ∈ B(V, U) and w = f(u).",
                "PROOF.",
                "Fix an arbitrary v ∈ (0, 1).",
                "Suppose that U plays some u ∈ pbrU (v), w = f(u) satisfies w ∈ [0, 1], and W plays w. There exists a vector of strategies v1, . . . , vj−1 = u, vj = v such that for each Vk, k < j, its strategy is a best response to its neighbours strategies.",
                "Since w = f(u), V is indifferent between playing 0 and 1; in particular, it can play v. Therefore, if we define vj+1 = w, the vector of strategies (v1, . . . , vj+1) will satisfy the conditions in the definition of potential best response, i.e., we have v ∈ pbrV (w).",
                "Conversely, suppose v ∈ pbrV (w) for some w ∈ [0, 1], v = 0, 1.",
                "Then there exists a vector of strategies v1, . . . , vj−1, vj = v, vj+1 = w such that for each Vk, k ≤ j, its strategy is a best response to its neighbours strategies.",
                "As v = 0, 1, V is, in fact, indifferent between playing 0 and 1, which is only possible if w = f(vj−1).",
                "Choose u = vj−1; by construction, u ∈ pbrU (v).",
                "Lemma 1 describes the situations when V is indifferent between playing 0 and playing 1.",
                "However, to fully characterize B(W, V ), we also need to know when V prefers a pure strategy.",
                "Define ˆf(0) = ∪u∈pbrU (0)Ru, where Ru = ´ [f(u), +∞)×{0} if B(u) > 0, (−∞, f(u)]×{0} if B(u) < 0. and ˆf(1) = ∪u∈pbrU (1)Ru, where Ru = ´ [f(u), +∞)×{1} if B(u) < 0, (−∞, f(u)]×{1} if B(u) > 0.",
                "LEMMA 2.",
                "For any w ∈ [0, 1], we have (w, 0) ∈ ˆf(0) if and only if 0 ∈ pbrV (w) and (w, 1) ∈ ˆf(1) if and only if 1 ∈ pbrV (w).",
                "PROOF.",
                "Consider an arbitrary u0 ∈ pbrU (0).",
                "If B(u0) > 0, for u = u0 the inequality P0 ≥ P1 is equivalent to w ≥ f(u0).",
                "Therefore, when U plays u0 and W plays w, w ≥ f(u0), V prefers to play 0; as u0 ∈ pbrU (u), it follows that 0 ∈ pbrV (w).",
                "The argument for the case B(u0) < 0 is similar.",
                "Conversely, if 0 ∈ pbrV (w) for some w ∈ [0, 1], there exists a vector (v1, . . . , vj−1, vj = 0, vj+1 = w) such that for each Vk, k ≤ j, Vk plays vk, and this strategy is a best response to the strategies of Vks neighbours.",
                "Note that for any such vector we have vj−1 ∈ pbrU (0).",
                "By way of contradiction, assume (w, 0) ∈ Ë u∈pbrU (0) Ru.",
                "Then it must be the case that for any u0 ∈ pbrU (0) either f(u0) < w and Ru0 = (−∞, f(u0)]×{0} or f(u0) > w and Ru0 = [f(u0), +∞)×{0}.",
                "In both cases, when V plays 0, U plays u0, and V plays w, the inequality between f(u0) and w is equivalent to P0 < P1 , i.e., V would benefit from switching to 1.",
                "The argument for ˆf(1) is similar.",
                "Together, Lemma 1 and Lemma 2 completely describe the set B(W, V ): we have B(W, V ) = ˆf(0) ∪ ˆf(B(V, U)) ∪ ˆf(1) [0, 1]2 .",
                "It remains to show that B(W, V ) can be represented as a union of at most (j + 4)2 rectangles, has at most 2j + 4 event points, and can be computed in O(j2 ) time.",
                "Set u∗ = −B0/B1. 2 Consider an arbitrary rectangle R = [v1, v2]×[u1, u2] ⊆ B(V, U).",
                "If u∗ ∈ [u1, u2], the function f(·) is continuous on [u1, u2] and hence ˆf(R) = [fmin, fmax]×[v1, v2], where fmin = min{f(u1), f(u2)}, fmax = max{f(u1), f(u2)}, i.e., in this case ˆf(R) ∩ [0, 1]2 consists of a single rectangle.",
                "Now, suppose that R is intersected by the line [0, 1]×{u∗ }; as was noted earlier, there are at most 2j+2 such rectangles.",
                "Suppose that limu→u∗− f(u) = +∞; as f(·) is a fractional linear function, this implies that limu→u∗+ f(u) = −∞ and also f(u1) > f(u2).",
                "Since f(·) is continuous on [u1, u∗ ) and (u∗ , u2], it is easy to see that ˆf([v1, v2]×[u1, u∗ )) = [f(u1), +∞)×[v1, v2] 2 The case B1 = 0 causes no special problems.",
                "For completeness, set u∗ to be any value outside of [0, 1] in this case. 104 v u v u* 1 f(0) f(a)f(b) f(1) a b (0, 0) w v 2 v (0, 0) 1 1 1 v 2 v 1 1 Figure 4: f is increasing on (−∞, u∗ ) and (u∗ , +∞). and ˆf([v1, v2]×(u∗ , u2]) = (−∞, f(u2)]×[v1, v2], i.e., in this case ˆf(R) ∩ [0, 1]2 consists of at most two rectangles.",
                "The case limu→u∗− f(u) = −∞ is similar.",
                "As ˆf(B(V, U)) = Ë R⊂B(V,U) ˆf(R), it follows that ˆf(B(V, U)) consists of at most (j + 3)2 + 2j + 2 rectangles.",
                "Also, it is easy to see that both ˆf(0) and ˆf(1) consist of at most 2 line segments each.",
                "We conclude that B(W, V ) can be represented as a union of at most (j + 3)2 + 2j + 6 < (j + 4)2 rectangles.",
                "Moreover, if v is a V -event point of B(W, V ), then v is a Vevent point of B(V, U) (this includes the cases v = 0 and v = 1, as 0 and 1 are V -event points of B(V, U)) and if w is a W -event point of B(W, V ), then either w = 0 or w = 1 or there exists some u ∈ [0, 1] such that w = f(u) and u is a U-event point of B(V, U).",
                "Hence, B(W, V ) has at most 2j + 4 event points.",
                "The O(j2 ) bound on the running time in Theorem 5 follows from our description of the algorithm.",
                "The O(n3 ) bound on the overall running time for finding a Nash equilibrium (and a representation of all Nash equilibria) follows. 4.1 Finding a Single Nash Equilibrium in O(n2 ) Time The upper bound on the running time of our algorithm is tight, at least assuming the straightforward implementation, in which each B(Vj+1, Vj) is stored as a union of rectangles: it is not hard to construct an example in which the size of B(Vj+1, Vj) is Ω(j2 ).",
                "However, in some cases it is not necessary to represent all Nash equilibria; rather, the goal is to find an arbitrary equilibrium of the game.",
                "In this section, we show that this problem can be solved in quadratic time, thus obtaining a proof of Theorem 1.",
                "Our solution is based on the idea of [9], i.e., working with subsets of the best response policies rather than the best response policies themselves; following [9], we will refer to such subsets as breakpoint policies.",
                "While it is not always possible to construct a <br>breakpoint policy</br> as defined in [9], we show how to modify this definition so as to ensure that a <br>breakpoint policy</br> always exists; moreover, we prove that for a path graph, the breakpoint policy of any vertex can be stored in a data structure whose size is linear in the number of descendants this vertex has.",
                "Definition 3.",
                "A <br>breakpoint policy</br> ˆB(V, U) for a vertex U whose parent is V is a non-self-intersecting curve of the form X1 ∪ Y1 ∪ · · · ∪ Ym−1 ∪ Xm, where Xi = [vi−1, vi]×{ui}, Yi = {vi}×[ui, ui+1] and ui, vi ∈ [0, 1] for i = 0, . . . , m. We say that a <br>breakpoint policy</br> is valid if v0 = 0, vm = 1, and ˆB(V, U) ⊆ B(V, U).",
                "We will sometimes abuse notation by referring to ˆB(V, U) as a collection of segments Xi, Yi rather than their union.",
                "Note that we do not require that vi ≤ vi+1 or ui ≤ ui+1; consequently, in any argument involving breakpoint policies, all segments are to be treated as directed segments.",
                "Observe that any valid <br>breakpoint policy</br> ˆB(V, U) can be viewed as a continuous 1-1 mapping γ(t) = (γv(t), γu(t)), γ : [0, 1] → [0, 1]2 , where γ(0) = (0, u1), γ(1) = (1, um) and there exist some t0 = 0, t1, . . . , t2m−2 = 1 such that {γ(t) | t2k ≤ t ≤ t2k+1} = Xk+1, {γ(t) | t2k+1 ≤ t ≤ t2k+2} = Yk+1.",
                "As explained in Section 3, we can use a valid <br>breakpoint policy</br> instead of the best response policy during the downstream pass, and still guarantee that in the end, we will output a Nash equilibrium.",
                "Theorem 6 shows that one can inductively compute valid breakpoint policies for all vertices on the path; the proof of this theorem can be found in the full version of this paper [6].",
                "THEOREM 6.",
                "For any V = Vj, one can find in polynomial time a valid <br>breakpoint policy</br> ˆB(W, V ) that consists of at most 2j + 1 segments. 5.",
                "NASH EQUILIBRIA ON GRAPHS WITH MAXIMUM DEGREE 2 In this section we show how the algorithm for paths can be applied to solve a game on any graph whose vertices have degree at most 2.",
                "A graph having maximum degree 2 is, of course, a union of paths and cycles.",
                "Since each connected component can be handled independently, to obtain a proof of Theorem 2, we only need to show how to deal with cycles.",
                "Given a cycle with vertices V1, . . . , Vk (in cyclic order), we make two separate searches for a Nash equilibrium: first we search for a Nash equilibrium where some vertex plays a pure strategy, then we search for a fully mixed Nash equilibrium, where all vertices play mixed strategies.",
                "For i ≤ k let vi denote the probability that Vi plays 1.",
                "The first search can be done as follows.",
                "For each i ∈ {1, . . . , k} and each b ∈ {0, 1}, do the following. 1.",
                "Let P be the path (Vi+1, Vi+2 . . . , Vk, V1, . . . , Vi−1, Vi) 2.",
                "Let payoff to Vi+1 be based on putting vi = b (so it depends only on vi+1 and vi+2.) 3.",
                "Apply the upstream pass to P 4.",
                "Put vi = b; apply the downstream pass For each vertex, Vj, keep track of all possible mixed strategies vj 5.",
                "Check whether Vi+1 has any responses that are consistent with vi = b; if so we have a Nash equilibrium. (Otherwise, there is no Nash equilibrium of the desired form.)",
                "For the second search, note that if Vi plays a mixed strategy, then vi+1 and vi−1 satisfy an equation of the form vi+1 = (A0 + A1vi−1)/(B0 + B1vi−1).",
                "Since all vertices in the cycle play mixed strategies, we have vi+3 = (A0 +A1vi+1)/(B0 +B1vi+1).",
                "Composing the two linear fractional transforms, we obtain vi+3 = (A0 +A1 vi−1)/(B0 +B1 vi−1). for some new constants A0 , A1 , B0 , B1 .",
                "Choose any vertex Vi.",
                "We can express vi in terms of vi+2, then vi+4, vi+6 etc. and ultimately vi itself to obtain a quadratic equation (for vi) that is simple to derive from the payoffs in the game.",
                "If the equation is non-trivial it has at most 2 solutions in (0, 1).",
                "For an odd-length cycle all other vj s are derivable from those solutions, and if a fully mixed Nash equilibrium exists, all the vj should turn out to be real numbers in the range (0, 1).",
                "For an even-length cycle, we obtain two quadratic equations, one for vi and another for 105 vi+1, and we can in the same way test whether any solutions to these yield values for the other vj , all of which lie in (0, 1).",
                "If the quadratic equation is trivial, there is potentially a continuum of fully-mixed equilibria.",
                "The values for vi that may occur in a Nash equilibrium are those for which all dependent vj values lie in (0, 1); the latter condition is easy to check by computing the image of the interval (0, 1) under respective fractional linear transforms. 6.",
                "FINDING EQUILIBRIA ON AN (ARBITRARY) TREE For arbitrary trees, the general structure of the algorithm remains the same, i.e., one can construct a best response policy (or, alternatively, a <br>breakpoint policy</br>) for any vertex based on the best response policies of its children.",
                "We assume that the degree of each vertex is bounded by a constant K, i.e., the payoff matrix for each vertex is of size O(2K ).",
                "Consider a vertex V whose children are U1, . . . , Uk and whose parent is W ; the best response policy of each Uj is B(V, Uj).",
                "Similarly to the previous section, we can compute V s expected payoffs P0 and P1 from playing 0 or 1, respectively.",
                "Namely, when each of the Uj plays uj and W plays w, we have P0 = L0 (u1, . . . , uk, w), P 1 = L1 (u1, . . . , uk, w), where the functions L0 (·, . . . , ·), L1 (·, . . . , ·) are linear in all of their arguments.",
                "Hence, the inequality P0 > P1 can be rewritten as wB(u1, . . . , uk) > A(u1, . . . , uk), where both A(·, . . . , ·) and B(·, . . . , ·) are linear in all of their arguments.",
                "Set u = (u1, . . . , uk) and define the indifference function f : [0, 1]k → [0, 1] as f(u) = A(u)/B(u); clearly, if each Uj plays uj, W plays w and w = f(u), V is indifferent between playing 0 and 1.",
                "For any X = X1 × · · · × Xk, where Xi ⊆ [0, 1]2 define ˆf(X) = {(f(u), v) | (v, ui) ∈ Xi, i = 1, . . . , k} Also, set ˆf(0) = {(w, 0) | ∃u s.t. ui ∈ pbrUi (0) and wB(u) ≥ A(u)} and ˆf(1) = {(w, 1) | ∃u s.t. ui ∈ pbrUi (1) and wB(u) ≤ A(u)}.",
                "As in previous section, we can show that B(W, V ) is equal to ˆf(0) ∪ ˆf(B(V, U1) × · · · × B(V, Uk)) ∪ ˆf(1) [0, 1]2 ; also, any path from w = 0 to w = 1 that is a subset of B(W, V ) constitutes a valid <br>breakpoint policy</br>. 6.1 Exponential Size <br>breakpoint policy</br> While the algorithm of Section 4 can be generalized for boundeddegree trees, its running time is no longer polynomial.",
                "In fact, the converse is true: we can construct a family of trees and payoff matrices for all players so that the best response policies for some of the players consist of an exponential number of segments.",
                "Moreover, in our example the breakpoint policies coincide with the best response policies, which means that even finding a single Nash equilibrium using the approach of [8, 9] is going to take exponentially long time.",
                "In fact, a stronger statement is true: for any polynomial-time two-pass algorithm (defined later) that works with subsets of best response policies for this graph, we can choose the payoffs of the vertices so that the downstream pass of this algorithm will fail.",
                "S 1 1 T S n−1 00 0000 11 1111 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 00 0000 11 1111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 11111111 11111111 1111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 n−1 n 2 n 1 n−12 n VVVVV 0 Figure 5: The tree Tn that corresponds to exponential-size <br>breakpoint policy</br>.",
                "In the rest of this subsection, we describe this construction.",
                "Consider the tree Tn given by Figure 5; let Vn be the root of this tree.",
                "For every k = 1, . . . , n, let the payoffs of Sk and Tk be the same as those for the U and V described in Section 3; recall that the breakpoint policies for U and V are shown in Figure 2.",
                "It is not hard to see that the indifference function for Tk is given by f(s) = .8s+.1.",
                "The payoff of V0 is 1 if V1 selects the same action as V0 and 0 otherwise; V0s best response policy is given by Figure 6.",
                "LEMMA 3.",
                "Fix k < n, and let u, t, v, and w denote the strategies of Vk−1, Tk, Vk, and Vk+1, respectively.",
                "Suppose that Vk prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. Then B(Vk+1, Vk) consists of at least 3k segments.",
                "Moreover, {(v, w) | (v, w) ∈ B(Vk+1, Vk), 0 ≤ w ≤ .2} = [0, .2]×{0} and {(v, w) | (v, w) ∈ B(Vk+1, Vk), .8 ≤ w ≤ 1} = [.8, 1]×{1}.",
                "PROOF.",
                "The proof proceeds by induction on k. For k = 0, the statement is obvious.",
                "Now, suppose it is true for B(Vk, Vk−1).",
                "One can view B(Vk+1, Vk) as a union of seven components: ˆf(0) ∩ [0, 1]×{0}, ˆf(1) ∩ [0, 1]×{1}, and five components that correspond to the segments of B(Vk, Tk).",
                "Let us examine them in turn.",
                "To describe ˆf(0)∩[0, 1]×{0}, note that f(u, t) = .5t+.1u+.2 is monotone in t and u and satisfies f(0, 0) = .2.",
                "Also, we have pbrVk−1 (0) = {0} and pbrTk (0) = {0}.",
                "For any w ∈ [0, 1] we have f(0, 0) ≥ w if and only if w ∈ [0, .2].",
                "We conclude that ˆf(0) ∩ [0, 1]×{0} = [0, .2]×{0}.",
                "Similarly, it follows that ˆf(1) ∩ [0, 1]×{1} = [.8, 1]×{1}.",
                "Define S1 = {(f(u, 0), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [0, .9]×[0, 1]}, S2 = {(f(u, .5), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, .9]×[0, 1]}, S3 = {(f(u, 1), v) | (v, u) ∈ B(Vk, Vk−1) ∩ [.1, 1]×[0, 1]}; these sets correspond to horizontal segments of B(Vk, Tk).",
                "It is easy to see that S1, S2, S3 ⊂ B(Vk+1, Vk).",
                "Since f is a continuous function, the number of segments in each Si is at least the number of segments in B(Vk, Vk−1)∩[.1, .9]×[0, 1], which is at least 3k−1 by induction hypothesis.",
                "Moreover, as f is monotone in u and f(1, 0) < f(0, .5) < f(1, .5) < f(0, 1), all Si, i = 1, 2, 3, are disjoint.",
                "Finally, the set B(Vk+1, Vk) contains two segments that correspond to the vertical segments of B(Vk, Tk), i.e., S4 = {(f(0, t), .1) | t ∈ [.5, 1]) = [.45, .7]×{.1} and S5 = {(f(1, t), .9) | t ∈ [0, .5]) = [.3, .55]×{.9}.",
                "Clearly, S4 connects S2 and S3, S5 connects S1 and S2, and S4 and S5 do not intersect each other.",
                "We conclude that B(Vk+1, Vk) 106 0 00 00 00 00 00 00 00 00 00 0 1 11 11 11 11 11 11 11 11 11 1 00000000001111111111 1 1 10.8 1 1 0.9 0.1 V V0.5 0.2 V V 21 10 Figure 6: Breakpoint policies for V0 and V1. is a continuous line that consist of at least 3k segments and satisfies the condition of the lemma.",
                "To complete the construction, we need to show that we can design the payoff matrix for Vk so that it prefers playing 0 to playing 1 if and only if .5t + .1u + .2 > w. To this end, we prove a more general statement, namely, that the indifference function of a vertex can be an arbitrary fractional multilinear function of its descendants strategies.",
                "We say that a function of k variables is multilinear if it can be represented as a sum of monomials and each of these monomials is linear in all of its variables.",
                "Note that this definition is different from a more standard one in that we do not require that all of the monomials have the same degree.",
                "Recall that the payoffs of a vertex with k + 1 neighbours are described by matrices P0 and P1 , where Pj i0i1...ik is the payoff that V gets when it plays j, and its neighbours play i0, . . . , ik, and j, i0, . . . , ik ∈ {0, 1}.",
                "Let P[j] = P[j](w, u1, . . . , uk) be the expected payoff obtained by this vertex when it plays j and the (mixed) strategies of its neighbours are given by a vector (w, u1, . . . , uk), i.e., P[j] = E[P j i0i1...ik ] where i0, . . . , ik are independent Bernoulli random variables, each of which is 1 with the respective probabilities w, u1, . . . , uk.",
                "LEMMA 4.",
                "Given a tree vertex V whose parent is W and whose children are U1, . . . , Uk, for any function f = f(u1, . . . , uk) that can be represented as a ratio of two multilinear functions f1, f2, i.e., f = f1(u1,...,uk) f2(u1,...,uk) , there exist payoff matrices P0 and P1 for V such that P[0] − P[1] = wf2(u1, . . . , uk) − f1(u1, . . . , uk).",
                "The proof of this lemma is based on the fact that every monomial of the form as(u0)s0 . . . (uk)sk , s1, . . . , sk ∈ {0, 1}, can be represented as t=t0...tk∈Σk+1 Ct(u0)t0 (1 − u0)1−t0 . . . (uk)tk (1 − uk)1−tk for some Ct, t ∈ {0, 1}k+1 .",
                "The details can be found in the full version of this paper [6]. 6.2 Irreducibility of the Best Response Policy for Tn While the best response policy constructed in the previous subsection has exponential size, it is not clear `a priori that it is necessary to keep track of all of its line segments rather than to focus on a small subset of these segments.",
                "However, it turns out that for two-pass algorithms such as the algorithm of [8], the best response policy cannot be simplified.",
                "More precisely, we say that an algorithm A is a two-pass algorithm if 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 11 1 1 1 1 11 1 1 1 1 11 1 1 1 1 0000000000000000000000000000011111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figure 7: <br>breakpoint policy</br> for V2. • A consists of an upstream pass and a downstream pass. • During the upstream pass, for each vertex V with parent W , A constructs a set BB(W, V ) ⊆ B(W, V ).",
                "This set is produced from the sets {BB(V, U) | U is a child of V } by applying the procedure from the beginning of Section 6 (substituting BB(V, Uj ) for B(V, Uj) for all children Uj of V ) , and then possibly omitting some of the points of the resulting set (which is then stored explicitly). • The downstream pass is identical to the downstream pass of [8] as described in Section 2 except that it operates on the sets BB(W, V ) rather than on the sets B(W, V ).",
                "Theorem 7 demonstrates that any two-pass algorithm will fail during the downstream pass on Tn if there is an index j such that the set BB(Vj+1, Vj) omits any interior point of any of the (at least 3j ) segments of B(Vj+1, Vj).",
                "This implies Theorem 3.",
                "THEOREM 7.",
                "For any two-pass algorithm A for which there exists an index j, j ∈ [1, n/4], a segment S of B(Vj , Vj−1), and an interior point (x, y) of S such that BB(Vj, Vj−1) does not contain (x, y), we can choose payoff matrices of the vertices Vj, . . . , Vn so that the downstream pass of A will fail, and, additionally, payoffs to V4j , . . . , Vn are identically 0.",
                "We sketch the proof of Theorem 7; the details can be found in the full version of this paper [6].",
                "We proceed by induction.",
                "For j = 1, the argument is similar to that in Section 3.",
                "For the inductive step, the main idea is that we can zoom in on any part of a best response policy (including the part that was omitted!) by using an appropriate indifference function; this allows us to reduce the case j = j0 to j = j0 − 1. 7.",
                "PPAD-COMPLETENESS OF BOUNDED PATHWIDTH GRAPHICAL GAMES In the previous section, we showed that for graphical games on trees that are almost but not quite paths, two-pass algorithms fail to find Nash equilibria in polynomial time.",
                "We next show that a milder path-like graph property allows us to construct graphical games for which it is unlikely that any polynomial-time algorithm will find Nash equilibria. 7.1 Pathwidth A path decomposition of a graph G = (V, E) is a sequence of subset Si(V ) ⊆ V such that for each edge (v, v ) ∈ E, v, v ∈ Si(V ) for some i, and furthermore, for each v ∈ V , if v ∈ Si(V ) and v ∈ Sj(V ) for j > i, then v ∈ Sk(V ) for all i ≤ k ≤ j.",
                "The path decomposition has width k if all sets Si(V ) have cardinality at most k + 1.",
                "The pathwidth of G is the minimum width of any path decomposition of G. 107 Pathwidth is a restriction of treewidth (in which one would seek a tree whose vertices were the sets Si(V ), and the sets containing some vertex would have to form a subtree).",
                "For any constant k it can be decided in polynomial time whether a graph has pathwidth (or treewidth) k. Furthermore many graph-theoretic problems seem easier to solve in polynomial time, when restricted to fixed treewidth, or pathwidth, graphs, see [1] for an overview.",
                "Note that a path has pathwidth 1 and a cycle has pathwidth 2. 7.2 PPAD-completeness We review some basic definitions from the computational complexity theory of search problems.",
                "A search problem associates any input (here, a graphical game) with a set of solutions (here, the Nash equilibria of the input game), where the description length of any solution should be polynomially bounded as a function of the description length of its input.",
                "In a total search problem, there is a guarantee that at least one solution exists for any input.",
                "Nashs theorem assures us that the problem of finding Nash equilibria is total.",
                "A reduction from search problem S to problem S is a mechanism that shows that any polynomial-time algorithm for S implies a polynomial-time algorithm for S. It consists of functions f and g, computable in polynomial time, where f maps inputs of S to inputs of S , and g maps solutions of S to solutions of S, in such a way that if IS is an input to S, and SS is a solution to f(IS), then g(SS ) is a solution to IS.",
                "Observe that total search problems do not allow the above reductions from problems such as CIRCUIT SAT (where the input is a boolean circuit, and solutions are input vectors that make the output true) due to the fact that CIRCUIT SAT and other NP-complete problems have inputs with empty solution sets.",
                "Instead, recent work on the computational complexity of finding a Nash equilibrium [7, 4, 5, 2, 3] has related it to the following problem.",
                "Definition 4.",
                "END OF THE LINE.",
                "Input: boolean circuits S and P, each having n input and n output bits, where P(0n ) = 0n and S(0n ) = 0n .",
                "Solution: x ∈ {0, 1}n such that S(x) = x, or alternatively x ∈ {0, 1}n such that P(S(x)) = x.",
                "S and P can be thought of as standing for successor and predecessor.",
                "Observe that by computing Si (0n ) (for i = 0, 1, 2, . . .) and comparing with P(Si+1 (0n )), we must eventually find a solution to END OF THE LINE.",
                "END OF THE LINE characterizes the complexity class PPAD (standing for parity argument on a graph, directed version), introduced in Papadimitriou [11], and any search problem S is PPAD-complete if END OF THE LINE reduces to S. Other PPAD-complete problems include the search for a ham sandwich hyperplane, and finding market equilibria in an exchange economy (see [11] for more detailed descriptions of these problems). 3-GRAPHICAL NASH is the problem of finding a Nash equilibrium for a graphical game whose graph has degree 3.",
                "Daskalakis et al. [4] show PPAD-completeness of 3-GRAPHICAL NASH by a reduction from 3-DIMENSIONAL BROUWER, introduced in [4] and defined as follows.",
                "Definition 5. 3-DIMENSIONAL BROUWER.",
                "Input: a circuit C having 3n input bits and 2 output bits.",
                "The input bits define a cubelet of the unit cube, consisting of the 3 coordinates of its points, given to n bits of precision.",
                "The output represents one of four colours assigned by C to a cubelet.",
                "C is restricted so as to assign colour 1 to cubelets adjacent to the (y, z)-plane, colour 2 to remaining cubelets adjacent to the (x, z)-plane, colour 3 to remaining cubelets on the (x, y)-plane, and colour 0 to all other cubelets on the surface of the unit cube.",
                "A solution is a panchromatic vertex, a vertex adjacent to cubelets that have 4 distinct colours.",
                "The reason why a solution is guaranteed to exist, is that an associated Brouwer function φ can be constructed, i.e. a continuous function from the unit cube to itself, such that panchromatic vertices correspond to fixpoints of φ. Brouwers Fixpoint Theorem promises the existence of a fixpoint.",
                "The proof of Theorem 4 uses a modification of the reduction of [4] from 3-DIMENSIONAL BROUWER to 3-GRAPHICAL NASH.",
                "To prove the theorem, we begin with some preliminary results as follows.",
                "Each player has 2 actions, denoted 0 and 1.",
                "For a player at vertex V let p[V ] denote the probability that the player plays 1.",
                "LEMMA 5. [7] There exists a graphical game Gshift of fixed size having vertices V , V where p[V ] is the fractional part of 2p[V ].",
                "COROLLARY 1.",
                "There exists a graphical game Gn−shift of size Θ(n) of constant pathwidth, having vertices V , Vn where p[Vn] is the fractional part of 2n .p[V ].",
                "PROOF.",
                "Make a chain of n copies of Gshift in Lemma 5.",
                "Each subset of vertices in the path decomposition is the vertices in a copy of Gshift.",
                "Let In(x) denote the n-th bit of the binary expansion of x, where we interpret 1 as true and 0 as false.",
                "The following uses gadgets from [7, 4].",
                "COROLLARY 2.",
                "There exists k such that for all n, and for all n1, n2, n3 ≤ n, there exists a graphical game of size O(n) with pathwidth k, having vertices V1, V2, V3 where p[V3] = p[V1] + 2−n3 (In1 p[V1] ∧ In2 p[V2]).",
                "PROOF OF THEOREM 4.",
                "Let C be the boolean circuit describing an instance of 3-DIMENSIONAL BROUWER.",
                "Let g1, . . . , gp(n) be the gates of C indexed in such a way that the input(s) to any gate are the output(s) of lower-indexed gates. g1, . . . , g3n will be the 3n inputs to C. All players in the graphical game G constructed in [4] have 2 actions denoted 0 and 1.",
                "The probability that V plays 1 is denoted p[V ].",
                "G has 3 players Vx, Vy and Vz for which p[Vx], p[Vy] and p[Vz] represent the coordinates of a point in the unit cube.",
                "G is designed to incentivize Vx, Vy and Vz to adjust their probabilities in directions given by a Brouwer function which is itself specified by the circuit C. In a Nash equilibrium, p[Vx], p[Vy] and p[Vz] represent coordinates of a fixpoint of a function that belongs to the class of functions represented by 3-DIMENSIONAL BROUWER.",
                "For 1 ≤ i ≤ p(n) we introduce a vertex V (i) C such that for 1 ≤ j ≤ i, Ij(p[V (i) C ]) is the output of gate gj; for i < j ≤ p(n), Ij(p[V (i) C ]) is 0.",
                "Construct V (i) C from V (i−1) C using Corollary 2.",
                "Let G(i) be the graphical game that does this.",
                "Let S1(G(i) ), . . . , Sn(G(i) ) be a length n path decomposition of G(i) , where V (i−1) C ∈ S1(G(i) ) and V (i) C ∈ Sn(G(i) ).",
                "Then, a path decomposition of ∪1≤i≤p(n)G(i) is obtained by taking the union of the separate path decompositions, together with Sn(G(i−1) ) ∪ S1(G(i) ) for 2 ≤ i ≤ p(n).",
                "Let GC be the above graphical game that simulates C. GC has 3n inputs, consisting of the first n bits of the binary expansions of p[Vx], p[Vy] and p[Vz].",
                "Similarly to [4], the output of GC affects Vx, Vy and Vz as follows.",
                "Colour 0 incentivizes Vx, Vy and Vz 108 to adjust their probabilities p[Vx], p[Vy] and p[Vz] in the direction (−1, −1, −1); colour 2 incentivizes them to move in direction (1, 0, 0); colour 2, direction (0, 1, 0); colour 3, direction (0, 0, 1).",
                "We need to ensure that at points at the boundaries of adjacent cubelets, the change of direction will be approximately the average of directions of surrounding points.",
                "That way, all four colors/directions must be nearby so that they can cancel each other out (and we are at a panchromatic vertex).",
                "This is achieved using the same trick as [4], in which we make a constant number M of copies of GC, which differ in that each copy adds a tiny displacement vector to its copies of p[Vx], p[Vy] and p[Vz] (which are derived from the original using the addition gadget of [7]).",
                "Using the addition and multiplication gadgets of [7] we average the directions and add a small multiple of this average to (p[Vx], p[Vy], p[Vz]).",
                "At a Nash equilibrium the outputs of each copy will cancel each other out.",
                "The pathwidth of the whole game is at most M times the pathwidth GC. 8.",
                "OPEN PROBLEMS The most important problem left open by this paper is whether it is possible to find a Nash equilibrium of a graphical game on a bounded-degree tree in polynomial time.",
                "Our construction shows that any two-pass algorithm that explicitly stores breakpoint policies needs exponential time and space.",
                "However, it does not preclude the existence of an algorithm that is based on a similar idea, but, instead of computing the entire <br>breakpoint policy</br> for each vertex, uses a small number of additional passes through the graph to decide which (polynomial-sized) parts of each <br>breakpoint policy</br> should be computed.",
                "In particular, such an algorithm may be based on the approximation algorithm of [8], where the value of is chosen adaptively.",
                "Another intriguing question is related to the fact that the graph for which we constructed an exponential-sized <br>breakpoint policy</br> has pathwidth 2, while our positive results are for a path, i.e., a graph of pathwidth 1.",
                "It is not clear if for any bounded-degree graph of pathwidth 1 the running time of (the breakpoint policybased version of) our algorithm will be polynomial.",
                "In particular, it is instructive to consider a caterpillar graph, i.e., the graph that can be obtained from Tn by deleting the vertices S1, . . . , Sn.",
                "For this graph, the best response policy of a vertex Vk in the spine of the caterpillar is obtained by combining the best response policy of its predecessor on the spine Vk−1 and its other child Tk; since the latter is a leaf, its best response policy is either trivial (i.e., [0, 1]2 , [0, 1]×{0}, or [0, 1]×{1}) or consists of two horizontal segments and one vertical segment of the form {α}×[0, 1] that connects them.",
                "Assuming for convenience that B(Vk, Tk) = [0, α]×{0} ∪ {α}×[0, 1] ∪ [α, 1]×{1}, and f is the indifference function for Vk, we observe that the best response policy for Vk consists of 5 components: ˆf(0), ˆf(1), and three components that correspond to [0, α]×{0}, {α}×[0, 1], and [α, 1]×{1}.",
                "Hence, one can think of constructing B(Vk+1, Vk) as the following process: turn B(Vk, Vk−1) by π/2, cut it along the (now horizontal) line vk = α, apply a fractional linear transform to the horizontal coordinate of both parts, and reconnect them using the image of the segment {α}×[0, 1] under f. This implies that the problem of bounding the size of the best response policy (or, alternatively, the <br>breakpoint policy</br>), can be viewed as a generalization of the following computational geometry problem, which we believe may be of independent interest: PROBLEM 1.",
                "Given a collection of axis-parallel segments in R2 , consider the following operation: pick an axis-parallel line li (either vertical or horizontal), cut the plane along this line, and shift one of the resulting two parts by an arbitrary amount δi; as a result, some segments will be split into two parts.",
                "Reconnect these parts, i.e., for each segment of the form [a, b] × {c} that was transformed into [a, t] × {c + δi} and [t, b] × {c}, introduce a segment {t}×[c, c+δi].",
                "Is it possible to start with the segment [0, 1] and after n operations obtain a set that cannot be represented as a union of poly(n) line segments?",
                "If yes, can it be the case that in this set, there is no path with a polynomial number of turns that connects the endpoints of the original segment?",
                "It turns out that in general, the answer to the first question is positive, i.e., after n steps, it is possible to obtain a set that consists of Θ(cn ) segments for some c > 0.",
                "This implies that even for a caterpillar, the best response policy can be exponentially large.",
                "However, in our example (which is omitted from this version of the paper due to space constraints), there exists a polynomial-size path through the best response policy, i.e., it does not prove that the <br>breakpoint policy</br> is necessarily exponential in size.",
                "If one can prove that this is always the case, it may be possible to adapt this proof to show that there can be an exponential gap between the sizes of best response policies and breakpoint policies. 9.",
                "REFERENCES [1] H. Bodlaender and T. Kloks.",
                "Efficient and constructive algorithms for the pathwidth and treewidth of graphs.",
                "Journal of Algorithms, 21:358-402, 1996. [2] X. Chen and X. Deng. 3-NASH is PPAD-complete.",
                "Technical Report TR-05-134, Electronic Colloquium in Computational Complexity, 2005. [3] X. Chen and X. Deng.",
                "Settling the complexity of 2-player Nash equilibrium.",
                "Technical Report TR-05-140, Electronic Colloquium in Computational Complexity, 2005. [4] C. Daskalakis, P. Goldberg, and C. Papadimitriou.",
                "The complexity of computing a Nash equilibrium.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [5] C. Daskalakis and C. Papadimitriou.",
                "Three-player games are hard.",
                "Technical Report TR-05-139, Electronic Colloquium in Computational Complexity, 2005. [6] E. Elkind, L. Goldberg, and P. Goldberg.",
                "Nash equilibria in graphical games on trees revisited.",
                "Technical Report TR-06-005, Electronic Colloquium in Computational Complexity, 2006. [7] P. Goldberg and C. Papadimitriou.",
                "Reducibility among equilibrium problems.",
                "In Proceedings of the 38th ACM Symposium on Theory of Computing, 2006. [8] M. Kearns, M. Littman, and S. Singh.",
                "Graphical models for game theory.",
                "In Proceedings of the 17th Conference on Uncertainty in Artificial Intelligence, 2001. [9] M. Littman, M. Kearns, and S. Singh.",
                "An efficient exact algorithm for singly connected graphical games.",
                "In Proceedings of the 15th Annual Conference on Neural Information Processing Systems, 2001. [10] L. Ortiz and M. Kearns.",
                "Nash propagation for loopy graphical games.",
                "In Proceedings of the 17th Annual Conference on Neural Information Processing Systems, 2003. [11] C. Papadimitriou.",
                "On the complexity of the parity argument and other inefficient proofs of existence.",
                "J. Comput.",
                "Syst.",
                "Sci., 48(3):498-532, 1994. 109"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "La idea principal de [9] es que no es necesario realizar un seguimiento de todos los rectángulos en las mejores políticas de respuesta;Más bien, en cada paso del pase ascendente, es posible seleccionar un subconjunto de tamaño polinomial de la política correspondiente (en [9], este subconjunto se denomina \"política de punto de ruptura\"), y aún así asegurarse de que el pase posterior pueda procedercon éxito (una condición suficiente para esto es que el subconjunto de la mejor política de respuesta para V almacenada por el algoritmo contiene una ruta continua de W = 0 a W = 1).1.2 Nuestros resultados Una de las principales contribuciones de nuestro artículo es mostrar que el algoritmo propuesto por [9] es incorrecto.",
                "Esto se puede lograr si, al comienzo del pase aguas abajo, tenemos una estructura de datos en la que cada vértice V con el padre se almacena un conjunto ˆb (W, V) ⊆ B (W, V) (llamada \"Política de punto de interrupción\") que cubre todos los posibles w ∈ [0, 1].",
                "En [9], se sugiere que podamos seleccionar la \"política de punto de interrupción\" de una manera particular.",
                "A saber, el documento usa la siguiente definición: Definición 2. (cf. [9]) Una \"política de punto de ruptura\" para un nodo V con el padre w consiste en un conjunto ordenado de w -breakpoints w0 = 0 <w1 <w2 <· · ·· <Wt -1 <wt = 1 y un conjunto asociado de valores V v1 ,..., Vt.",
                "Decimos que tal \"política de punto de ruptura\" tiene puntos de interrupción T - 1.",
                "Luego, el documento afirma que cualquier vértice V puede calcular su \"política de punto de ruptura\" con respecto a su padre W dadas las políticas de punto de interrupción de sus hijos U1 ,..., Reino Unido.",
                "Luego, los autores afirman que cualquier cobertura de este tipo puede transformarse en una \"política de punto de ruptura\" para V.",
                "La ruta conectada gruesa es la \"política de punto de ruptura\" correspondiente.",
                "La mejor política de respuesta para U es una \"política de punto de ruptura\" para U (como en la definición 2) con V -breakpoints v0 = 0, v1 = 1/2 y v2 = 1 con valores asociados U1 = 1 y U2 = 0.",
                "La mejor política de respuesta para V no es una \"política de punto de ruptura\" (debido a cómo la curva de W = 0 a W = 1 se duplica).",
                "El algoritmo LKS se recortaría para obtener una \"política de punto de ruptura\" como la de la Figura 3.",
                "Tenga en cuenta que esta \"política de punto de interrupción\" ˆB (W, V) no es válido en el sentido de que no satisface ˆB (W, V) ⊆ B (W, V).102 1 10.5 0.5 1 10.1 0.9 U V V W Figura 2: Mejores políticas de respuesta para U y V.0.1 0.9 1 0.5 1 V W Figura 3: Una política recortada para V El punto es que la matriz de pago de W ahora se puede elegir para evitar que el algoritmo LKS encuentre un equilibrio de Nash.",
                "Por ejemplo, suponga que la \"política de punto de interrupción\" para V tiene V = 0 hasta algún punto w ∗ <.9 y luego salta a v = 1.",
                "Para el algoritmo modificado, tenemos que extender la definición de \"política de punto de ruptura\" (ver definición 3) para que incluya políticas de punto de ruptura, como la mejor política de respuesta para V en la Figura 2.",
                "Desafortunadamente, dicha \"política de punto de ruptura\" puede ser de tamaño exponencial (ver Figura 7), por lo que el algoritmo corregido no se ejecuta en tiempo polinomial en todos los árboles.",
                "Si bien no siempre es posible construir una \"política de punto de ruptura\" como se define en [9], mostramos cómo modificar esta definición para garantizar que siempre exista una \"política de punto de ruptura\";Además, demostramos que para un gráfico de ruta, la política de punto de interrupción de cualquier vértice se puede almacenar en una estructura de datos cuyo tamaño es lineal en el número de descendientes que tiene este vértice.",
                "Una \"Política de punto de interrupción\" ˆB (V, U) para un vértice U cuyo padre es V es una curva no interna de la forma X1 ∪ y1 ∪ · · · ∪ ym-1 xm, donde xi = [vi--1, vi] × {ui}, yi = {vi} × [ui, ui+1] y ui, vi ∈ [0, 1] para i = 0 ,..., m.Decimos que una \"política de punto de ruptura\" es válida si v0 = 0, vm = 1 y ˆb (v, u) ⊆ b (v, u).",
                "Observe que cualquier \"política de punto de ruptura\" válida ˆB (V, U) puede verse como un mapeo 1-1 continuo γ (t) = (γv (t), γu (t)), γ: [0, 1] → [[0, 1] 2, donde γ (0) = (0, u1), γ (1) = (1, um) y existen algunos t0 = 0, t1 ,..., t2m - 2 = 1 tal que {γ (t) |t2k ≤ t ≤ t2k+1} = xk+1, {γ (t) |t2k+1 ≤ t ≤ t2k+2} = yk+1.",
                "Como se explica en la Sección 3, podemos usar una \"política de punto de interrupción\" válida en lugar de la mejor política de respuesta durante el pase posterior, y aún así garantizar que al final, generaremos un equilibrio de Nash.",
                "Para cualquier V = VJ, uno puede encontrar en el tiempo polinomial una \"Política de punto de interrupción\" válida ˆB (W, V) que consiste en como máximo segmentos 2J + 1.5.",
                "Encontrar equilibrios en un árbol (arbitrario) para árboles arbitrarios, la estructura general del algoritmo sigue siendo el mismo, es decir, se puede construir una mejor política de respuesta (o, alternativamente, una \"política de punto de ruptura\") para cualquier vértice basado en la mejor respuestaPolíticas de sus hijos.",
                "Como en la sección anterior, podemos mostrar que B (W, V) es igual a ˆf (0) ∪ ˆf (B (V, U1) × · · · × B (V, Reino Unido)) ∪ ˆf (1) [0, 1] 2;Además, cualquier ruta de W = 0 a W = 1 que sea un subconjunto de B (W, V) constituye una \"política de punto de ruptura\" válida.6.1 Tamaño exponencial \"Política de punto de ruptura\" Si bien el algoritmo de la Sección 4 puede generalizarse para árboles limitados, su tiempo de ejecución ya no es polinomio.",
                "S 1 1 T S N - 1 00 0000 11 1111 00 0000 11 1111 0000 0000 11 1111 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0 00 1 11 0000 111111 00 0000 11 1111 0 00 1 11 0000 00000000 00000000 0000 1111 1111111111111111111111 000 000000 000000 000 111 111111 111111 111 S S T T T 2 N - 1 N 2 N 1 N - 12 N-Size \"Política de punto de interrupción\".",
                "Más precisamente, decimos que un algoritmo A es un algoritmo de dos pasos si 0 0 0 0 00 0 0 0 0 0 00 0 0 0 0 00 0 0 0 0 1 1 1 1 11 1 1 1 11 1 1 1 11 1 1 1 1 1 1 1 11 1 0000000000000000000000000000000111111111111111111111111111111 0.2 0.8 0.9 1 0.1 1 V V 2 3 S 1 S S S S 1 T 0 T 2 3 4 5 Figura 7: \"Política de punto de interrupción\" para V2.• A consiste en un pase aguas arriba y un pase aguas abajo.• Durante el pase ascendente, para cada vértice V con el padre W, A construye un conjunto BB (W, V) ⊆ B (W, V).",
                "Sin embargo, no excluye la existencia de un algoritmo que se basa en una idea similar, pero, en lugar de calcular toda la \"política de punto de interrupción\" para cada vértice, utiliza un pequeño número de pases adicionales a través del gráfico para decidir qué (polinomial-dimensionamiento) Se deben calcular partes de cada \"política de punto de interrupción\".",
                "Otra pregunta intrigante está relacionada con el hecho de que el gráfico para el que construimos una \"política de punto de ruptura\" de tamaño exponencial tiene el ancho de ruta 2, mientras que nuestros resultados positivos son para una ruta, es decir, un gráfico de vía de ruta 1.",
                "Por lo tanto, se puede pensar en construir B (VK+1, VK) como el siguiente proceso: Turn B (VK, VK - 1) por π/2, córtelo a lo largo de la línea (ahora horizontal) VK = α, aplique una fraccionadaTransformación lineal a la coordenada horizontal de ambas partes y vuelva a conectarlas usando la imagen del segmento {α} × [0, 1] bajo f.Esto implica que el problema de limitar el tamaño de la mejor política de respuesta (o, alternativamente, la \"política de punto de ruptura\"), puede verse como una generalización del siguiente problema de geometría computacional, que creemos que puede ser de interés independiente: Problema 1.",
                "Sin embargo, en nuestro ejemplo (que se omite a partir de esta versión del documento debido a limitaciones de espacio), existe una ruta de tamaño polinomial a través de la mejor política de respuesta, es decir, no prueba que la \"política de punto de ruptura\" sea necesariamente exponencial entamaño."
            ],
            "translated_text": "",
            "candidates": [
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de ruptura",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de interrupción",
                "política de punto de interrupción",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura",
                "Política de punto de interrupción",
                "política de punto de ruptura"
            ],
            "error": []
        }
    }
}