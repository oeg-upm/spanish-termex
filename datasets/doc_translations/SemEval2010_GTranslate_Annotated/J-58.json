{
    "id": "J-58",
    "original_text": "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept. of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design. However, VCG mechanisms have their limitations. They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function. For many optimization problems, finding the optimal output is computationally intractable. If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful. In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O. In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to. For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property. We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output. In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames. Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1. INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable. The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation. However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents. Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines. The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations. Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP. Some mechanisms other than VCG mechanism are needed to address these issues. Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output. They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem. Auletta et al. [3] studied a similar scheduling problem. They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem. Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods. They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism. The work of Mualem and Nisan [13] is the closest in spirit to our work. They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting. They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems. As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions. More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected. We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type. Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately. In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function. In fact, we do not even require the existence of an objective function. Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property. The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful. We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems. The remainder of the paper is organized as follows. In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games. In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P). A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O. In Section 5, we provide several examples to demonstrate the effectiveness of our general framework. We conclude our paper in Section 6 with some possible future directions. 2. PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain. A standard model for mechanism design is as follows. There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself. For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction. The agents types define the type vector t = (t1, t2, . . . , tn). Each agent i has a set of strategies Ai from which it can choose. For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)). Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents. A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies. For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node. Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O. A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o. Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i. Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti. Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a). Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai. Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i. Sometimes, we write (a−i, bi) as a|i bi. An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i. A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism. An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility. Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti). Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating. A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties. Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11]. The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite. A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i. Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10]. The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function. This makes the mechanism computationally intractable in many cases. Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used. In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n . In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected. Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13]. Hereafter, we make the following further assumptions. 1. The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2. The valuation v(ti, oi) is a publicly known value and is normalized to 0. This assumption is needed to guarantee the IR property. Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative. For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service. Throughout this paper, we will use ci instead of vi in our analysis. All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction. In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game. The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1. The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2. The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function. We even do not require the existence of an objective function. 3. We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism. In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction. In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci. A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ . In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness. Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme. For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0. Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game. Their payment scheme inspired our payment scheme for binary demand game. In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si. They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction. As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability. On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules. In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load. The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load. Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems. Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game. If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output. But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games. The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work. They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12]. They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value. With a simple generalization, we get our conclusion for general binary demand game. They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search. All of their methods required the welfare function associated with the output satisfying bitonic property. Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property. Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction. In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function. Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3. GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful. THEOREM 1. If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ). COROLLARY 2. For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0. THEOREM 3. Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC. The proofs of above theorems are straightforward and thus omitted due to space limit. This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected. Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O. Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)). An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ). This definition is not restricted only to binary demand games. For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1. THEOREM 4. Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1. There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i). When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2. The allocation rule O satisfies MP. 3. There exists a truthful payment scheme P for this binary demand game. PROOF. The proof that Condition 2 implies Condition is straightforward and is omitted here. We then show Condition 3 implies Condition 2. The proof of this is similar to a proof in [13]. To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0. From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i . Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i . When agent i lies its valuation to ci2 , its utility is p1 i − ci1 . Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 . Now consider the scenario when the actual valuation of agent i is ci = ci2 . Its utility is p1 i − ci2 when it reports its true valuation. Similarly, if it lies its valuation to ci1 , its utility is p0 i . Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 . Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 . This inequality implies that ci1 > ci2 , which is a contradiction. We then show Condition 1 implies Condition 3. We prove this by constructing a payment scheme and proving that this payment scheme is truthful. The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0. From condition 1, if Oi(c) = 1 then ci > κi(O, c−i). Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR. In the following we prove that this payment scheme also satisfies IC property. There are two cases here. Case 1: ci < κ(O, c−i). In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0. Now consider the situation when i declares a cost di = ci. If di < κi(O, c−i), then i gets the same payment and utility since it is still selected. If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore. Thus, it has no incentive to lie in this case. Case 2: ci ≥ κ(O, c−i). In this case, when i reveals its true valuation, its payment is 0 and the utility is 0. Now consider the situation when i declares a valuation di = ci. If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected. If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now. Thus, it has no incentive to lie. The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games. The details are omitted here due to space limit. We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O. General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP. If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful. Otherwise, define the payment scheme P as follows. Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i). Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1. THEOREM 5. The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4. COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2. Notice that binary search does not work generally since the valuations of agents may be continuous. We give some general techniques that can help with finding the cut value function under certain circumstances. Our basic approach is as follows. First, we decompose the allocation rule into several allocation rules. Next find the cut value function for each of these new allocation rules. Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions. For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)). Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed. THEOREM 6. With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi . Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property. Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c). PROOF. Assume that ci > ci and Oi(c) = 1. Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1. Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1. This proves that O(c) satisfies MP. The correctness of the cut value function follows directly from Theorem 4. Many algorithms indeed fall into this category. To demonstrate the usefulness of Theorem 6, we discuss a concrete example here. In a network, sometimes we want to deliver a packet to a set of nodes instead of one. This problem is known as multicast. The most commonly used structure in multicast routing is so called shortest path tree (SPT). Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data. Assume that the source node is s and the receivers are Q ⊂ V . For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree. We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P). Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization. We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d). Then the output SPT is defined as W qi∈Q LCP(s,qi) . In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d). The shortest path allocation rule is a utilitarian and satisfies MP. Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c). Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT. THEOREM 7. Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP. Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}. We show that our simple combination generalizes the IF-THENELSE function defined in [13]. For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP. Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively. Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions. By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary. For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category. As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output. Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V . Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0. For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci. We want to find a vertex cover with the minimum weight. Hence, the objective function to be implemented is utilitarian. To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16]. Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules. Many algorithms have been proposed in the literature to approximate the optimal solution. In this paper, we use a 2-approximation algorithm given in [16]. For the sake of completeness, we briefly review this algorithm here. The algorithm is round-based. Each round selects some vertices and discards some vertices. For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover. To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2). Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c). Output: A vertex cover V . 1: Set V = ∅. For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V . If w(j) = 0, add j to V . Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property. Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum. For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario. Typically, a round-based output can be characterized as follows (Algorithm 3). DEFINITION 2. An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 . We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8. A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent. PROOF. Consider an agent i and fixed c−i. We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci. Assume that i is selected in round r with cost ci. Then under cost di, if agent i is selected in a round before r, our claim holds. Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property. Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP. This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n . Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively. Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function. For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1. Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ). Here we updates the cost and setting of the game. Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output. For the example of vertex cover, it is the union of nodes selected in all rounds. Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U. Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ. Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k. Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value. If the round-based output satisfies monotonicity property, the cut-value always exists. We then show how to find the cut value for a selected agent k in Algorithm 4. The correctness of Algorithm 4 is straightforward. To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given. Now we consider the vertex cover problem. For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge. The output satisfies MP. For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected. It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5. Algorithm 5 Compute Cut Value for MVC. Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2. Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG). However, some algorithms cannot be decomposed in the way described in subsection 4.1. Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated. Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm). Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm). For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)). Let us see a concrete example of these combinations. Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V . The Steiner tree problem is to find a set of links with minimum total cost to connect Q. One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H). In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c). The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST. More details will be given in Section 5.2. DEFINITION 3. Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)). The allocation rule of the above definition can be interpreted as follows. An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c). For simplicity, we will use O ◦ F to denote the output of this compound binary demand game. Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property. To study when O ◦F satisfies MP, several necessary definitions are in order. DEFINITION 4. Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1. When Oi(c) = 0, H(c) does not increase over ci. 2. When Oi(c) = 1, H(c) does not decrease over ci. DEFINITION 5. Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0. LEMMA 1. For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1. From the definition of the strong monotonicity property, we have Lemma 1 directly. We now can give a sufficient condition when O ◦ F satisfies the monotonicity property. THEOREM 9. If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP. PROOF. Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1. Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c). There are two scenarios, which will be studied one by one as follows. One scenario is that index k is not chosen by the output function O. From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1. If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci. Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1). Consequently, we have ψj i (c ) = 1. From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1. The other scenario is that index k is chosen by the output function O. First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1. Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c). Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c). Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof. This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output. Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1. Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property. When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y. For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent. In this paper, we assume that given any y, we can find such x in polynomial time. Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i. Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j. THEOREM 10. Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF. In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases. For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused. First, if di < κi then (O ◦ F)i(c|i di) = 1. Without loss of generality, we assume that κi = κi,j for some j. Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi). Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected. Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1. Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk. Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞). In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0. Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1. Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1. Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1. This implies that Fj(c|i di) < τj. Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}. This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction. This finishes our proof. In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian. Thus, we can compute the inverse of F−1 j efficiently. Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive. However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13]. Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare. If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP. From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP. Further, the cut value of the MAX combination can be found by Algorithm 6. As we will show in Section 5, the complex combination can apply to some more complicated problems. 5. CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci. Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn). We want to find a subset of agents D such that U ⊆ S i∈D Si. The selected subsets is called the set cover for U. The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized. Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost. It is well-known that finding the optimal solution is NP-hard. In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem. For the completeness of presentation, we review their method here. Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n). Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge. Here, we consider a more general case in which the type of an agent is (Si, ci). In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si. This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint. We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful. Obviously, the set cover problem is a binary demand game. For the moment, we assume that agent i wont be able to lie about Si. We will drop this assumption later. We show how to design a truthful mechanism by applying our general framework. 1. Check the monotonicity property: The output of Algorithm 7 is a round-based output. Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents. Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents. Consequently, agent i is still selected in round r, which means the output of round r satisfies MP. Now we look into the updating rules. For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent. Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2. Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4. First, we set ci = ∞ and apply Algorithm 7. Let ir be the agent selected in round r and T−i r+1 be the corresponding set. Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |. Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0. We now consider the scenario when agent i can lie about Si. Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si. We argue that agent i will not lie about its elements Si. Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |. Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si. Thus, lying its set as Si will not increase the cut value for each round. Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei. The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V . For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents. The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H). It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20]. The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17]. Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20]. Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q. Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0. The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned. Hereafter, let LST(G) be the final tree constructed using the above method. It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism. We then show how to design a truthful payment scheme using our general framework. Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence. Thus, from Theorem 8, the roundbased output LST satisfies MP. In round r, the cut value for a link ei can be obtained by using the VCG mechanism. Now we set ci = ∞ and execute Algorithm 8. Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞. Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi. Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}. Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used. Assume that Q is the set of receivers, including the sender. Assume that the nodes in a node-weighted graph are all agents. The virtual minimum spanning tree is constructed as follows. Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected. The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism. We then show how to design a truthful mechanism based on the framework we described. 1. Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|. In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|. We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP. From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2. Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST. Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T). Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP. Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|. Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞). Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector. Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST. It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|. Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|. The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3. We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction. In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi. A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ . Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅. Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows. First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids. The first bid is granted. Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted. If it does, it is denied. They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai. It is easy to verify the output of the greedy algorithm is a round-based output. Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after. This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence. In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai. Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all. Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i. Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise. This payment scheme is exactly the same as the payment scheme in [12]. 6. CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game. We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist. We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time. We further presented several general composition-based techniques to compute P efficiently for various allocation rules O. Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time. In this paper, we have concentrated on how to compute P in polynomial time. Our algorithms do not necessarily have the optimal running time for computing P given O. It would be of interest to design algorithms to compute P in optimal time. We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time. Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game. Many works [12, 13] in the mechanism design literature are in this direction. We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given. It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme. In this paper, we have studied mechanism design for binary demand games. However, some problems cannot be directly formulated as binary demand games. The job scheduling problem in [2] is such an example. For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner. It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games. Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ . The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist. Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7. REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents. In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents. In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem. Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods. Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra. On Dominant Strategy Mechanisms. Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games. In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract). In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing. In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J. Characterization of satisfactory mechanisms for the revelation of preferences for public goods. Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams. Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y. Truth revelation in approximately efficient combinatorial auctions. Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract. In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design. In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin. Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs. In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even. A local ratio theorem for approximating the weighted vertex cover problem. Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985. Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A. Improved steiner tree approximation in graphs. In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky. An 11/6-approximation algorithm for the network Steiner problem. Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum. Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A. An approximate solution for the steiner problem in graphs. Math. Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders. Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y. Truthful low-cost unicast in selfish wireless networks. In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z. Design multicast protocols for non-cooperative networks. IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks. ACM MobiCom, 2005. 222",
    "original_translation": "Hacia los mecanismos veraces para los juegos de demanda binaria: un marco general Ming-yang Kao ∗ Departamento. de informática Northwestern University Evanston, IL, EE. UU. kao@cs.northwestern.edu xiang-yang li † Departamento de informática Illinois Instituto de Tecnología Chicago, IL, EE. UU. Xli@cs.iit.edu Weizhao Wang Dept. de Computer Science de ComputerInstituto de Tecnología de Illinois Chicago, IL, EE. UU. Wangwei4@iit.edu Resumen La familia de los mecanismos de Vickrey-Clarke-Groves (VCG) es posiblemente el logro más famoso en el diseño del mecanismo veraz. Sin embargo, los mecanismos de VCG tienen sus limitaciones. Solo se aplican a los problemas de optimización con una función objetivo utilitaria (o afina), y su salida debe optimizar la función objetivo. Para muchos problemas de optimización, encontrar la salida óptima es computacionalmente intratable. Si aplicamos mecanismos de VCG a algoritmos de tiempo polinomial que se aproximan a la solución óptima, los mecanismos resultantes ya no pueden ser sinceros. A la luz de estas limitaciones, es útil estudiar si podemos diseñar un esquema de pago sin VCG que sea computacionalmente manejable para una regla de asignación dada O. En este documento, centramos nuestra atención en los juegos de demanda binaria en los que los agentes solo las acciones disponibles deben participar en el juego A o no. Para estos problemas, demostramos que un mecanismo veraz M = (O, P) existe con un método de pago adecuado sobre la regla de asignación o satisface una cierta propiedad de monotonicidad. Proporcionamos un marco general para diseñar dicho P. Proponemos además varias técnicas generales basadas en composición para calcular P de manera eficiente para varios tipos de salida. En particular, mostramos cómo P se puede calcular a través de/y combinaciones, combinaciones basadas en la ronda y algunas combinaciones más complejas de las salidas de los subjuegos. Categorías y descriptores de sujetos F.2 [Análisis de algoritmos y complejidad del problema]: general;J.4 [Ciencias sociales y conductuales]: Economía;K.4.4 [Computer and Society]: Algoritmos de términos generales de comercio electrónico, Economía, Teoría 1. Introducción En los últimos años, con el rápido desarrollo de Internet, se han propuesto muchos protocolos y algoritmos para que Internet sea más eficiente y confiable. Internet es un sistema distribuido complejo donde una multitud de agentes heterogéneos cooperan para lograr algunos objetivos comunes, y los protocolos y algoritmos existentes a menudo asumen que todos los agentes seguirán las reglas prescritas sin desviación. Sin embargo, en algunos entornos en los que los agentes son egoístas en lugar de altruistas, es más razonable suponer que estos agentes son racionales, maximizan sus propias ganancias, según la economía neoclásica, y se necesitan nuevos modelos para hacer frente al comportamiento egoísta de tales agentes. Con este fin, Nisan y Ronen [14] propusieron el marco del diseño del mecanismo algorítmico y los mecanismos de VCG aplicados a algunos problemas fundamentales en la informática, incluidas las rutas más cortas, los árboles mínimos y la programación en máquinas no relacionadas. Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño del mecanismo cuyas salidas optimizan la función objetivo utilitaria, que es simplemente la suma de las valoraciones de todos los agentes. Desafortunadamente, algunas funciones objetivas no son utilitarias;Incluso para esos problemas con una función objetivo utilitaria, a veces es imposible encontrar el resultado óptimo en el tiempo polinomial a menos que p = NP. Se necesitan algunos mecanismos distintos del mecanismo VCG para abordar estos problemas. Archer y Tardos [2] estudiaron un problema de programación en el que es difícil encontrar la salida óptima. Señalaron que una determinada propiedad de monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación. Auletta et al.[3] estudió un problema de programación similar. Proporcionaron una familia de mecanismos deterministas de Aprolitación (2 +) para cualquier número fijo de máquinas y varios mecanismos influyentes (1 +) para algunas restricciones difíciles de su problema de programación. Lehmann et al.[12] estudiaron la subasta combinatoria determinada y dio un mecanismo veraz de la acroximación m, donde M es el número de bienes. También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un mecanismo veraz. El trabajo de Mualem y Nisan [13] es el espíritu más cercano a nuestro trabajo. Caracterizaron todos los mecanismos veraces basados en una determinada propiedad de monotonicidad en un entorno de subasta decidida. También mostraron cómo usar Max e If-Then-else para combinar salidas de subproblemas. Como se muestra en este documento, las combinaciones MAX e IF-Then-ELSE son casos especiales de las técnicas basadas en la composición que presentamos en este documento para calcular los pagos en el tiempo polinomial bajo supuestos leves. En términos más generales, estudiamos cómo diseñar mecanismos veraces para los juegos de demanda binaria donde la asignación de un agente es seleccionada o no seleccionada. También suponemos que las valoraciones 213 de los agentes no están correlacionadas, es decir, la valoración de un agente solo depende de su propia asignación y tipo. Recuerde que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un esquema de pago P. Anteriormente, a menudo se supone que existe una función objetivo G y una regla de asignación O, que optimiza exactamenteo aproximadamente. A diferencia de los mecanismos de VCG, no requerimos que la asignación sea optimizar la función objetivo. De hecho, ni siquiera requerimos la existencia de una función objetivo. Dada cualquier regla de asignación o para un juego de demanda binaria, demostramos que existe un mecanismo veraz M = (O, P) para el juego si y solo si o satisface una determinada propiedad de monotonicidad. La propiedad de la monotonicidad solo garantiza la existencia de un esquema de pago P tal que (O, P) es sincero. Complementamos este teorema de existencia con un marco general para diseñar dicho esquema de pago P. Además, presentamos técnicas generales para calcular el pago cuando la salida es una composición de las salidas de subgamas a través de los operadores o y y;a través de combinaciones basadas en la ronda;o a través de resultados intermedios, que pueden calcularse a partir de otros subproblemas. El resto del documento se organiza de la siguiente manera. En la Sección 2, discutimos preliminares y trabajos anteriores, definimos juegos de demanda binaria y discutimos los supuestos básicos sobre los juegos de demanda binaria. En la Sección 3, mostramos que satisfacer una determinada propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P). Luego se propone un marco en la Sección 4 para calcular el pago P en tiempo polinomial para varios tipos de reglas de asignación O. En la Sección 5, proporcionamos varios ejemplos para demostrar la efectividad de nuestro marco general. Concluimos nuestro documento en la Sección 6 con algunas posibles direcciones futuras.2. Preliminares 2.1 Diseño del mecanismo Como generalmente se hace en la literatura sobre el diseño de algoritmos o protocolos con aportes de agentes individuales, adoptamos la suposición en la economía neoclásica de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y se desviaremos de losProtocolo solo si la desviación mejora su ganancia. Un modelo estándar para el diseño del mecanismo es el siguiente. Hay n agentes 1 ,..., n y cada agente I tiene cierta información privada Ti, llamada su tipo, solo conocido por sí mismo. Por ejemplo, el tipo TI puede ser el costo en el que incurre en el agente en el que estoy para reenviar un paquete en una red o puede ser un pago que el agente está dispuesto a pagar por un bien en una subasta. Los tipos de agentes definen el vector tipo t = (T1, T2, ..., Tn). Cada agente I tiene un conjunto de estrategias de la que puede elegir. Para cada vector de entrada a = (a1, ..., un) donde el agente i reproduce estrategia ai ∈ Ai, el mecanismo m = (o, p) calcula una salida o = o (a) y un vector de pago p (a)= (p1 (a), ..., pn (a)). Aquí el pago PI (·) es el dinero otorgado al Agente I y depende de las estrategias utilizadas por los agentes. Un juego se define como G = (S, M), donde S es la configuración del juego G. Aquí, S consiste en los parámetros del juego que se establecen antes de que comience el juego y no depende de las estrategias de los jugadores. Por ejemplo, en un juego de enrutamiento de unidifusión [14], la configuración consta de la topología de la red, el nodo de origen y el nodo de destino. A lo largo de este documento, a menos que se mencione explícitamente lo contrario, la configuración del juego es fija y solo estamos interesados en cómo diseñar P para una regla de asignación dada O. Una función de valoración v (Ti, O) asigna una cantidad monetaria al agente I para cada posible salida o. Todo sobre un juego S, M, incluida la configuración S, la Regla de Asignación O y el Esquema de Pago P, es el conocimiento público, excepto que el agente es el tipo real Ti, que es información privada para el agente i. Deje que UI (Ti, O) denote la utilidad del Agente I en el resultado del Juego O, dadas sus preferencias TI. Aquí, después de una suposición común en la literatura, asumimos que la utilidad para el agente I es cuasi-lineal, es decir, ui (ti, o) = v (ti, o) + pi (a). Deje a | i ai = (a1, · · ·, ai - 1, ai, ai+1, · · ·, an), es decir, cada agente j = yo reproduce una acción AJ excepto que el agente que toca ai. Deje a - i = (a1, · · ·, ai - 1, ai+1, · · ·, an) denota las acciones de todos los agentes excepto i. A veces, escribimos (a - i, bi) como un | i bi. Una acción ai se llama dominante para i si (débilmente) maximiza la utilidad de I para todas las estrategias posibles b - i de otros agentes, es decir, ui (ti, o (b - i, ai)) ≥ ui (ti, o(b - i, ai)) para todos ai = ai y b - i. Un mecanismo de revelación directa es un mecanismo en el que las únicas acciones disponibles para cada agente son informar su tipo privado, ya sea con sinceridad o falsamente, al mecanismo. Un mecanismo de incentivo compatible (IC) es un mecanismo de revelación directa en el que si un agente informa su tipo TI con sinceridad, entonces maximizará su utilidad. Luego, en un mecanismo de revelación directa que satisface el IC, el esquema de pago debe satisfacer la propiedad que, para cada agente i, v (ti, o (t)) + pi (t) ≥ v (ti, o (t | i tii)) + pi (t | i ti). Otro requisito común en la literatura para el diseño del mecanismo es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar. Un mecanismo de revelación directa es a prueba de estrategias si satisface las propiedades de IC e IR. Podría decirse que el resultado positivo más importante en el diseño del mecanismo es el mecanismo generalizado de Vickrey-Clarke (VCG) por Vickrey [21], Clarke [5] y Groves [11]. El mecanismo VCG se aplica a los problemas de maximización (afinos) donde la función objetivo es utilitaria g (o, t) = p i v (ti, o) (es decir, la suma de las valoraciones de todos los agentes) y se supone que el conjunto de salidas posiblesfinito. Un mecanismo de revelación directo m = (o (t), p (t)) pertenece a la familia VCG si (1) la asignación o (t) maximizesp i v (ti, o) y (2) el pago al agente i esPi (t) = p j = i vj (tj, o (t))+ hi (t - i), donde hi () es una función arbitraria de t - i. Bajo suposiciones leves, los mecanismos de VCG son las únicas implementaciones veraces para problemas utilitarios [10]. Se requiere la regla de asignación de un mecanismo VCG para maximizar la función objetivo en el rango de la función de asignación. Esto hace que el mecanismo sea computacionalmente intratable en muchos casos. Además, reemplazar un algoritmo óptimo para calcular la salida con un algoritmo de aproximación generalmente conduce a mecanismos falsos si se usa un esquema de pago VCG. En este artículo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetivo utilitaria.2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n. En otras palabras, la salida es un vector n-tuple o (t) = (o1 (t), o2 (t), ..., on (t)), donde oi (t) = 1 (respectivamente, 0)significa que el agente I está (respectivamente, no está) seleccionado. Ejemplos de juegos de demanda binaria incluyen: Unicast [14, 22, 9] y multidifusión [23, 24, 8] (generalmente subcraft construcción seleccionando algunos enlaces/nodos para satisfacer algunas propiedades), ubicación de la instalación [7] y una determinada subasta[12, 2, 13]. En adelante, hacemos los siguientes supuestos adicionales.1. La valoración de los agentes no está correlacionada, es decir, V (Ti, O) es una función de V (Ti, Oi) solo se denota como V (Ti, Oi).2. La valoración v (ti, oi) es un valor públicamente conocido y se normaliza a 0. Esta suposición es necesaria para garantizar la propiedad IR. Por lo tanto, a lo largo de su artículo, solo consideramos estos mecanismos de revelación directa en los que cada agente solo necesita revelar su valoración VI = V (TI, 1).214 Observe que en las solicitudes donde los agentes que brindan servicio y reciben el pago, por ejemplo, la programación de unidifusión y trabajo, la valoración VI de un agente I suele ser negativo. Para la conveniencia de la presentación, definimos el costo del agente como CI = −v (Ti, 1), es decir, cuesta al agente I CI proporcionar el servicio. A lo largo de este artículo, usaremos CI en lugar de VI en nuestro análisis. Todos nuestros resultados pueden aplicarse al caso en el que los agentes reciben el servicio en lugar de proporcionar al establecer CI en negativo, como en una subasta. En un juego de demanda binaria, si queremos optimizar una función objetivo G (O, T), entonces lo llamamos un juego de demanda de optimización binaria. Las principales diferencias entre los juegos de demanda binaria y aquellos problemas que pueden resolverse mediante mecanismos de VCG son: 1. La función objetivo es utilitario (o problema de maximización afín) para un problema solucionable por VCG, mientras que no hay restricción en la función objetivo de un juego de demanda binaria.2. La regla de asignación O estudiada aquí no necesariamente optimiza una función objetivo, mientras que un mecanismo VCG solo usa la salida que optimiza la función objetivo. Incluso no requerimos la existencia de una función objetivo.3. Suponemos que las valoraciones de los agentes no están correlacionadas en un juego de demanda binaria, mientras que las valoraciones de los agentes pueden estar correlacionadas en un mecanismo de VCG. En este documento, asumimos la conveniencia técnica que la función objetivo G (O, C), si existe, es continua con respecto al COS de CI, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación.2.3 Trabajo previo Lehmann et al.[12] estudiaron cómo diseñar un mecanismo veraz eficiente para una subasta combinatoria resuelta. En una subasta combinatoria individual, cada agente I (1 ≤ i ≤ n) solo quiere comprar un subset Si ⊆ s con precio privado. Un postor resuelto que declara una oferta bi = si, ai con si ⊆ s y ai ∈ R+. En [12], se supone que el conjunto de bienes asignados a un agente I es Si o ∅, que se conoce como exactitud. Lehmann et al.Dio un codicioso algoritmo de asignación basado en la ronda, basado en el rango ai | si | 1/2, que tiene una relación de aproximación √ m, donde M es el número de bienes en S. basado en el algoritmo de aproximación, dieron un pago verazesquema. Para una regla de asignación que satisface (1) exactitud: el conjunto de bienes asignados a un agente I es si o ∅;(2) Monotonicidad: proponer más dinero para menos bienes no puede causar que un postor pierda su oferta, propusieron un esquema de pago veraz de la siguiente manera: (1) cobrar a un postor ganador una cierta cantidad que no depende de su propia oferta;(2) cobrar a un postor perdedor 0. Observe que la suposición de exactitud revela que la subasta de mentalidad individual es de hecho un juego de demanda binaria. Su esquema de pago inspiró nuestro esquema de pago para el juego de demanda binaria. En [1], Archer et al.Estudió las subastas combinatorias donde se a la venta múltiples copias de muchos artículos diferentes, y cada postor desea solo un subconjunto SI. Idearon un método de redondeo aleatorio que es compatible con incentivos y dio un mecanismo veraz para las subastas combinatorias con agentes de parámetros únicos que maximiza aproximadamente el valor social de la subasta. Como señalaron, su método es fuertemente sincero en el sentido de que es sincero con alta probabilidad 1 -, donde es una probabilidad de error. Por el contrario, en este documento, estudiamos cómo diseñar un mecanismo determinista que sea veraz en función de algunas reglas de asignación dadas. En [2], Archer y Tardos mostraron cómo diseñar mecanismos veraces para varios problemas combinatorios en los que cada agente, la información privada se expresa naturalmente por un solo número real positivo, que siempre será el costo incurrido por unidad de carga. La salida de los mecanismos podría ser un número real arbitrario, pero su valoración es una función cuasi-lineal t · w, donde t es el costo privado por unidad y W es la carga de trabajo. Archer y Tardos caracterizaron que todo mecanismo veraz debería tener curvas de trabajo decrecientes w y que el pago veraz debe ser pi (bi) = pi (0) + biwi (bi) - r bi 0 wi (u) du usando este modelo, arquero y yTardos diseñó mecanismos veraces para varios problemas relacionados con la programación, incluida la minimización del tramo, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de finalización. Observe cuándo la carga de los problemas es w = {0, 1}, de hecho es un juego de demanda binaria. Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes W implica exactamente la propiedad de monotonicidad de la producción. Pero observe que su prueba se basa en gran medida en la suposición de que la producción es una función continua del costo, por lo que su conclusión no puede aplicarse directamente a los juegos de demanda binaria. El documento de Ahuva Mualem y Noam Nisan [13] es más cercano en espíritu a nuestro trabajo. Claramente declararon que solo discutimos una clase limitada de postores, postores de una mente soltera, que fue introducida por [12]. Probaron que todos los mecanismos veraces deberían tener una producción de monotonicidad y su esquema de pago se basa en el valor de corte. Con una generalización simple, obtenemos nuestra conclusión para el juego general de demanda binaria. Propusieron varios métodos combinados, incluidos Max, If-Then-Else, la construcción para realizar una búsqueda parcial. Todos sus métodos requirieron la función de bienestar asociada con la salida que satisface la propiedad bitónica. Distinción entre nuestras contribuciones y resultados anteriores: se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de mentalidad única, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una determinada propiedad de monotonicidad. El teorema 4 también depende de la propiedad de monotonicidad, pero es aplicable a un entorno más amplio que la subasta combinatoria de mentalidad única. Además, el juego de demanda binaria estudiada aquí es diferente del IPS tradicional de embalaje: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisface una determinada propiedad de monotonicidad;No ponemos ninguna restricción en la función objetivo. Además, el enfoque principal de este documento es diseñar algunas técnicas generales para encontrar el esquema de pago veraz para una regla de asignación dada o satisfacer una cierta propiedad de monotonicidad.3. Enfoques generales 3.1 Propiedades de los mecanismos a prueba de estrategias Discutimos varias propiedades que los mecanismos deben satisfacer para ser sincero. Teorema 1. Si un mecanismo m = (o, p) satisface el IC, entonces ∀i, si oi (t | i ti1) = oi (t | i ti2), entonces pi (t | i ti1) = pi (t | i ti2). Corolario 2. Para cualquier mecanismo a prueba de estrategia para un juego de demanda binaria G con la configuración S, si solucionamos el costo C-I de todos los agentes que no sean yo, el pago al Agente I es un P1 I constante si oi (c) = 1, yEs otra constante p0 i if oi (c) = 0. Teorema 3. Se corrigió la configuración S para un juego de demanda binaria, si el mecanismo m = (o, p) satisface el IC, entonces el mecanismo M = (o, p) con el mismo método de salida O y pi (c) = pi (c) - Δi (C - I) para cualquier función Δi (C - I) también satisface IC. Las pruebas de los teoremas anteriores son sencillas y, por lo tanto, se omiten debido al límite de espacio. Este teorema implica que para los juegos de demanda binaria siempre podemos normalizar el pago a un agente I tal que el pago al agente sea 0 cuando no se selecciona. En adelante, solo consideraremos esquemas de pago normalizados.215 3.2 Existencia del aviso de mecanismos a prueba de estrategias, dada la configuración S, un problema de diseño del mecanismo se compone de dos partes: la regla de asignación O y un esquema de pago P. En este documento, dada una regla de asignación o, centramos nuestra atención en cómo diseñarUn esquema de pago veraz basado en O. Dada una regla de asignación O para un juego de demanda binaria, primero presentamos una condición suficiente y necesaria para la existencia de un esquema de pago veraz P. Definición 1 (propiedad monótona no aumentable (MP)). Se dice que un método de salida O satisface la propiedad monótona no creciente si para cada agente I y dos de sus posibles costos CI1 <CI2, OI (C | I Ci2) ≤ Oi (C | I Ci1). Esta definición no está restringida solo a los juegos de demanda binarios. Para los juegos de demanda binaria, esta definición implica que si oi (c | i ci2) = 1 entonces oi (c | i ci1) = 1. Teorema 4. Arregle la configuración S, C - I en un juego de demanda binaria G con la regla de asignación O, las siguientes tres condiciones son equivalentes: 1. Existe un valor κi (O, C - I) (que llamaremos un valor cortado, de modo que oi (c) = 1 si Ci <κi (O, c - I) y oi (c) = 0 si Ci>κi (O, C - I). Cuando CI = κi (O, C-I), Oi (c) puede ser 0 o 1 dependiendo del desempate de la regla de asignación O. en adelante, no consideraremos el escenario del desempate en nuestras pruebas.2. La regla de asignación de MP3 satisfecho. Existe un esquema de pago veraz P para este juego de demanda binaria. PRUEBA. La prueba de que la condición 2 implica la condición es sencilla y se omite aquí. Luego mostramos la condición 3 implica la condición 2. La prueba de esto es similar a una prueba en [13]. Para probar esta dirección, suponemos que existe un agente I y dos vectores de valoración c | i ci1 y c | i ci2, donde ci1 <ci2, oi (c | i ci2) = 1 y oi (c | i ci1) = 0. De Corollary 2, sabemos que pi (c | i ci1) = p0 i y pi (c | i ci2) = p1 i. Ahora arregle C - I, la utilidad para i cuando Ci = Ci1 es ui (ci1) = p0 i. Cuando el agente I se encuentra su valoración a CI2, su utilidad es p1 i - Ci1. Dado que M = (O, P) es sincero, tenemos p0 i> p1 i - ci1. Ahora considere el escenario cuando la valoración real del agente I es CI = CI2. Su utilidad es P1 I - Ci2 cuando informa su verdadera valoración. Del mismo modo, si se encuentra su valoración a CI1, su utilidad es P0 I. Dado que M = (O, P) es sincero, tenemos p0 i <p1 i - ci2. En consecuencia, tenemos p1 i −ci2> p0 i> p1 i −ci1. Esta desigualdad implica que Ci1> Ci2, que es una contradicción. Luego mostramos la condición 1 implica la condición 3. Probamos esto construyendo un esquema de pago y demostrando que este esquema de pago es sincero. El esquema de pago es: si oi (c) = 1, entonces el agente I obtiene el pago pi (c) = κi (o, c - i);De lo contrario, obtiene el pago Pi (c) = 0. De la condición 1, si oi (c) = 1 entonces Ci> κi (O, C - I). Por lo tanto, su utilidad es κi (O, C - I) - Ci> 0, lo que implica que el esquema de pago satisface el IR. A continuación, probamos que este esquema de pago también satisface la propiedad IC. Hay dos casos aquí. Caso 1: CI <κ (O, C - I). En este caso, cuando declaro su verdadero costo CI, su utilidad es κi (O, C - I) - Ci> 0. Ahora considere la situación cuando declare un costo DI = CI. Si Di <κi (O, C - I), entonces obtiene el mismo pago y utilidad ya que todavía está seleccionado. Si Di> κi (O, C - I), entonces su utilidad se convierte en 0 ya que ya no se selecciona. Por lo tanto, no tiene ningún incentivo para mentir en este caso. Caso 2: IC ≥ κ (O, C - I). En este caso, cuando revela su verdadera valoración, su pago es 0 y la utilidad es 0. Ahora considere la situación cuando declara una valoración DI = CI. Si Di> κi (O, C - I), entonces obtiene el mismo pago y utilidad, ya que todavía no está seleccionado. Si Di ≤ κi (O, C - I), entonces su utilidad se convierte en κi (O, C - I) - Ci ≤ 0 ya que ahora se selecciona. Por lo tanto, no tiene incentivo para mentir. La equivalencia de la propiedad de monotonicidad de la regla de asignación O y la existencia de un mecanismo veraz que usa O puede extenderse a juegos más allá de los juegos de demanda binaria. Los detalles se omiten aquí debido al límite de espacio. Ahora resumimos el proceso para diseñar un esquema de pago veraz para un juego de demanda binaria basado en un método de salida O. Marco general 1 Diseño de mecanismo veraz para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación o satisface el MP. Si no es así, entonces no hay un esquema de pago P tal que el mecanismo M = (O, P) sea sincero. De lo contrario, defina el esquema de pago P de la siguiente manera. Etapa 2: Basado en la regla de asignación O, encuentre el valor cortado κi (O, C - I) para el Agente I tal que Oi (C | I di) = 1 cuando Di <κi (O, C - I) y Oi(c | i di) = 0 cuando di> κi (o, c - i). Etapa 3: El pago del Agente I es 0 si oi (c) = 0;El pago es κi (O, C - I) si oi (c) = 1. Teorema 5. El pago definido por nuestro marco general es mínimo entre todos los esquemas de pago veraces que utilizan O como salida.4. Computación de las funciones de valor de corte Para encontrar el esquema de pago veraz mediante el uso de General Framework 1, la etapa más difícil parece ser la etapa 2. Observe que la búsqueda binaria no funciona generalmente ya que las valoraciones de los agentes pueden ser continuas. Damos algunas técnicas generales que pueden ayudar a encontrar la función de valor cortado en ciertas circunstancias. Nuestro enfoque básico es el siguiente. Primero, descomponemos la regla de asignación en varias reglas de asignación. A continuación, encuentre la función de valor de corte para cada una de estas nuevas reglas de asignación. Luego, calculamos la función de valor de corte original combinando estas funciones de valor de corte de las nuevas reglas de asignación.4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la función del valor de corte mediante la combinación de múltiples reglas de asignación con conjunciones o disconjunciones. Por simplicidad, dada una regla de asignación O, usaremos κ (O, c) para denotar un vector N-tuple (κ1 (O, C-1), κ2 (O, C-2), ..., κN ((O, c - n)). Aquí, κi (O, C - I) es el valor reducido para el Agente I cuando la regla de asignación es O y los costos C - I de todos los demás agentes son fijos. Teorema 6. Con una configuración fija de un juego de demanda binaria, suponga que existen reglas de asignación M O1, O2, · · ·, que satisface la propiedad de monotonicidad, y κ (OI, C) es el vector de valor cortado para OI. Entonces la regla de asignación O (c) = Wm I = 1 Oi (c) satisface la propiedad de monotonicidad. Además, el valor cortado para O es κ (O, c) = maxm i = 1 {κ (oi, c)} aquí κ (o, c) = maxm i = 1 {κ (oi, c)} medias, ∀j ∈ [1, n], κj (o, c - j) = maxm i = 1 {κj (oi, c - j)} y o (c) = wm i = 1 oi (c) medias, ∀j ∈[1, n], oj (c) = o1 j (c) ∨ o2 j (c) ∨ · · · ∨ om j (c). PRUEBA. Suponga que Ci> Ci y Oi (c) = 1. Sin pérdida de generalidad, suponemos que OK I (C) = 1 para algunos k, 1 ≤ k ≤ m.De la suposición de que OK I (c) satisface a MP, obtenemos que 216 OK I (C | I CI) = 1. Por lo tanto, oi (c | i ci) = wm j = 1 oj (c) = 1. Esto demuestra que O (c) satisface MP. La corrección de la función de valor de corte sigue directamente desde el teorema 4. Muchos algoritmos se dividen en esta categoría. Para demostrar la utilidad del Teorema 6, discutimos un ejemplo concreto aquí. En una red, a veces queremos entregar un paquete a un conjunto de nodos en lugar de uno. Este problema se conoce como multidifusión. La estructura más utilizada en el enrutamiento de multidifusión se llama árbol de ruta más corto (SPT). Considere una red G = (V, E, C), donde V es el conjunto de nodos, y el vector C es el costo real de los nodos que reenvían los datos. Suponga que el nodo fuente es S y los receptores son Q ⊂ V. Para cada receptor Qi ∈ Q, calculamos la ruta más corta (ruta de menor costo), denotada por LCP (S, Qi, D), de la fuente a Qi bajo el perfil de costo informado d.La unión de todos esos caminos más cortos forma el árbol de camino más corto. Luego usamos General Framework 1 para diseñar el esquema de pago veraz P cuando la estructura SPT se usa como salida para multidifusión, es decir, diseñamos un mecanismo M = (SPT, P). Observe que los mecanismos de VCG no se pueden aplicar aquí ya que SPT no es una maximización afina. Definimos LCP (S, Qi) ya que la asignación corresponde a la ruta LCP (S, Qi, D), es decir, LCP (S, Qi) K (D) = 1 si y solo si el nodo VK está en LCP (S, S,qi, d). Entonces la salida SPT se define como w qi∈Q lcp (s, qi). En otras palabras, SPTK (d) = 1 si y solo si QK se selecciona en algún LCP (S, Qi, D). La regla de asignación de ruta más corta es una utilitaria y satisface MP. Por lo tanto, del teorema 6, SPT también satisface MP, y el vector de función del valor cortado para SPT se puede calcular como κ (SPT, C) = Maxqi∈Q κ (LCP (S, Qi), C), donde κ (LCP (LCP (LCP (LCP (LCP (LCP (LCPS, qi), c) es el vector de función de valor cortado para la ruta más corta LCP (S, Qi, C). En consecuencia, el esquema de pago anterior es veraz y el mínimo entre todos los esquemas de pago veraz cuando la regla de asignación es SPT. Teorema 7. Se corrigió la configuración de un juego de demanda binaria, suponga que existen m métodos de salida O1, O2, · · ·, om satisfecho de MP y κ (OI, C) son las funciones de valor cortado respectivamente para OI donde i = 1, 2, · · ·, M.Entonces la regla de asignación o (c) = vm i = 1 oi (c) satisface mp. Además, la función de valor cortado para O es κ (O, C) = Minm I = 1 {κ (Oi, C)}. Mostramos que nuestra combinación simple generaliza la función if-thenelse definida en [13]. Para un agente I, suponga que hay dos reglas de asignación O1 y O2 que satisfacen MP. Sea κi (O1, C - I), κi (O2, C - I) las funciones de valor cortado para O1, O2 respectivamente. Entonces la función if-then-else Oi (c) es en realidad Oi (c) = [(CI ≤ κi (O1, C-I) + Δ1 (C-I)) ∧ O2 (C-I, CI)] ∨(CI <κI (O1, C - I) - Δ2 (C - I)) donde Δ1 (C - I) y Δ2 (C - I) son dos funciones positivas. Al aplicar los teoremas 6 y 7, sabemos que la regla de asignación O satisface el MP y, en consecuencia, κi (O, C - I) = max {min (κi (O1, C - I)+ Δ1 (C - I), κi (O2 (O2, c - i)), κi (o1, c - i) - Δ2 (c - i))}.4.2 Asignaciones basadas en la ronda Algunos algoritmos de aproximación están basados en redondos, donde cada ronda de un algoritmo selecciona algunos agentes y actualiza la configuración y el perfil de costo si es necesario. Por ejemplo, varios algoritmos de aproximación para la cubierta de vértice de peso mínimo [19], el conjunto independiente de peso máximo, la cubierta del conjunto de peso mínimo [4] y el árbol de peso mínimo [18] se dividen en esta categoría. Como ejemplo, discutimos el problema mínimo de cobertura de vértice ponderado (MWVC) [16, 15] para mostrar cómo calcular el valor de corte para una salida redonda. Dado un gráfico g = (v, e), donde los nodos v1, v2 ,..., VN son los agentes y cada agente VI tiene un CI de peso, queremos encontrar un conjunto de nodo V ⊆ V tal que para cada borde (u, v) ∈ E al menos uno de U y V esté en V. Dicha V se llama una cubierta de vértice de G. La valoración de un nodo I es −ci si se selecciona;de lo contrario, su valoración es 0. Para un subconjunto de nodos v ∈ V, definimos su peso como c (v) = p i∈V ci. Queremos encontrar una cubierta de vértice con el peso mínimo. Por lo tanto, la función objetivo a implementar es utilitaria. Para usar el mecanismo VCG, necesitamos encontrar la cubierta del vértice con el peso mínimo, que es NP-Hard [16]. Dado que estamos interesados en mecanismos que se pueden calcular en tiempo polinomial, debemos usar reglas de asignación computables en tiempo polinómico. Se han propuesto muchos algoritmos en la literatura para aproximar la solución óptima. En este documento, utilizamos un algoritmo de 2 de acerca de 2 dados en [16]. En aras de la integridad, revisamos brevemente este algoritmo aquí. El algoritmo está basado en redondo. Cada ronda selecciona algunos vértices y descarta algunos vértices. Para cada nodo I, W (i) se inicializa a su peso CI, y cuando W (i) cae a 0, I está incluido en la cubierta del vértice. Para que la presentación sea clara, decimos que un borde (i1, j1) es lexicográficamente más pequeño que el borde (i2, j2) si (1) min (i1, j1) <min (i2, j2) o (2) min (i1, j1) = min (i2, j2) y max (i1, j1) <max (i2, j2). Algoritmo 2 Introducción de cubierta de vértice ponderada mínima aproximada: un gráfico ponderado de nodo G = (V, E, C). Salida: una cubierta de vértice v.1: establecer v = ∅. Para cada i ∈ V, establezca w (i) = ci.2: Si bien V no es una cubierta de vértice Do 3: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.4: Sea M = Min (W (I), W (J)).5: Actualización W (I) a W (I) - M y W (J) a W (J) - M.6: Si w (i) = 0, agregue i a v. Si w (j) = 0, agregue j a v. Aviso, seleccionar un borde utilizando el orden lexicográfico es crucial para garantizar la propiedad de monotonicidad. El algoritmo 2 sale una cubierta de vértice V cuyo peso está dentro de las 2 veces del óptimo. Por conveniencia, usamos VC (c) para denotar la cubierta de vértice calculada por el algoritmo 2 cuando el vector de costo de los vértices es c.A continuación generalizamos el Algoritmo 2 a un escenario más general. Por lo general, una salida redonda se puede caracterizar de la siguiente manera (Algoritmo 3). Definición 2. Se dice que una regla de actualización UR es independiente de Crossinging si, para cualquier agente no seleccioné en la ronda R, (1) Sr+1 y Cr+1 −o no depende de Cr J (2) para CR −i fijo, Cr I1≤ Cr I2 implica que Cr+1 I1 ≤ Cr+1 i2. Tenemos el siguiente teorema sobre la existencia de un pago veraz utilizando una regla de asignación basada en la ronda A. Teorema 8. Una salida redonda A, con el marco definido en el Algoritmo 3, satisface MP si los métodos de salida o satisfacen MP y todas las reglas de actualización UR son independientes del cruce. PRUEBA. Considere un agente I y C - I fijo. Probamos que cuando se selecciona un agente I con Costo CI, también se selecciona con Costo Di <Ci. Suponga que me seleccionan en la ronda R con Costo CI. Luego, bajo el costo di, si el agente I se selecciona en una ronda antes de R, nuestro reclamo es válido. De lo contrario, considere en la ronda r.Claramente, la configuración de SR y los costos de todos los demás agentes son los mismos que si el agente me hubiera costado CI, ya que no se selecciona en las rondas anteriores debido a la propiedad Independiente Cross. Como se selecciona en la ronda R con Costo CI, también se selecciona en la ronda R con di <ci por la razón que o satisface MP. Esto termina la prueba.217 Algoritmo 3 Una regla de asignación general basada en la ronda A 1: SET R = 0, C0 = C y G0 = G inicialmente.2: Repita 3: Calcule una salida o usando un algoritmo determinista o: Sr × Cr → {0, 1} n. Aquí o, CR y SR son regla de asignación, vector de costos y configuración de juego en el juego GR, respectivamente. Observación: o a menudo es un algoritmo codicioso simple, como seleccionar los agentes que minimizan alguna función utilitaria. Para el ejemplo de la cubierta del vértice, o siempre seleccionará el nodo ligero en el borde lexicográficamente menos descubierto (I, J).4: Sea r = r + 1. Actualice el juego GR - 1 para obtener un nuevo juego GR con la configuración de SR y Costo Vector CR de acuerdo con alguna regla UR: OR - 1 × (SR - 1, CR - 1) → (SR, CR). Aquí actualizamos el costo y la configuración del juego. Observación: Para el ejemplo de la cubierta de vértice, la regla de actualización disminuirá el peso de los vértices I y J por min (W (I), W (J)).5: Hasta que se encuentre una salida válida 6: devuelva la unión del conjunto de jugadores seleccionados de cada ronda como salida final. Para el ejemplo de la cobertura del vértice, es la unión de nodos seleccionados en todas las rondas. Algoritmo 4 Valor de corte de cálculo para la entrada de algoritmos basados en redondos: una salida redonda A, un juego G1 = G y una función de actualización Vector U. Salida: el valor de corte x para el agente k.1: establecer r = 0 y ck = ζ. Recuerde que ζ es un valor que puede garantizar AK = 0 cuando un agente informa el costo ζ.2: Repita 3: Calcule una salida o usando un algoritmo determinista basado en configurar SR usando una regla de asignación o: SR × Cr → {0, 1} n.4: Encuentre el valor de corte para el Agente K en función de la regla de asignación o para los costos Cr −k. Sea R = κK (OR, Cr −k) el valor cortado.5: Establezca R = R + 1 y obtenga un nuevo juego GR de GR - 1 y o de acuerdo con la regla de actualización UR.6: Deje que CR sea el nuevo vector de costo para el juego Gr.7: Hasta que se encuentre una salida válida.8: Deje que GI (x) sea el costo de Ci k cuando el vector de costo original es c | k x.9: Encuentre el valor mínimo x tal que 8 >>>>> <>>>>>: G1 (x) ≥ 1;G2 (x) ≥ 2;... GT - 1 (x) ≥ t - 1;gt (x) ≥ t.Aquí, T es el número total de rondas.10: emite el valor x como el valor de corte. Si el resultado basado en la ronda satisface la propiedad de monotonicidad, el valor de corte siempre existe. Luego mostramos cómo encontrar el valor cortado para un agente K seleccionado en el algoritmo 4. La corrección del algoritmo 4 es sencilla. Para calcular el valor de corte, suponemos que (1) el valor de corte R para cada ronda R se puede calcular en tiempo polinomial;(2) Podemos resolver la ecuación gr (x) = r para encontrar x en el tiempo polinomial cuando se dan el vector de costo C - I y B. Ahora consideramos el problema de la portada del vértice. Para cada ronda R, seleccionamos un vértice con el menor peso y eso es incidente en el borde lexicográficamente menos descubierto. La salida satisface MP. Para el Agente I, actualizamos su costo a Cr I - Cr J Iff Edge (I, J) se selecciona. Es fácil verificar que esta regla de actualización sea independiente del cruce, por lo tanto, podemos aplicar el Algoritmo 4 para calcular el valor de corte para el juego de cubierta establecida como se muestra en el Algoritmo 5. Algoritmo 5 COMPUTE CUT VALOR para MVC. Entrada: un gráfico ponderado de nodo G = (V, E, C) y un nodo k seleccionado por el algoritmo 2. Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binaria es una combinación simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG). Sin embargo, algunos algoritmos no pueden descomponerse de la manera descrita en la subsección 4.1. A continuación, presentamos una forma más compleja de combinar reglas de asignación, y como esperábamos, la forma de encontrar el valor de corte también es más complicado. Suponga que hay n agentes 1 ≤ i ≤ n con el vector de costos C, y hay M Juegos de demanda binarios GI con funciones objetivas fi (O, C), configuración de Si y regla de asignación ψi donde i = 1, 2, · · ·, m.Hay otro juego de demanda binaria con la configuración de la regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · ·, dm). Sea F el vector de función (F1, F2, · · ·, FM), ψ el vector de regla de asignación (ψ1, ψ2, · · ·, ψm) y ∫ ser el vector de configuración (S1, S2, · · ·,,SM). Para la simplicidad de notación, definimos fi (c) = fi (ψi (c), c), para cada 1 ≤ i ≤ m, y f (c) = (F1 (c), f2 (c), · · ·,,Fm (c)). Veamos un ejemplo concreto de estas combinaciones. Considere un gráfico ponderado de enlace G = (V, E, C), y un subconjunto de N nodos Q ⊆ V. El problema del árbol Steiner es encontrar un conjunto de enlaces con un costo total mínimo para conectar Q. Una forma de encontrar una aproximación del árbol Steiner es la siguiente: (1) Construimos una gráfica virtual completa H usando Q como vértices, y el costo de cada borde (i, j) es el costo de LCP (I, J, c) en el gráfico G;(2) construir el árbol de expansión mínimo de H, denotado como MST (H);(3) Se selecciona un borde de G si se selecciona en algunos LCP (I, J, C) y el borde (I, J) de H se selecciona para MST (H). En este juego, definimos Q (Q - 1)/2 juegos GI, J, donde i, j ∈ Q, con funciones objetivas fi, j (o, c) es el costo mínimo de 218 conectando I y J en el gráfico g, configurar Si es el gráfico original G y la regla de asignación es LCP (I, J, C). El juego G corresponde al juego MST en Graph H. El costo de las rutas Q (q-1)/2 más cortas define el vector de entrada d = (d1, d2, · · · ·, dm) para el juego MST. Se darán más detalles en la Sección 5.2. Definición 3. Dada una regla de asignación O y configuración S, un vector de función objetivo F, un vector de regla de asignación ψ y un vector de configuración ∫, definimos un juego de demanda binaria compuesta con la configuración S y la salida O ◦ F as (O ◦ F) I (C)= Wm J = 1 (OJ (F (C)) ∧ ψj I (C)). La regla de asignación de la definición anterior se puede interpretar de la siguiente manera. Se selecciona un agente I si y solo si hay una j tal que (1) i se selecciona en ψj (c), y (2) la regla de asignación o seleccionará el índice J en el perfil de costo f (c). Para simplificar, utilizaremos O ◦ F para denotar la salida de este juego de demanda binaria compuesta. Observe que existe un esquema de pago veraz que usa o ◦ f como salida si y solo si satisface la propiedad de monotonicidad. Para estudiar cuándo O ◦F satisface a MP, varias definiciones necesarias están en orden. Definición 4. Función Propiedad de monotonicidad (FMP) dada una función objetivo G y una regla de asignación O, se dice que una función h (c) = g (o (c), c) satisface la propiedad de la monotonicidad de la función, si, dado, se les da fijo c - i,Satisface: 1. Cuando Oi (c) = 0, H (c) no aumenta sobre CI.2. Cuando Oi (c) = 1, H (c) no disminuye sobre IC. Definición 5. Se dice que una propiedad de monotonicidad fuerte (SMP) una regla de asignación O satisface la fuerte propiedad de monotonicidad si o satisface MP, y para cualquier agente I con oi (c) = 1 y agente j = i, oi (c | j cj) = 1Si cj ≥ cj u oj (c | j cj) = 0. Lema 1. Para una regla de asignación dada o satisfaciendo los vectores SMP y costos C, C con Ci = Ci, si oi (c) = 1 y oi (c) = 0, entonces debe existir j = i tal que cj <cj y oj (c) = 1. De la definición de la fuerte propiedad de monotonicidad, tenemos el Lema 1 directamente. Ahora podemos dar una condición suficiente cuando O ◦ F satisface la propiedad de monotonicidad. Teorema 9. Si ∀i ∈ [1, M], Fi satisface FMP, ψi satisface MP, y la salida o satisface SMP, entonces O ◦ F satisface MP. PRUEBA. Suponiendo que para el vector de costo c tenemos (o ◦ f) i (c) = 1, debemos probar para cualquier vector de costo c = c | i ci con ci <ci, (o ◦ f) i (c) = 1. Notando que (o ◦ f) i (c) = 1, sin pérdida de generalidad, suponemos que OK (f (c)) = 1 y ψk i (c) = 1 para algún índice 1 ≤ k ≤ m.Ahora considere la salida O con el vector de costo f (c) | k fk (c). Hay dos escenarios, que se estudiarán uno por uno de la siguiente manera. Un escenario es que el índice K no es elegido por la función de salida O. De Lemma 1, debe existir j = k tal que fj (c) <fj (c) (1) oj (f (c) | k fk (c)) = 1 (2) luego demostramos que el agente seréseleccionado en la salida ψj (c), es decir, ψj i (c) = 1. Si no es así, ya que ψj (c) satisface MP, tenemos ψj i (c) = ψj i (c) = 0 de Ci <Ci. Dado que FJ satisface FMP, conocemos FJ (C) ≥ FJ (C), lo cual es una contradicción con la desigualdad (1). En consecuencia, tenemos ψj i (c) = 1. De la ecuación (2), el hecho de que el índice k no se seleccione por la regla de asignación O y la definición de SMP, tenemos OJ (f (c)) = 1, por lo tanto, el agente I es seleccionado por O ◦ F debido a OJ (OJ (F (c)) = 1 y ψj i (c) = 1. El otro escenario es que el índice K es elegido por la función de salida O. Primero, el agente I se elige en ψk (c) ya que la salida ψk (c) satisface la propiedad de monotonicidad y ci <ci y ψk i (c) = 1. En segundo lugar, dado que la función FK satisface FMP, sabemos que FK (C) ≤ Fk (C). Recuerde que la salida O satisface el SMP, por lo tanto, podemos obtener OK (F (c)) = 1 del hecho de que OK (F (C) | K Fk (C)) = 1 y Fk (C) ≤ Fk (C). En consecuencia, el agente I también será seleccionado en la salida final o ◦ F. Esto termina nuestra prueba. Este teorema implica que hay un valor de corte para la salida compuesta o ◦ F. Luego discutimos cómo encontrar el valor de corte para esta salida. A continuación, daremos un algoritmo para calcular κi (o ◦ f) cuando (1) o satisface SMP, (2) ψj satisface a MP y (3) para C - I fijo, FJ (c) es una constante, digamos HJ,Cuando ψj i (c) = 0, y fj (c) aumenta cuando ψj i (c) = 1. Observe que aquí HJ puede calcularse fácilmente configurando CI = ∞ ya que ψj satisface la propiedad de monotonicidad. Cuando se administra I y C - I fijo, definimos (fi j) −1 (y) como el X más pequeño de tal manera que FJ (C | I x) = y. Para simplificar, denotamos (fi j) −1 como f - 1 j si no se causa confusión cuando yo es un agente fijo. En este artículo, suponemos que, dado cualquier Y, podemos encontrar tales X en el tiempo polinomial. Algoritmo 6 Encuentre el valor de corte para el método de compuesto O ◦ F Entrada: Regla de asignación O, Vector de función objetivo F y Vector de función inversa F - 1 = {F - 1 1, · · · ·, F - 1 M}, Vector de regla de asignación ψ yC - I fijo. Salida: valor de corte para el agente I basado en O ◦ F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas ψj (CI).3: Calcule hj = fj (c | i ∞).4: Use H = (H1, H2, · · ·, HM) como la entrada para la función de salida O. denota τj = κJ (O, H - J) como la función de valor cortado de la salida O basada en la entrada h.5: para 1 ≤ j ≤ m do 6: set κi, j = f - 1 j (min {τj, hj}).7: El valor cortado para I es κi (O ◦ F, C - I) = maxm j = 1 κi, j. Teorema 10. El algoritmo 6 calcula el valor de corte correcto para el agente I en función de la regla de asignación O ◦ F. Prueba. Para probar la corrección de la función de valor cortado calculada por el algoritmo 6, probamos los siguientes dos casos. Para nuestra conveniencia, usaremos κi para representar κi (O ◦ F, C - I) si no se causa confusión. Primero, si di <κi entonces (o ◦ f) i (c | i di) = 1. Sin pérdida de generalidad, suponemos que κi = κi, j para algunos j. Dado que la función fj satisface fmp y ψj i (c | i di) = 1, tenemos fj (c | i di) <fj (κi). Aviso di <κi, j, a partir de la definición de κi, j = f - 1 j (min {τj, hj}) tenemos (1) ψj i (c | i di) = 1, (2) fj (c |i di) <τj debido al hecho de que FJ (x) es una función no dreible cuando se selecciona J. Por lo tanto, de la propiedad de monotonicidad de O y τj es el valor cortado para la salida o, tenemos oj (h | j fj (c | i di)) = 1. (3) Si oj (f (c | i di))= 1 entonces (o◦f) i (c | i di) = 1. De lo contrario, dado que o satisface SMP, Lemma 1 y la ecuación 3 implican que existe al menos un índice k tal que ok (f (c | i di)) = 1 y fk (c | i di) <hk. Nota fk (c | i di) <hk implica que yo está seleccionado en ψk (c | i di) ya que hk = fk (ci | i ∞). En otras palabras, el agente I se selecciona en O◦F.219 segundo, si di ≥ κi (o ◦ f, c - i) entonces (o ◦ f) i (c | i di) = 0. Suponga en aras de la contradicción de que (o ◦ f) i (c | i di) = 1. Luego existe un índice 1 ≤ j ≤ m tal que oj (f (c | i di)) = 1 y ψj i (c | i di) = 1. Recuerde que HK ≥ fk (c | i di) para cualquier k.Por lo tanto, del hecho de que o satisface SMP, al cambiar el vector de costo de f (c | i di) a h | j fj (c | i di), todavía tenemos OJ (h | j fj (c | i di)) = 1. Esto implica que FJ (c | i di) <τj. Combinando la desigualdad anterior y el hecho de que FJ (c | i c | i di) <hj, tenemos fj (c | i di) <min {hj, τj}. Esto implica di <f - 1 j (min {hj, τj}) = κi, j <κi (o ◦ f, c - i).que es una contradicción. Esto termina nuestra prueba. En la mayoría de las aplicaciones, la regla de asignación ψj implementa la función objetivo FJ y FJ es utilitario. Por lo tanto, podemos calcular el inverso de F - 1 J de manera eficiente. Otro problema es que parece que las condiciones cuando podemos aplicar el Algoritmo 6 son restrictivos. Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la combinación MAX en [13]. Suponga que A1 y A2 son dos reglas de asignación para una subasta combinatoria de mentalidad única, luego la combinación Max (A1, A2) devuelve la asignación con el bienestar más grande. Si el algoritmo A1 y A2 satisfacen MP y FMP, la operación max (x, y) que devuelve el elemento más grande de x e y satisface SMP. Del Teorema 9 obtenemos esa combinación Max (A1, A2) también satisface el MP. Además, el valor cortado de la combinación MAX se puede encontrar mediante el algoritmo 6. Como mostraremos en la Sección 5, la combinación compleja puede aplicarse a algunos problemas más complicados.5. Ejemplos concretos 5.1 Cubierta establecida En el problema de la cubierta establecida, se necesita cubrir un conjunto de elementos M, y cada agente 1 ≤ I ≤ n puede cubrir un subconjunto de elementos Si con un Cos de costo. Sea S = {S1, S2, · · ·, Sn} y C = (C1, C2, · · ·, CN). Queremos encontrar un subconjunto de agentes D tal que U ⊆ S i∈D Si. Los subconjuntos seleccionados se llaman la cubierta establecida para U. La eficiencia social de la salida d se define como p i∈D Ci, que es la función objetivo que se minimiza. Claramente, este es un mecanismo utilitario y, por lo tanto, se puede aplicar un mecanismo de VCG si podemos encontrar el subconjunto de S que te cubra con el costo mínimo. Es bien sabido que encontrar la solución óptima es NP-Hard. En [4], se ha propuesto un algoritmo de relación de aproximación de HM y se ha demostrado que esta es la mejor proporción posible para el problema de la cubierta establecida. Para la integridad de la presentación, revisamos su método aquí. Algoritmo 7 Entrada de la cubierta del conjunto codicioso (GSC): el agente está cubierto de subset SI y costo CI.(1 ≤ i ≤ n). Salida: un conjunto de agentes que pueden cubrir todos los elementos.1: Inicializar r = 1, t0 = ∅ y r = ∅.2: Mientras que r = u do 3: Encuentre el conjunto SJ con la densidad mínima CJ | SJ −tr |.4: establecer tr+1 = tr s sj y r = r s j.5: R = R + 1 6: Salida R. Sea GSC (s) los conjuntos seleccionados por el algoritmo 7. Notice que el conjunto de salida es una función de S y C.Algunos trabajos suponen que el tipo de agente podría ser CI, es decir, se supone que SI es un conocimiento público. Aquí, consideramos un caso más general en el que el tipo de agente es (Si, CI). En otras palabras, suponemos que cada agente no solo puede mentir sobre su costo CI, sino que también puede mentir sobre el conjunto SI. Este problema ahora se parece a la subasta combinatoria con postor de mentalidad única estudiada en [12], pero con las siguientes diferencias: en el problema de la cubierta del conjunto queremos cubrir todos los elementos y los conjuntos elegidos pueden tener cierta superposición mientras en una subasta combinatoria de la combinatoriaLos conjuntos elegidos son disjuntos. Podemos mostrar que el mecanismo M = (GSC, PV CG), utilizando el Algoritmo 7 para encontrar una cubierta establecida y aplicar el mecanismo VCG para calcular el pago a los agentes seleccionados, no es veraz. Obviamente, el problema de la portada del conjunto es un juego de demanda binaria. Por el momento, suponemos que el agente no podré mentir sobre SI. Descargaremos esta suposición más tarde. Mostramos cómo diseñar un mecanismo veraz aplicando nuestro marco general.1. Verifique la propiedad de monotonicidad: la salida del algoritmo 7 es una salida redonda. Por lo tanto, para un agente I, primero nos centramos en la salida de una ronda r.En la ronda R, si I es seleccionada por el algoritmo 7, entonces tiene la relación mínima CI | Si -tr |Entre todos los agentes restantes. Ahora considere el caso cuando miente su costo para Ci <ci, obviamente Ci | si - tr |sigue siendo mínimo entre todos los agentes restantes. En consecuencia, el agente I todavía se selecciona en la ronda R, lo que significa que la salida de la ronda R satisface MP. Ahora buscamos las reglas de actualización. Para cada ronda, solo actualizamos el TR+1 = TR S SJ y R = R S J, que obviamente es independiente. Por lo tanto, al aplicar el Teorema 8, sabemos que la salida por algoritmo 7 satisface MP.2. Encuentre el valor de corte: para calcular el valor de corte para el agente I con el vector de costo fijo C - I, seguimos los pasos en el algoritmo 4. Primero, establecemos CI = ∞ y aplicamos el algoritmo 7. Sea IR el agente seleccionado en la ronda R y T - I R+1 sea el conjunto correspondiente. Entonces el valor cortado de la ronda R es r = cir | señor - t - i r |· | Si - t - i r |. Recuerde que la regla de actualización solo actualiza la configuración del juego pero no el costo del agente, por lo tanto, tenemos gr (x) = x ≥ r para 1 ≤ r ≤ t.Por lo tanto, el valor de corte final para el Agente I es κi (GSC, C - I) = Max R {CIR | Sir - T - I R |· | Si - t - i r |} El pago a un agente I es κi si se selecciona;de lo contrario, su pago es 0. Ahora consideramos el escenario cuando el agente puedo mentir sobre SI. Suponga que el agente no puedo estar hacia arriba, es decir, solo puede informar un conjunto de Si ⊆ Si. Argumentamos que el agente no mentiré sobre sus elementos si. Observe que el valor de corte calculado para la ronda R es r = cir | Sir −t −i r |· | Si - t - i r |. Obviamente | Si - t - i r |≤ | si - t - i r |Para cualquier Si ⊆ Si. Por lo tanto, mentir su set como Si no aumentará el valor de corte para cada ronda. Por lo tanto, mentir sobre SI no mejorará el agente es la utilidad.5.2 Los árboles Steiner ponderados del enlace Considere cualquier enlace Network ponderada G = (V, E, C), donde E = {E1, E2, · · ·, EM} son el conjunto de enlaces y CI es el peso de la EI del enlace. El problema del árbol Steiner ponderado del enlace es encontrar un árbol enotricado en el nodo de origen que abarca un conjunto dado de nodos q = {Q1, Q2, · · ·, QK} ⊂ V. Por simplicidad, suponemos que qi = vi, para 1 ≤ i ≤ k.Aquí los enlaces son agentes. El costo total de los enlaces en un gráfico H ⊆ G se llama peso de H, denotado como Ω (H). Es difícil encontrar el árbol de multidifusión de costo mínimo cuando se le da un enlace arbitrario ponderado 220 gráfico G [17, 20]. El mejor método de tiempo polinómico tiene la relación de aproximación 1 + Ln 3 2 [17]. Aquí, revisamos y discutimos el primer método de aproximación de Takahashi y Matsuyama [20]. Algoritmo 8 Encuentre Entrada de SteinerTree (LST) de LinkWeeting: Network G = (V, E, C) donde C es el vector de costo para el conjunto de enlaces E. Nodos de origen y el conjunto de receptor establecido Q. Salida: un árbol LST enraizado en S y abarcó a todos los receptores.1: establecer r = 1, g1 = g, q1 = qy s1 = s.2: Repita 3: en gráfico GR, encuentre el receptor, digamos Qi, que está más cerca de la fuente S, es decir, LCP (S, Qi, C) tiene el menor costo entre las rutas más cortas de S a todos los receptores en QR.4: Seleccione todos los enlaces en LCP (S, Qi, C) como enlaces de retransmisión y establezca su costo en 0. El nuevo gráfico se denota como GR+1.5: Establezca TR como Qi y PR = LCP (S, Qi, C).6: Establezca qr + 1 = qr \\ qi y r = r + 1. 7: Hasta que todos los receptores estén abarcados. En adelante, deje que LST (G) sea el árbol final construido utilizando el método anterior. Se muestra en [24] que el mecanismo M = (LST, PV CG) no es veraz, donde PV CG es el pago calculado en función del mecanismo VCG. Luego mostramos cómo diseñar un esquema de pago veraz utilizando nuestro marco general. Observe que la salida PR, para cualquier ronda R, satisface MP, y la regla de actualización para cada ronda satisface la independencia de cruce. Por lo tanto, del Teorema 8, la salida de base redonda LST satisface MP. En la ronda R, el valor de corte para un enlace EI se puede obtener utilizando el mecanismo VCG. Ahora establecemos Ci = ∞ y ejecutamos el algoritmo 8. Deje que W - i r (ci) sea el costo de la ruta PR (CI) seleccionado en la redonda RTH y πi r (CI) sea la ruta más corta seleccionada en la ronda R si el costo de CI se establece temporalmente en −∞. Entonces el valor cortado para la ronda R es r = wi r (c - i) - | πi r (c - i) |donde | πi r (c - i) |es el costo de la ruta πi r (c - i) excluyendo el nodo vi. Usando el Algoritmo 4, obtenemos el valor de corte final para el Agente I: κi (LST, C - I) = Maxr {R}. Por lo tanto, el pago a un enlace EI es κi (LST, C - I) si su costo informado es di <κi (LST, D - I);De lo contrario, su pago es 0. 5.3 Los árboles de expansión mínima virtual para conectar el conjunto de receptores dado al nodo fuente, además del árbol Steiner construido por los algoritmos descritos anteriormente, a menudo también se usa un árbol de expansión mínimo virtual. Suponga que Q es el conjunto de receptores, incluido el remitente. Suponga que los nodos en un gráfico ponderado por el nodo son todos agentes. El árbol de expansión mínimo virtual se construye de la siguiente manera. Algoritmo 9 Construir VMST 1: Para todos los pares de receptores Qi, Qj ∈ Q DO 2: Calcule la ruta de menor costo LCP (Qi, QJ, D).3: Construya un gráfico ponderado de enlace completo virtual K (d) usando Q como conjunto de nodo, donde el enlace Qiqj corresponde a la ruta de menor costo LCP (Qi, Qj, D), y su peso es W (Qiqj) = | LCP(Qi, QJ, D) |.4: Construya el árbol de expansión mínimo en K (D), denotado como V MST (D).5: Para cada enlace virtual Qiqj en V MST (d) Do 6: Encuentre la ruta de menor costo correspondiente LCP (Qi, QJ, D) en la red original.7: Marque los agentes en LCP (Qi, QJ, D) seleccionado. El mecanismo M = (V MST, PV CG) no es veraz [24], donde el pago PV CG a un nodo se basa en el mecanismo VCG. Luego mostramos cómo diseñar un mecanismo veraz basado en el marco que describimos.1. Verifique la propiedad de monotonicidad: recuerde que en el gráfico completo k (d), el peso de un enlace qiqj es | lcp (qi, qj, d) |. En otras palabras, definimos implícitamente | Q | (| Q | - 1)/2 Funciones fi, j, para todos i <j y qi ∈ Q y qj ∈ Q, con fi, j (d) = | lcp (qi, QJ, D) |. Podemos mostrar que la función fi, j (d) = | lcp (qi, qj, d) |Satisface FMP, LCP satisface MP, y la salida MST satisface SMP. Desde el Teorema 9, la regla de asignación VMST satisface la propiedad de monotonicidad.2. Encuentre el valor de corte: aviso de VMST es la combinación de MST y función Fi, j, por lo que el valor de corte para VMST se puede calcular en función del algoritmo 6 de la siguiente manera.(a) Dado un gráfico completo ponderado de enlace k (d) en Q, deberíamos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST. Dado un árbol de expansión T y un par de terminales P y Q, claramente hay una ruta única que los conecta en T. Denotamos esta ruta como πt (P, Q), y el borde con la longitud máxima en este camino como LE (P, Q, T). Por lo tanto, el valor cortado se puede representar como κK (MST, D) = LE (Qi, QJ, MST (D | K ∞)) (b) Encontramos la función de costo de valor para LCP. Suponga vk ∈ Lcp (qi, qj, d), entonces la función de costo de valor es xk = yk-| lcpvk (qi, qj, d | k 0) |. Aquí, LCPVK (Qi, QJ, D) es la ruta de menor costo entre Qi y QJ con Node VK en esta ruta.(c) Retire VK y calcule el valor k (d | k ∞). Set h (i, j) = | lcp (qi, qj, d | ∞)) |Para cada par de nodo i = j y dejar h = {h (i, j)} el vector. Entonces es fácil mostrar que τ (i, j) = | le (qi, qj, mst (h | (i, j) ∞)) |es el valor de corte para la salida VMST. Es fácil verificar que Min {h (i, j), τ (i, j)} = | le (qi, qj, mst (h) |. Por lo tanto, sabemos κ (i, j) k (v mst, d) es | le (qi, qj, mst (h) | - | lcpvk (qi, qj, d | k 0) |. El valor de corte para el agente K es κK (V MST, D - K) = Max0≤i, J≤R κij K (V MST, D - K).3. Pagamos el agente K κK (V MST, D - K) si y solo si K se selecciona en V MST (D);De lo contrario, lo pagamos 0. 5.4 Subastas combinatorias Lehmann et al.[12] estudiaron cómo diseñar un mecanismo veraz eficiente para una subasta combinatoria resuelta. En una subasta combinatoria individual, hay un conjunto de artículos que se venden y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: Agente I quiere comprar un subconjunto con un precio máximomi. Un postor resuelto que declara una oferta bi = si, ai con si ⊆ s y ai ∈ R+. Dos ofertas SI, AI y SJ, AJ Conflicto si SI ∩ SJ = ∅. Dadas las ofertas B1, B2, · · ·, BN, dieron un codicioso algoritmo de base redondo como sigue. Primero, las ofertas se clasifican mediante algún criterio (Ai | Si | 1/2 se usa en [12]) en un orden creciente y que sea la lista de ofertas ordenadas. Se otorga la primera oferta. Luego, el algoritmo examina cada oferta de L en orden y otorga la oferta si no entra en conflicto con ninguna de las ofertas otorgadas previamente. Si es así, se niega. Probaron que este esquema de asignación codiciosa utilizando Criterion Ai | Si | 1/2 se aproxima a la asignación óptima dentro de un factor de √ m, donde M es el número de bienes en S. En la configuración de la subasta, tenemos CI = −ai. Es fácil verificar la salida del algoritmo codicioso es una salida redonda. Recuerde que después de que el postor J sea seleccionado para la ronda R, cada postor tiene conflicto 221 con J no será seleccionado en las rondas posteriores. Esto equivale a actualizar el costo de cada postor que tenga conflicto con J a 0, lo que satisface la independencia del cruce. Además, en cualquier ronda, si el postor i es seleccionado con AI, entonces aún se seleccionará cuando declare AI> AI. Por lo tanto, para cada ronda, satisface MP y el valor cortado es | Si | 1/2 · Ajr | Sjr | 1/2 donde Jr es el postor seleccionado en la ronda R si no consideramos el agente I en absoluto. Aviso ajr | sjr | 1/2 no aumenta cuando la ronda R aumenta, por lo que el valor de corte final es | si | 1/2 · aj | sj | 1/2 donde bj es la primera oferta que se ha negado pero se habría sidoSeleccionado no fue solo por la presencia del postor i. Por lo tanto, el pago del agente I es | Si | 1/2 · AJ | SJ | 1/2 si ai ≥ | si | 1/2 · aj | sj | 1/2, y 0 de lo contrario. Este esquema de pago es exactamente el mismo que el esquema de pago en [12].6. Conclusiones En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un juego de demanda binaria. Primero demostramos que la regla de asignación o satisfacer al MP es una condición necesaria y suficiente para que exista un mecanismo veraz. Luego formulamos un marco general para diseñar el pago P de manera que el mecanismo M = (O, P) sea sincero y computable en el tiempo polinomial. Además, presentamos varias técnicas generales basadas en composición para calcular P de manera eficiente para varias reglas de asignación O. Se discutieron varios ejemplos concretos para demostrar nuestro marco general para el diseño de P y para las técnicas basadas en la composición de computación P en el tiempo polinomial. En este artículo, nos hemos concentrado en cómo calcular P en el tiempo polinomial. Nuestros algoritmos no necesariamente tienen el tiempo de ejecución óptimo para calcular P dado O. Sería de interés diseñar algoritmos para calcular P en un tiempo óptimo. Hemos progresado en esta dirección de investigación en [22] al proporcionar un algoritmo para calcular los pagos de unidifusión en un gráfico ponderado de nodo en el tiempo óptimo de O (N log n + m). Otra dirección de investigación es diseñar una regla de asignación de aproximación o satisfacer a MP con una buena relación de aproximación para un juego de demanda binaria determinada. Muchas obras [12, 13] en la literatura de diseño del mecanismo están en esta dirección. Señalamos aquí que el objetivo de este documento no es diseñar una mejor regla de asignación para un problema, sino diseñar un algoritmo para calcular los pagos de manera eficiente cuando se da O. Sería importante diseñar reglas de asignación con buenas relaciones de aproximación de modo que un juego de demanda binaria determinada tenga un esquema de pago computacionalmente eficiente. En este artículo, hemos estudiado el diseño del mecanismo para los juegos de demanda binaria. Sin embargo, algunos problemas no pueden formularse directamente como juegos de demanda binaria. El problema de programación de trabajo en [2] es un ejemplo. Para este problema, existe un esquema de pago veraz P para una regla de asignación o si y solo si la carga de trabajo asignada por O es monotónica de cierta manera. A la herida será de interés generalizar nuestro marco para diseñar un esquema de pago veraz para un juego de demanda binaria a los juegos de demanda no binarios. Hacia esta dirección de investigación, el Teorema 4 se puede extender a una regla de asignación general O, cuyo rango es R+. La dificultad restante es entonces cómo calcular el pago P bajo suposiciones leves sobre las valoraciones si existe un mecanismo veraz M = (O, P). Agradecimientos Nos gustaría agradecer a Rakesh Vohra, Tuomas Sandholm y los revisores anónimos por sus útiles comentarios y discusiones.7. REFERENCIAS [1] A. Archer, C. Papadimitriou, K. T. y Tardos, E. Un mecanismo de veraz aproximado para subastas combinatorias con agentes de parámetros únicos. En ACM-SIAM Soda (2003), pp. 205-214.[2] Archer, A. y Tardos, E. Mecanismos veraces para agentes de un parámetro. En Actas del 42º IEEE FOCS (2001), IEEE Computer Society, p.482. [3] Auletta, V., Prisco, R. D., Penna, P. y Persiano, P. Esquemas de aproximación veraz deterministas para las máquinas relacionadas con la programación.[4] Chvatal, V. Una heurística codiciosa para el problema de cobertura del conjunto. Matemáticas de Operations Research 4, 3 (1979), 233-235.[5] Clarke, E. H. Precios multipart de bienes públicos. Public Choice (1971), 17-33.[6] R. Muller y R. V. Vohra. Sobre mecanismos de estrategia dominante. Working Paper, 2003. [7] Devanur, N. R., Mihail, M. y Vazirani, V. V. Mecanismos de intercambio de costos a prueba de estrategias para juegos de ubicación de la portada y la instalación. En ACM Electronic Commerce (EC03) (2003).[8] Feigenbaum, J., Krishnamurthy, A., Sami, R. y Shenker, S. Aproximación y colusión en costos compartidos de multidifusión (resumen). En ACM Economic Conference (2001).[9] Feigenbaum, J., Papadimitriou, C., Sami, R. y Shenker, S. Un mecanismo basado en BGP para el enrutamiento de menor costo. En Actas del Simposio ACM de 2002 sobre principios de computación distribuida.(2002), pp. 173-182.[10] Green, J. y Laffont, J. J. Caracterización de mecanismos satisfactorios para la revelación de las preferencias de los bienes públicos. Econometrica (1977), 427-438.[11] Groves, T. Incentivos en equipos. Econometrica (1973), 617-631.[12] Lehmann, D., Ocallaghan, L. I. y Shoham, Y. Revelación de la verdad en subastas combinatorias aproximadamente eficientes. Journal of ACM 49, 5 (2002), 577-602.[13] Mualem, A. y Nisan, N. Mecanismos de aproximación veraz para subastas combinatorias restringidas: abstracto extendido. En la 18ª Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana de Inteligencia Artificial, pp. 379-384.[14] Nisan, N. y Ronen, A. Diseño del mecanismo algorítmico. En Proc.31º ACM STOC anual (1999), págs. 129-140.[15] E. Halperin. Algoritmos de aproximación mejorados para el problema de la cubierta del vértice en gráficos e hipergrafios. En Actas del 11º Simposio ACM-SIAM anual sobre algoritmos discretos, páginas 329-337, 2000. [16] R. Bar-Yehuda y S. incluso. Un teorema de relación local para aproximar el problema de cubierta de vértice ponderado. Anales de Matemáticas Discretas, Volumen 25: Análisis y diseño de algoritmos para problemas combinatorios, páginas 27-46, 1985. Editor: G. Ausiello y M. Lucertini [17] Robins, G. y Zelikovsky, A. Aproximación mejorada del árbol Steiner en gráficos. En Actas del 11º ACM-SIAM Soda anual (2000), pp. 770-779.[18] A. Zelikovsky. Un algoritmo de 11/6 de acujos para el problema de la red Steiner. Algorithmica, 9 (5): 463-470, 1993. [19] D. S. Hochbaum. Límites eficientes para el conjunto estable, cobertura de vértice y problemas de embalaje, matemáticas aplicadas discretas, 6: 243-254, 1983. [20] Takahashi, H. y Matsuyama, A. Una solución aproximada para el problema Steiner en gráficos. Matemáticas. Japonica 24 (1980), 573-577.[21] Vickrey, W. Contadores, subastas y licitaciones selladas competitivas. Journal of Finance (1961), 8-37.[22] Wang, W. y Li, X.-Y. Unicast de bajo costo en las redes inalámbricas egoístas. En la cuarta transacciones IEEE en Mobile Computing (2005), para aparecer.[23] Wang, W., Li, X.-Y., y Sun, Z. Diseñar protocolos de multidifusión para redes no cooperativas. IEEE Infocom 2005, para aparecer.[24] Wang, W., Li, X.-Y. y Wang, Y. Multicast sincero en redes inalámbricas egoístas. ACM Mobicom, 2005. 222",
    "original_sentences": [
        "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
        "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
        "However, VCG mechanisms have their limitations.",
        "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
        "For many optimization problems, finding the optimal output is computationally intractable.",
        "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
        "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
        "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
        "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
        "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
        "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
        "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
        "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
        "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
        "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
        "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
        "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
        "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
        "Some mechanisms other than VCG mechanism are needed to address these issues.",
        "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
        "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
        "Auletta et al. [3] studied a similar scheduling problem.",
        "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
        "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
        "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
        "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
        "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
        "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
        "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
        "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
        "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
        "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
        "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
        "In fact, we do not even require the existence of an objective function.",
        "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
        "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
        "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
        "The remainder of the paper is organized as follows.",
        "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
        "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
        "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
        "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
        "We conclude our paper in Section 6 with some possible future directions. 2.",
        "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
        "A standard model for mechanism design is as follows.",
        "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
        "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
        "The agents types define the type vector t = (t1, t2, . . . , tn).",
        "Each agent i has a set of strategies Ai from which it can choose.",
        "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
        "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
        "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
        "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
        "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
        "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
        "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
        "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
        "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
        "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
        "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
        "Sometimes, we write (a−i, bi) as a|i bi.",
        "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
        "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
        "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
        "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
        "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
        "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
        "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
        "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
        "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
        "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
        "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
        "This makes the mechanism computationally intractable in many cases.",
        "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
        "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
        "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
        "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
        "Hereafter, we make the following further assumptions. 1.",
        "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
        "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
        "This assumption is needed to guarantee the IR property.",
        "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
        "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
        "Throughout this paper, we will use ci instead of vi in our analysis.",
        "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
        "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
        "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
        "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
        "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
        "We even do not require the existence of an objective function. 3.",
        "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
        "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
        "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
        "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
        "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
        "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
        "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
        "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
        "Their payment scheme inspired our payment scheme for binary demand game.",
        "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
        "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
        "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
        "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
        "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
        "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
        "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
        "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
        "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
        "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
        "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
        "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
        "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
        "With a simple generalization, we get our conclusion for general binary demand game.",
        "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
        "All of their methods required the welfare function associated with the output satisfying bitonic property.",
        "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
        "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
        "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
        "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
        "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
        "THEOREM 1.",
        "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
        "COROLLARY 2.",
        "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
        "THEOREM 3.",
        "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
        "The proofs of above theorems are straightforward and thus omitted due to space limit.",
        "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
        "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
        "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
        "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
        "This definition is not restricted only to binary demand games.",
        "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
        "THEOREM 4.",
        "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
        "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
        "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
        "The allocation rule O satisfies MP. 3.",
        "There exists a truthful payment scheme P for this binary demand game.",
        "PROOF.",
        "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
        "We then show Condition 3 implies Condition 2.",
        "The proof of this is similar to a proof in [13].",
        "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
        "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
        "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
        "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
        "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
        "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
        "Its utility is p1 i − ci2 when it reports its true valuation.",
        "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
        "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
        "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
        "This inequality implies that ci1 > ci2 , which is a contradiction.",
        "We then show Condition 1 implies Condition 3.",
        "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
        "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
        "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
        "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
        "In the following we prove that this payment scheme also satisfies IC property.",
        "There are two cases here.",
        "Case 1: ci < κ(O, c−i).",
        "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
        "Now consider the situation when i declares a cost di = ci.",
        "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
        "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
        "Thus, it has no incentive to lie in this case.",
        "Case 2: ci ≥ κ(O, c−i).",
        "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
        "Now consider the situation when i declares a valuation di = ci.",
        "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
        "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
        "Thus, it has no incentive to lie.",
        "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
        "The details are omitted here due to space limit.",
        "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
        "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
        "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
        "Otherwise, define the payment scheme P as follows.",
        "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
        "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
        "THEOREM 5.",
        "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
        "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
        "Notice that binary search does not work generally since the valuations of agents may be continuous.",
        "We give some general techniques that can help with finding the cut value function under certain circumstances.",
        "Our basic approach is as follows.",
        "First, we decompose the allocation rule into several allocation rules.",
        "Next find the cut value function for each of these new allocation rules.",
        "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
        "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
        "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
        "THEOREM 6.",
        "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
        "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
        "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
        "PROOF.",
        "Assume that ci > ci and Oi(c) = 1.",
        "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
        "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
        "This proves that O(c) satisfies MP.",
        "The correctness of the cut value function follows directly from Theorem 4.",
        "Many algorithms indeed fall into this category.",
        "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
        "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
        "This problem is known as multicast.",
        "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
        "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
        "Assume that the source node is s and the receivers are Q ⊂ V .",
        "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
        "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
        "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
        "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
        "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
        "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
        "The shortest path allocation rule is a utilitarian and satisfies MP.",
        "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
        "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
        "THEOREM 7.",
        "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
        "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
        "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
        "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
        "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
        "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
        "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
        "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
        "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
        "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
        "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
        "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
        "We want to find a vertex cover with the minimum weight.",
        "Hence, the objective function to be implemented is utilitarian.",
        "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
        "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
        "Many algorithms have been proposed in the literature to approximate the optimal solution.",
        "In this paper, we use a 2-approximation algorithm given in [16].",
        "For the sake of completeness, we briefly review this algorithm here.",
        "The algorithm is round-based.",
        "Each round selects some vertices and discards some vertices.",
        "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
        "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
        "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
        "Output: A vertex cover V . 1: Set V = ∅.",
        "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
        "If w(j) = 0, add j to V .",
        "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
        "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
        "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
        "Typically, a round-based output can be characterized as follows (Algorithm 3).",
        "DEFINITION 2.",
        "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
        "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
        "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
        "PROOF.",
        "Consider an agent i and fixed c−i.",
        "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
        "Assume that i is selected in round r with cost ci.",
        "Then under cost di, if agent i is selected in a round before r, our claim holds.",
        "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
        "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
        "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
        "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
        "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
        "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
        "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
        "Here we updates the cost and setting of the game.",
        "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
        "For the example of vertex cover, it is the union of nodes selected in all rounds.",
        "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
        "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
        "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
        "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
        "If the round-based output satisfies monotonicity property, the cut-value always exists.",
        "We then show how to find the cut value for a selected agent k in Algorithm 4.",
        "The correctness of Algorithm 4 is straightforward.",
        "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
        "Now we consider the vertex cover problem.",
        "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
        "The output satisfies MP.",
        "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
        "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
        "Algorithm 5 Compute Cut Value for MVC.",
        "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
        "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
        "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
        "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
        "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
        "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
        "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
        "Let us see a concrete example of these combinations.",
        "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
        "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
        "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
        "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
        "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
        "More details will be given in Section 5.2.",
        "DEFINITION 3.",
        "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
        "The allocation rule of the above definition can be interpreted as follows.",
        "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
        "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
        "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
        "To study when O ◦F satisfies MP, several necessary definitions are in order.",
        "DEFINITION 4.",
        "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
        "When Oi(c) = 0, H(c) does not increase over ci. 2.",
        "When Oi(c) = 1, H(c) does not decrease over ci.",
        "DEFINITION 5.",
        "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
        "LEMMA 1.",
        "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
        "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
        "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
        "THEOREM 9.",
        "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
        "PROOF.",
        "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
        "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
        "There are two scenarios, which will be studied one by one as follows.",
        "One scenario is that index k is not chosen by the output function O.",
        "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
        "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
        "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
        "Consequently, we have ψj i (c ) = 1.",
        "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
        "The other scenario is that index k is chosen by the output function O.",
        "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
        "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
        "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
        "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
        "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
        "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
        "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
        "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
        "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
        "In this paper, we assume that given any y, we can find such x in polynomial time.",
        "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
        "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
        "THEOREM 10.",
        "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
        "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
        "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
        "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
        "Without loss of generality, we assume that κi = κi,j for some j.",
        "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
        "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
        "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
        "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
        "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
        "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
        "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
        "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
        "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
        "This implies that Fj(c|i di) < τj.",
        "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
        "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
        "This finishes our proof.",
        "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
        "Thus, we can compute the inverse of F−1 j efficiently.",
        "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
        "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
        "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
        "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
        "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
        "Further, the cut value of the MAX combination can be found by Algorithm 6.",
        "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
        "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
        "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
        "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
        "The selected subsets is called the set cover for U.",
        "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
        "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
        "It is well-known that finding the optimal solution is NP-hard.",
        "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
        "For the completeness of presentation, we review their method here.",
        "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
        "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
        "Here, we consider a more general case in which the type of an agent is (Si, ci).",
        "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
        "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
        "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
        "Obviously, the set cover problem is a binary demand game.",
        "For the moment, we assume that agent i wont be able to lie about Si.",
        "We will drop this assumption later.",
        "We show how to design a truthful mechanism by applying our general framework. 1.",
        "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
        "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
        "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
        "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
        "Now we look into the updating rules.",
        "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
        "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
        "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
        "First, we set ci = ∞ and apply Algorithm 7.",
        "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
        "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
        "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
        "We now consider the scenario when agent i can lie about Si.",
        "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
        "We argue that agent i will not lie about its elements Si.",
        "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
        "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
        "Thus, lying its set as Si will not increase the cut value for each round.",
        "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
        "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
        "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
        "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
        "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
        "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
        "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
        "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
        "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
        "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
        "Hereafter, let LST(G) be the final tree constructed using the above method.",
        "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
        "We then show how to design a truthful payment scheme using our general framework.",
        "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
        "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
        "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
        "Now we set ci = ∞ and execute Algorithm 8.",
        "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
        "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
        "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
        "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
        "Assume that Q is the set of receivers, including the sender.",
        "Assume that the nodes in a node-weighted graph are all agents.",
        "The virtual minimum spanning tree is constructed as follows.",
        "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
        "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
        "We then show how to design a truthful mechanism based on the framework we described. 1.",
        "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
        "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
        "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
        "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
        "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
        "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
        "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
        "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
        "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
        "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
        "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
        "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
        "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
        "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
        "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
        "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
        "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
        "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
        "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
        "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
        "The first bid is granted.",
        "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
        "If it does, it is denied.",
        "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
        "It is easy to verify the output of the greedy algorithm is a round-based output.",
        "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
        "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
        "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
        "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
        "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
        "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
        "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
        "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
        "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
        "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
        "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
        "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
        "In this paper, we have concentrated on how to compute P in polynomial time.",
        "Our algorithms do not necessarily have the optimal running time for computing P given O.",
        "It would be of interest to design algorithms to compute P in optimal time.",
        "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
        "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
        "Many works [12, 13] in the mechanism design literature are in this direction.",
        "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
        "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
        "In this paper, we have studied mechanism design for binary demand games.",
        "However, some problems cannot be directly formulated as binary demand games.",
        "The job scheduling problem in [2] is such an example.",
        "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
        "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
        "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
        "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
        "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
        "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
        "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
        "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
        "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
        "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
        "On Dominant Strategy Mechanisms.",
        "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
        "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
        "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
        "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
        "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
        "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
        "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
        "Truth revelation in approximately efficient combinatorial auctions.",
        "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
        "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
        "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
        "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
        "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
        "A local ratio theorem for approximating the weighted vertex cover problem.",
        "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
        "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
        "Improved steiner tree approximation in graphs.",
        "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
        "An 11/6-approximation algorithm for the network Steiner problem.",
        "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
        "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
        "An approximate solution for the steiner problem in graphs.",
        "Math.",
        "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
        "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
        "Truthful low-cost unicast in selfish wireless networks.",
        "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
        "Design multicast protocols for non-cooperative networks.",
        "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
        "ACM MobiCom, 2005. 222"
    ],
    "error_count": 0,
    "keys": {
        "truthful mechanism": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in <br>truthful mechanism</br> design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a <br>truthful mechanism</br> M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a <br>truthful mechanism</br> for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation <br>truthful mechanism</br>, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a <br>truthful mechanism</br>.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a <br>truthful mechanism</br> M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a <br>truthful mechanism</br> M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a <br>truthful mechanism</br> that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient <br>truthful mechanism</br> for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a <br>truthful mechanism</br> for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all <br>truthful mechanism</br> should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the <br>truthful mechanism</br>, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a <br>truthful mechanism</br> if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a <br>truthful mechanism</br> using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 <br>truthful mechanism</br> design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a <br>truthful mechanism</br> by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a <br>truthful mechanism</br> based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient <br>truthful mechanism</br> for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a <br>truthful mechanism</br> M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a <br>truthful mechanism</br> M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a <br>truthful mechanism</br> M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate <br>truthful mechanism</br> for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "de informática Northwestern University Evanston, IL, EE. UU. kao@cs.northwestern.edu xiang-yang li † Departamento de informática Illinois Instituto de Tecnología Chicago, IL, EE. UU. Xli@cs.iit.edu Weizhao Wang Dept. de Computer Science de ComputerInstituto de Tecnología de Illinois Chicago, IL, EE. UU. Wangwei4@iit.edu Resumen La familia de los mecanismos de Vickrey-Clarke-Groves (VCG) es posiblemente el logro más famosa en el diseño de \"mecanismo veraz\".mecanismo veraz",
                "Para estos problemas, demostramos que un \"mecanismo veraz\" M = (O, P) existe con un método de pago adecuado sobre la regla de asignación o satisface una determinada propiedad de monotonicidad.mecanismo veraz",
                "Señalaron que una cierta propiedad de monotonicidad de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un \"mecanismo veraz\" para su problema de programación.mecanismo veraz",
                "Lehmann et al.[12] estudiaron la subasta combinatoria determinada y le dio una agrupación m \"mecanismo veraz\", donde M es el número de bienes.mecanismo veraz",
                "También señalaron que una cierta monotonicidad en la regla de asignación puede conducir a un \"mecanismo veraz\".mecanismo veraz",
                "Dada cualquier regla de asignación O para un juego de demanda binaria, demostramos que existe un \"mecanismo veraz\" M = (O, P) para el juego si y solo si o satisface una determinada propiedad de monotonicidad.mecanismo veraz",
                "En la Sección 3, mostramos que o satisfacer una determinada propiedad de monotonicidad es una condición necesaria y suficiente para la existencia de un \"mecanismo veraz\" M = (O, P).mecanismo veraz",
                "En este artículo, estudiamos cómo diseñar un \"mecanismo veraz\" que no optimice una función objetivo utilitaria.2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n.mecanismo veraz",
                "En este documento, asumimos la conveniencia técnica que la función objetivo G (O, C), si existe, es continua con respecto al COS de CI, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación.2.3 Trabajo previo Lehmann et al.[12] estudió cómo diseñar un \"mecanismo veraz\" eficiente para una subasta combinatoria resolutiva.mecanismo veraz",
                "Idearon un método de redondeo aleatorio que es compatible con incentivos y dio un \"mecanismo veraz\" para las subastas combinatorias con agentes de parámetros únicos que maximiza aproximadamente el valor social de la subasta.mecanismo veraz",
                "Archer y Tardos caracterizaron que todo el \"mecanismo veraz\" debería tener curvas de trabajo decrecientes w y que el pago veraz debería ser Pi (bi) = pi (0) + biwi (bi) - r bi 0 wi (u) du usando este modelo,Archer y Tardos diseñaron mecanismos veraces para varios problemas relacionados con la programación, incluida la minimización del tramo, maximizar el flujo y minimizar la suma ponderada de los problemas de tiempo de finalización.mecanismo veraz",
                "Si aplicamos su caracterización del \"mecanismo veraz\", sus curvas de trabajo decrecientes W implica exactamente la propiedad de monotonicidad de la salida.mecanismo veraz",
                "Distinción entre nuestras contribuciones y resultados anteriores: se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de mentalidad única, existe un esquema de pago que resulta en un \"mecanismo veraz\" si la regla de asignación satisface una ciertaPropiedad de monotonicidad.mecanismo veraz",
                "La equivalencia de la propiedad de monotonicidad de la regla de asignación O y la existencia de un \"mecanismo veraz\" que usa O puede extenderse a juegos más allá de los juegos de demanda binaria.mecanismo veraz",
                "Marco general 1 Diseño de \"mecanismo veraz\" para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación o satisface el MP.mecanismo veraz",
                "Mostramos cómo diseñar un \"mecanismo veraz\" aplicando nuestro marco general.1. Mecanismo veraz",
                "Luego mostramos cómo diseñar un \"mecanismo veraz\" basado en el marco que describimos.1. Mecanismo veraz",
                "Pagamos el agente K κK (V MST, D - K) si y solo si K se selecciona en V MST (D);De lo contrario, lo pagamos 0. 5.4 Subastas combinatorias Lehmann et al.[12] estudió cómo diseñar un \"mecanismo veraz\" eficiente para una subasta combinatoria resolutiva.mecanismo veraz",
                "Conclusiones En este artículo, hemos estudiado cómo diseñar un \"mecanismo veraz\" M = (O, P) para una regla de asignación dada O para un juego de demanda binaria.mecanismo veraz",
                "Primero demostramos que la regla de asignación o satisfacer al MP es una condición necesaria y suficiente para que exista un \"mecanismo veraz\".mecanismo veraz",
                "La dificultad restante es entonces cómo calcular el pago P bajo suposiciones leves sobre las valoraciones si existe un \"mecanismo veraz\" M = (O, P).mecanismo veraz",
                "Referencias [1] A. Archer, C. Papadimitriou, K. T. y Tardos, E. Un \"mecanismo veraz\" aproximado para las subastas combinatorias con agentes de parámetros únicos.mecanismo veraz"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "binary demand game": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a <br>binary demand game</br>, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A <br>binary demand game</br> is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a <br>binary demand game</br>, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a <br>binary demand game</br>. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a <br>binary demand game</br>, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a <br>binary demand game</br>.",
                "Their payment scheme inspired our payment scheme for <br>binary demand game</br>.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a <br>binary demand game</br>.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general <br>binary demand game</br>.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the <br>binary demand game</br> studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a <br>binary demand game</br> G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a <br>binary demand game</br>, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a <br>binary demand game</br>, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a <br>binary demand game</br> G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this <br>binary demand game</br>.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a <br>binary demand game</br> based on an output method O.",
                "General Framework 1 Truthful mechanism design for a <br>binary demand game</br> Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a <br>binary demand game</br>, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a <br>binary demand game</br>, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the <br>binary demand game</br> is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another <br>binary demand game</br> with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound <br>binary demand game</br> with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound <br>binary demand game</br>.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a <br>binary demand game</br>.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a <br>binary demand game</br>.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given <br>binary demand game</br>.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given <br>binary demand game</br> has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a <br>binary demand game</br> to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dada cualquier regla de asignación o para un \"juego de demanda binaria\", demostramos que existe un mecanismo veraz M = (O, P) para el juego si y solo si o satisface una determinada propiedad de monotonicidad.Juego de demanda binaria",
                "En este artículo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetivo utilitaria.2.2 Juegos de demanda binaria Un \"juego de demanda binaria\" es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n.Juego de demanda binaria",
                "En un \"juego de demanda binaria\", si queremos optimizar una función objetivo G (O, T), entonces lo llamamos un juego de demanda de optimización binaria.Juego de demanda binaria",
                "La función objetivo es utilitario (o problema de maximización afina) para un problema solucionable por VCG, mientras que no hay restricción en la función objetivo de un \"juego de demanda binaria\".2. Juego de demanda binaria",
                "Suponemos que las valoraciones de los agentes no están correlacionadas en un \"juego de demanda binaria\", mientras que las valoraciones de los agentes pueden correlacionarse en un mecanismo de VCG.Juego de demanda binaria",
                "Observe que la suposición de exactitud revela que la subasta de mentalidad individual es de hecho un \"juego de demanda binaria\".Juego de demanda binaria",
                "Su esquema de pago inspiró nuestro esquema de pago para \"Juego de demanda binaria\".Juego de demanda binaria",
                "Observe cuándo la carga de los problemas es w = {0, 1}, de hecho es un \"juego de demanda binaria\".Juego de demanda binaria",
                "Con una simple generalización, obtenemos nuestra conclusión para el \"juego de demanda binaria\" general.Juego de demanda binaria",
                "Además, el \"juego de demanda binaria\" estudiado aquí es diferente de las IP de embalaje tradicionales: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad;No ponemos ninguna restricción en la función objetivo.Juego de demanda binaria",
                "Para cualquier mecanismo a prueba de estrategia para un \"juego de demanda binaria\" G con la configuración S, si solucionamos el costo C-I de todos los agentes que no sean yo, el pago al Agente I es un P1 I If If Oi (C) = 1, y es otra constante p0 i si oi (c) = 0. juego de demanda binaria",
                "Se corrigió la configuración S para un \"juego de demanda binaria\", si el mecanismo M = (O, P) satisface IC, entonces el mecanismo M = (O, P) con el mismo método de salida O y Pi (C) = PI (C) - - -ΔI (C - I) para cualquier función ΔI (C - I) también satisface IC.Juego de demanda binaria",
                "Dada una regla de asignación O para un \"juego de demanda binaria\", primero presentamos una condición suficiente y necesaria para la existencia de un esquema de pago veraz P. Definición 1 (propiedad monótona no aumentable (MP)).Juego de demanda binaria",
                "Arregle la configuración S, C - I en un \"juego de demanda binaria\" G con la regla de asignación O, las siguientes tres condiciones son equivalentes: 1. Juego de demanda binaria",
                "Existe un esquema de pago veraz P para este \"juego de demanda binaria\".Juego de demanda binaria",
                "Ahora resumimos el proceso para diseñar un esquema de pago veraz para un \"juego de demanda binaria\" basado en un método de salida O. Juego de demanda binaria",
                "Marco general 1 Diseño del mecanismo veraz para un \"juego de demanda binaria\" Etapa 1: Compruebe si la regla de asignación o satisface el MP.Juego de demanda binaria",
                "Con una configuración fija de un \"juego de demanda binaria\", suponga que hay reglas de asignación M O1, O2, · · ·, que satisface la propiedad de monotonicidad, y κ (OI, C) es el vector de valor cortado para OI.Juego de demanda binaria",
                "Se corrigió la configuración de un \"juego de demanda binaria\", suponga que existen m métodos de salida O1, O2, · · ·, om satisfecho de MP y κ (OI, C) son las funciones de valor cortado respectivamente para OI donde i = 1, 2, · · ·, m.Entonces la regla de asignación o (c) = vm i = 1 oi (c) satisface mp.Juego de demanda binaria",
                "Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del \"juego de demanda binaria\" es una combinación simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG).Juego de demanda binaria",
                "Suponga que hay n agentes 1 ≤ i ≤ n con el vector de costos C, y hay M Juegos de demanda binarios GI con funciones objetivas fi (O, C), configuración de Si y regla de asignación ψi donde i = 1, 2, · · ·, m.Hay otro \"juego de demanda binaria\" con la configuración S y la regla de asignación O, cuya entrada es un vector de costo D = (D1, D2, · · ·, DM).Juego de demanda binaria",
                "Dada una regla de asignación O y configuración S, un vector de función objetivo F, un vector de regla de asignación ψ y un vector de configuración ∫, definimos un \"juego de demanda binaria\" compuesto con la configuración S y la salida O ◦ F as (O ◦ F) I (c) = Wm J = 1 (Oj (F (c)) ∧ ψj I (c)).Juego de demanda binaria",
                "Para simplificar, usaremos O ◦ F para denotar el resultado de este \"juego de demanda binaria\" compuesto.Juego de demanda binaria",
                "Obviamente, el problema de la portada del conjunto es un \"juego de demanda binaria\".Juego de demanda binaria",
                "Conclusiones En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un \"juego de demanda binaria\".Juego de demanda binaria",
                "Otra dirección de investigación es diseñar una regla de asignación de aproximación o satisfacer a MP con una buena relación de aproximación para un \"juego de demanda binaria\" dado.Juego de demanda binaria",
                "Sería una importancia diseñar reglas de asignación con buenas relaciones de aproximación de modo que un \"juego de demanda binaria\" dado tenga un esquema de pago computacionalmente eficiente.Juego de demanda binaria",
                "Sería interesante generalizar nuestro marco para diseñar un esquema de pago veraz para un \"juego de demanda binaria\" a los juegos de demanda no binarios.Juego de demanda binaria"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "vickrey-clarke-grove": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "objective function": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) <br>objective function</br>, and their output should optimize the <br>objective function</br>.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian <br>objective function</br>, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian <br>objective function</br>, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an <br>objective function</br> g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the <br>objective function</br>.",
                "In fact, we do not even require the existence of an <br>objective function</br>.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the <br>objective function</br> is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the <br>objective function</br> in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian <br>objective function</br>. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an <br>objective function</br> g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The <br>objective function</br> is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the <br>objective function</br> for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an <br>objective function</br>, while a VCG mechanism only uses the output that optimizes the <br>objective function</br>.",
                "We even do not require the existence of an <br>objective function</br>. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the <br>objective function</br> g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the <br>objective function</br>.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the <br>objective function</br> to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an <br>objective function</br> vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an <br>objective function</br> g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, <br>objective function</br> vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the <br>objective function</br> fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the <br>objective function</br> to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Solo se aplican a los problemas de optimización con una \"función objetivo\" utilitaria (o afine), y su salida debe optimizar la \"función objetivo\".función objetiva",
                "Los mecanismos VCG [5, 11, 21] son aplicables a los problemas de diseño del mecanismo cuyas salidas optimizan la \"función objetivo\" utilitaria, que es simplemente la suma de las valoraciones de todos los agentes.función objetiva",
                "Desafortunadamente, algunas funciones objetivas no son utilitarias;Incluso para esos problemas con una \"función objetivo\" utilitaria, a veces es imposible encontrar el resultado óptimo en el tiempo polinomial a menos que p = np.función objetiva",
                "Recuerde que un mecanismo M = (O, P) consta de dos partes, una regla de asignación O y un esquema de pago P. Anteriormente, a menudo se supone que existe una \"función objetivo\" G y una regla de asignación O, que optimizag exactamente o aproximadamente.función objetiva",
                "A diferencia de los mecanismos VCG, no requerimos que la asignación optimice la \"función objetivo\".función objetiva",
                "De hecho, ni siquiera requerimos la existencia de una \"función objetivo\".función objetiva",
                "El mecanismo VCG se aplica a los problemas de maximización (afines) donde la \"función objetivo\" es utilitaria g (o, t) = p i v (ti, o) (es decir, la suma de todas las valoraciones de los agentes) y se supone el conjunto de salidas posiblesser finito.función objetiva",
                "Se requiere la regla de asignación de un mecanismo VCG para maximizar la \"función objetivo\" en el rango de la función de asignación.función objetiva",
                "En este artículo, estudiamos cómo diseñar un mecanismo veraz que no optimice una \"función objetivo\" utilitaria.2.2 Juegos de demanda binaria Un juego de demanda binaria es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n.función objetiva",
                "En un juego de demanda binaria, si queremos optimizar una \"función objetivo\" G (O, T), entonces lo llamamos un juego de demanda de optimización binaria.función objetiva",
                "La \"función objetivo\" es utilitario (o problema de maximización afín) para un problema solucionable por VCG, mientras que no hay restricción en la \"función objetivo\" para un juego de demanda binaria.2. Función objetivo",
                "La regla de asignación O estudiada aquí no necesariamente optimiza una \"función objetivo\", mientras que un mecanismo VCG solo usa la salida que optimiza la \"función objetivo\".función objetiva",
                "Incluso no requerimos la existencia de una \"función objetivo\".3. Función objetivo",
                "En este documento, asumimos la conveniencia técnica que la \"función objetivo\" G (O, C), si existe, es continua con respecto al Cos de CI, pero la mayoría de nuestros resultados son directamente aplicables al caso discreto sin ninguna modificación.2.3 Trabajo previo Lehmann et al.[12] estudiaron cómo diseñar un mecanismo veraz eficiente para una subasta combinatoria resuelta.función objetiva",
                "Además, el juego de demanda binaria estudiada aquí es diferente del IPS tradicional de embalaje: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisface una determinada propiedad de monotonicidad;No ponemos ninguna restricción en la \"función objetivo\".función objetiva",
                "Por lo tanto, la \"función objetivo\" a implementar es utilitario.función objetiva",
                "Dada una regla de asignación O y una configuración S, un vector de \"función objetivo\" F, un vector de regla de asignación ψ y un vector de configuración ∫, definimos un juego de demanda binaria compuesta con la configuración S y la salida O ◦ F as (O ◦ F) I (c) = Wm J = 1 (Oj (F (c)) ∧ ψj I (c)).función objetiva",
                "Función Propiedad de monotonicidad (FMP) dada una \"función objetivo\" G y una regla de asignación o, se dice que una función h (c) = g (o (c), c) satisface la propiedad de monotonicidad de la función, si, dado, se le da una C- fija fijai, satisface: 1. función objetivo",
                "Algoritmo 6 Encuentre el valor de corte para el método de compuesto O ◦ F Entrada: Regla de asignación O, \"Función Objetiva\" Vector F y Vector de función inversa F - 1 = {F - 1 1, · · ·, F - 1 M}, Vector de regla de asignaciónψ y C - I fijo.función objetiva",
                "En la mayoría de las aplicaciones, la regla de asignación ψj implementa la \"función objetivo\" FJ y FJ es utilitario.función objetiva",
                "La eficiencia social de la salida d se define como p i∈D Ci, que es la \"función objetivo\" que se minimiza.función objetiva"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "composition-based technique": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general <br>composition-based technique</br>s to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the <br>composition-based technique</br>s that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general <br>composition-based technique</br>s to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for <br>composition-based technique</br>s of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Proporcionamos un marco general para diseñar dicho P. Proponemos además varias \"técnicas basadas en la composición\" generales para calcular P de manera eficiente para varios tipos de resultados.técnica basada en la composición",
                "Como se muestra en este documento, las combinaciones MAX e IF-Then-ELSE son casos especiales de las \"técnicas basadas en la composición\" que presentamos en este documento para calcular los pagos en el tiempo polinomial bajo suposiciones leves.técnica basada en la composición",
                "Además, presentamos varias \"técnicas\" generales basadas en la composición para calcular P de manera eficiente para varias reglas de asignación O. Técnica basada en la composición",
                "Se discutieron varios ejemplos concretos para demostrar nuestro marco general para diseñar P y para \"técnicas basadas en la composición\" de la computación de P en el tiempo polinomial.técnica basada en la composición"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "combination": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several <br>combination</br> methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple <br>combination</br> generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple <br>combination</br> of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX <br>combination</br> in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the <br>combination</br> MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that <br>combination</br> MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX <br>combination</br> can be found by Algorithm 6.",
                "As we will show in Section 5, the complex <br>combination</br> can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the <br>combination</br> of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Propusieron varios métodos de \"combinación\", incluidos Max, If-Then-Else, la construcción para realizar una búsqueda parcial.combinación",
                "Mostramos que nuestra \"combinación\" simple generaliza la función if-thenelse definida en [13].combinación",
                "Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la función de valor de corte cuando la salida del juego de demanda binaria es una \"combinación\" simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG).combinación",
                "Sin embargo, muchos juegos en la práctica satisfacen estas propiedades y aquí mostramos cómo deducir la \"combinación\" máxima en [13].combinación",
                "Suponga que A1 y A2 son dos reglas de asignación para una subasta combinatoria de mentalidad única, luego la \"combinación\" Max (A1, A2) devuelve la asignación con el bienestar más grande.combinación",
                "Del Teorema 9 obtenemos esa \"combinación\" Max (A1, A2) también satisface MP.combinación",
                "Además, el valor cortado de la \"combinación\" máxima se puede encontrar mediante el algoritmo 6. Combinación",
                "Como mostraremos en la Sección 5, la compleja \"combinación\" puede aplicarse a algunos problemas más complicados.5. Combinación",
                "Encuentre el valor de corte: aviso de VMST es la \"combinación\" de MST y función Fi, j, por lo que el valor de corte para VMST se puede calcular en función del algoritmo 6 de la siguiente manera.(a) Dado un gráfico completo ponderado de enlace k (d) en Q, deberíamos encontrar la función de valor de corte para borde ek = (qi, qj) basado en MST.combinación"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "selfish wireless network": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in <br>selfish wireless network</br>s.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in <br>selfish wireless network</br>s.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Unicast sincero de bajo costo en la \"red inalámbrica egoísta\" s.Red inalámbrica egoísta",
                "IEEE Infocom 2005, para aparecer.[24] Wang, W., Li, X.-Y., y Wang, Y. Multicast sincero en \"Red inalámbrica egoísta\" s.Red inalámbrica egoísta"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "mechanism design": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful <br>mechanism design</br>.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic <br>mechanism design</br> and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to <br>mechanism design</br> problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 <br>mechanism design</br> As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for <br>mechanism design</br> is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for <br>mechanism design</br> is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in <br>mechanism design</br> is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a <br>mechanism design</br> problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful <br>mechanism design</br> for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the <br>mechanism design</br> literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied <br>mechanism design</br> for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic <br>mechanism design</br>.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "de informática Northwestern University Evanston, IL, EE. UU. kao@cs.northwestern.edu xiang-yang li † Departamento de informática Illinois Instituto de Tecnología Chicago, IL, EE. UU. Xli@cs.iit.edu Weizhao Wang Dept. de Computer Science de ComputerIllinois Institute of Technology Chicago, IL, EE. UU. Wangwei4@iit.edu Resumen La familia de los mecanismos de Vickrey-Clarke-Groves (VCG) es posiblemente el logro más famoso en el \"diseño de mecanismo\" más famosa.diseño de mecanismo",
                "Con este fin, Nisan y Ronen [14] propusieron el marco del \"diseño de mecanismo\" algorítmico y los mecanismos de VCG aplicaron a algunos problemas fundamentales en la informática, incluidas las rutas más cortas, los árboles mínimos y la programación en máquinas no relacionadas.diseño de mecanismo",
                "Los mecanismos VCG [5, 11, 21] son aplicables a problemas de \"diseño de mecanismo\" cuyas salidas optimizan la función objetivo utilitaria, que es simplemente la suma de las valoraciones de todos los agentes.diseño de mecanismo",
                "Preliminares 2.1 \"Diseño del mecanismo\" Como se hace generalmente en la literatura sobre el diseño de algoritmos o protocolos con aportes de agentes individuales, adoptamos la suposición en la economía neoclásica de que todos los agentes son racionales, es decir, responden a incentivos bien definidos y desviaremosdel protocolo solo si la desviación mejora su ganancia.diseño de mecanismo",
                "Un modelo estándar para el \"diseño del mecanismo\" es el siguiente.diseño de mecanismo",
                "Otro requisito común en la literatura para el \"diseño del mecanismo\" es la llamada racionalidad individual o participación voluntaria: la utilidad de los agentes de participar en la producción del mecanismo no es menor que la utilidad del agente de no participar.diseño de mecanismo",
                "Podría decirse que el resultado positivo más importante en el \"diseño del mecanismo\" es el mecanismo generalizado de Vickrey-Clarke-Groves (VCG) por Vickrey [21], Clarke [5] y Groves [11].diseño de mecanismo",
                "En adelante, solo consideraremos esquemas de pago normalizados.215 3.2 Existencia de los mecanismos a prueba de estrategias Aviso, dado la configuración S, un problema de \"diseño de mecanismo\" se compone de dos partes: la regla de asignación O y un esquema de pago P. En este documento, dada una regla de asignación o, centramos nuestra atención en cómopara diseñar un esquema de pago veraz basado en el diseño del mecanismo O.",
                "Marco general 1 \"Diseño de mecanismo\" veraz para un juego de demanda binaria Etapa 1: Compruebe si la regla de asignación o satisface el MP.diseño de mecanismo",
                "Muchas obras [12, 13] en la literatura del \"diseño del mecanismo\" están en esta dirección.diseño de mecanismo",
                "En este artículo, hemos estudiado \"diseño de mecanismo\" para los juegos de demanda binaria.diseño de mecanismo",
                "En la 18ª Conferencia Nacional sobre Inteligencia Artificial (2002), Asociación Americana de Inteligencia Artificial, pp. 379-384.[14] Nisan, N. y Ronen, A. \"Diseño de mecanismo\" algorítmico.diseño de mecanismo"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "pricing": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart <br>pricing</br> of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Matemáticas de Operations Research 4, 3 (1979), 233-235.[5] Clarke, E. H. \"Precios\" de bienes públicos.fijación de precios"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "monotonicity property": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain <br>monotonicity property</br>.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain <br>monotonicity property</br> of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain <br>monotonicity property</br> in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain <br>monotonicity property</br>.",
                "The <br>monotonicity property</br> only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain <br>monotonicity property</br> is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the <br>monotonicity property</br> of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain <br>monotonicity property</br>.",
                "Theorem 4 also depends on the <br>monotonicity property</br>, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain <br>monotonicity property</br>; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain <br>monotonicity property</br>. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the <br>monotonicity property</br> of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the <br>monotonicity property</br>, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the <br>monotonicity property</br>.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the <br>monotonicity property</br>.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies <br>monotonicity property</br>, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the <br>monotonicity property</br>.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function <br>monotonicity property</br> (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function <br>monotonicity property</br>, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong <br>monotonicity property</br> (SMP) An allocation rule O is said to satisfy the strong <br>monotonicity property</br> if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong <br>monotonicity property</br>, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the <br>monotonicity property</br>.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the <br>monotonicity property</br> and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the <br>monotonicity property</br>.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the <br>monotonicity property</br> of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the <br>monotonicity property</br>: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the <br>monotonicity property</br>: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the <br>monotonicity property</br>. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Para estos problemas, demostramos que un mecanismo veraz M = (O, P) existe con un método de pago adecuado sobre la regla de asignación o satisface una cierta \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Señalaron que una cierta \"propiedad de monotonicidad\" de la carga de trabajo de salida es una condición necesaria y suficiente para la existencia de un mecanismo veraz para su problema de programación.propiedad de monotonicidad",
                "Caracterizaron todos los mecanismos veraces basados en una cierta \"propiedad de monotonicidad\" en un entorno de subasta decidida.propiedad de monotonicidad",
                "Dada cualquier regla de asignación o para un juego de demanda binaria, demostramos que existe un mecanismo veraz m = (o, p) para el juego si y solo si o satisface una cierta \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "La \"propiedad de monotonicidad\" solo garantiza la existencia de un esquema de pago P de tal manera que (o, p) es sincero.propiedad de monotonicidad",
                "En la Sección 3, mostramos que o satisfacer una cierta \"propiedad de monotonicidad\" es una condición necesaria y suficiente para la existencia de un mecanismo veraz M = (O, P).propiedad de monotonicidad",
                "Si aplicamos su caracterización del mecanismo veraz, sus curvas de trabajo decrecientes W implica exactamente la \"propiedad de monotonicidad\" de la salida.propiedad de monotonicidad",
                "Distinción entre nuestras contribuciones y resultados anteriores: se ha demostrado en [2, 6, 12, 13] que para la subasta combinatoria de mentalidad única, existe un esquema de pago que resulta en un mecanismo veraz si la regla de asignación satisface una cierta \"monotonicidadpropiedad\".propiedad de monotonicidad",
                "El teorema 4 también depende de la \"propiedad de monotonicidad\", pero es aplicable a un entorno más amplio que la subasta combinatoria de mentalidad única.propiedad de monotonicidad",
                "Además, el juego de demanda binaria estudiada aquí es diferente del IPS tradicional de embalaje: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisface una cierta \"propiedad de monotonicidad\";No ponemos ninguna restricción en la función objetivo.propiedad de monotonicidad",
                "Además, el enfoque principal de este documento es diseñar algunas técnicas generales para encontrar el esquema de pago veraz para una regla de asignación dada o satisfacer una cierta \"propiedad de monotonicidad\".3. Propiedad de monotonicidad",
                "La equivalencia de la \"propiedad de monotonicidad\" de la regla de asignación O y la existencia de un mecanismo veraz que usa O puede extenderse a juegos más allá de los juegos de demanda binaria.propiedad de monotonicidad",
                "Con una configuración fija de un juego de demanda binaria, suponga que existen reglas de asignación M O1, O2, · · ·, OM Satisfacer la \"propiedad de monotonicidad\", y κ (OI, C) es el vector de valor cortado para OI.propiedad de monotonicidad",
                "Entonces la regla de asignación O (c) = Wm I = 1 oi (c) satisface la \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Aviso, seleccionar un borde utilizando el orden lexicográfico es crucial para garantizar la \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Si el resultado basado en la ronda satisface la \"propiedad de monotonicidad\", siempre existe el valor de corte.propiedad de monotonicidad",
                "Observe que existe un esquema de pago veraz que usa o ◦ f como salida si y solo si satisface la \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Función \"Propiedad de monotonicidad\" (FMP) dada una función objetivo G y una regla de asignación O, se dice que una función h (c) = g (o (c), c) satisface la función \"propiedad de monotonicidad\", si, dada fijaC - I, satisface: 1. Propiedad de monotonicidad",
                "Se dice que una fuerte \"propiedad de monotonicidad\" (SMP) una regla de asignación O satisface la fuerte \"propiedad de monotonicidad\" si o satisface a MP, y para cualquier agente I con oi (c) = 1 y agente j = i, oi (c | jCJ) = 1 Si CJ ≥ CJ o OJ (C | J CJ) = 0. Propiedad de monotonicidad",
                "De la definición de la fuerte \"propiedad de monotonicidad\", tenemos Lemma 1 directamente.propiedad de monotonicidad",
                "Ahora podemos dar una condición suficiente cuando O ◦ F satisface la \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Primero, el agente I se elige en ψk (c) ya que la salida ψk (c) satisface la \"propiedad de monotonicidad\" y ci <ci y ψk i (c) = 1. Propiedad de monotonicidad",
                "Observe que aquí HJ puede calcularse fácilmente configurando CI = ∞ ya que ψj satisface la \"propiedad de monotonicidad\".propiedad de monotonicidad",
                "Por lo tanto, de la \"propiedad de monotonicidad\" de O y τj es el valor cortado para la salida o, tenemos oj (h | j fj (c | i di)) = 1. (3) si oj (f | i di di))) = 1 entonces (o◦f) i (c | i di) = 1. Propiedad de monotonicidad",
                "Verifique la \"propiedad de monotonicidad\": la salida del algoritmo 7 es una salida redonda.propiedad de monotonicidad",
                "Verifique la \"propiedad de monotonicidad\": recuerde que en el gráfico completo k (d), el peso de un enlace qiqj es | lcp (qi, qj, d) |.propiedad de monotonicidad",
                "Desde el Teorema 9, la regla de asignación VMST satisface la \"propiedad de monotonicidad\".2. Propiedad de monotonicidad"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "cut value function": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the <br>cut value function</br> under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the <br>cut value function</br> for each of these new allocation rules.",
                "Then, we compute the original <br>cut value function</br> by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the <br>cut value function</br> by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the <br>cut value function</br> follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the <br>cut value function</br> vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the <br>cut value function</br> vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the <br>cut value function</br> for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the <br>cut value function</br> when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the <br>cut value function</br> of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the <br>cut value function</br> calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the <br>cut value function</br> for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Damos algunas técnicas generales que pueden ayudar a encontrar la \"función de valor de corte\" en ciertas circunstancias.Función de valor de corte",
                "A continuación, encuentre la \"función de valor de corte\" para cada una de estas nuevas reglas de asignación.Función de valor de corte",
                "Luego, calculamos la \"función de valor de corte\" original al combinar estas funciones de valor cortado de las nuevas reglas de asignación.4.1 Combinaciones simples En esta subsección, introducimos técnicas para calcular la \"función de valor de corte\" combinando múltiples reglas de asignación con conjunciones o desconjunciones.Función de valor de corte",
                "La corrección de la \"función de valor de corte\" sigue directamente desde el teorema 4. Función de valor de corte",
                "Por lo tanto, del teorema 6, SPT también satisface MP, y el vector de \"función de valor cortado\" para SPT se puede calcular como κ (SPT, C) = maxqi∈Q κ (LCP (S, Qi), C), donde κ (((LCP (S, Qi), C) es el vector \"Función de valor de corte\" para la ruta más corta LCP (S, Qi, C).Función de valor de corte",
                "Además, la \"función de valor de corte\" para O es κ (O, c) = minm i = 1 {κ (Oi, c)}.Función de valor de corte",
                "Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la \"función de valor de corte\" cuando la salida del juego de demanda binaria es una combinación simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG).Función de valor de corte",
                "Salida: valor de corte para el agente I basado en O ◦ F. 1: para 1 ≤ j ≤ m do 2: Calcule las salidas ψj (CI).3: Calcule hj = fj (c | i ∞).4: use H = (H1, H2, · · ·, HM) como la entrada para la función de salida O. denota τj = κj (o, h - j) como la \"función de valor de corte\" de la salida O basada en la entrada h h.5: para 1 ≤ j ≤ m do 6: set κi, j = f - 1 j (min {τj, hj}).7: El valor cortado para I es κi (O ◦ F, C - I) = maxm j = 1 κi, j.Función de valor de corte",
                "Para probar la corrección de la \"función de valor de corte\" calculada por el algoritmo 6, probamos los siguientes dos casos.Función de valor de corte",
                "Encuentre el valor de corte: aviso de VMST es la combinación de MST y función Fi, j, por lo que el valor de corte para VMST se puede calcular en función del algoritmo 6 de la siguiente manera.(a) Dado un gráfico completo ponderado de enlace k (d) en Q, deberíamos encontrar la \"función de valor de corte\" para borde ek = (qi, qj) basado en MST.Función de valor de corte"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "selfish agent": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "price": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary demand game, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary demand game is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary demand game, if we want to optimize an objective function g(o, t), then we call it a binary optimization demand game.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary demand game. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary demand game, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private <br>price</br> ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary demand game.",
                "Their payment scheme inspired our payment scheme for binary demand game.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary demand game.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary demand game.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary demand game studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary demand game G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary demand game, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary demand game, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary demand game G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary demand game.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary demand game based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary demand game Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary demand game, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary demand game, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary demand game is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary demand game with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary demand game with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary demand game.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary demand game.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum <br>price</br> mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary demand game.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary demand game.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary demand game has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary demand game to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En una subasta combinatoria individual, cada agente I (1 ≤ I ≤ n) solo quiere comprar un subset Si ⊆ s con \"precio\" privado.precio",
                "En una subasta combinatoria individual, hay un conjunto de artículos que se venden y hay un conjunto de agentes 1 ≤ i ≤ n que quiere comprar algunos de los artículos: agente que quiero comprar un subconjunto con máximo \"Precio \"Mi.precio"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "demand game": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Towards Truthful Mechanisms for Binary Demand Games: A General Framework Ming-Yang Kao ∗ Dept.",
                "of Computer Science Northwestern University Evanston, IL, USA kao@cs.northwestern.edu Xiang-Yang Li † Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA xli@cs.iit.edu WeiZhao Wang Dept. of Computer Science Illinois Institute of Technology Chicago, IL, USA wangwei4@iit.edu ABSTRACT The family of Vickrey-Clarke-Groves (VCG) mechanisms is arguably the most celebrated achievement in truthful mechanism design.",
                "However, VCG mechanisms have their limitations.",
                "They only apply to optimization problems with a utilitarian (or affine) objective function, and their output should optimize the objective function.",
                "For many optimization problems, finding the optimal output is computationally intractable.",
                "If we apply VCG mechanisms to polynomial-time algorithms that approximate the optimal solution, the resulting mechanisms may no longer be truthful.",
                "In light of these limitations, it is useful to study whether we can design a truthful non-VCG payment scheme that is computationally tractable for a given allocation rule O.",
                "In this paper, we focus our attention on binary demand games in which the agents only available actions are to take part in the a game or not to.",
                "For these problems, we prove that a truthful mechanism M = (O, P) exists with a proper payment method P iff the allocation rule O satisfies a certain monotonicity property.",
                "We provide a general framework to design such P. We further propose several general composition-based techniques to compute P efficiently for various types of output.",
                "In particular, we show how P can be computed through or/and combinations, round-based combinations, and some more complex combinations of the outputs from subgames.",
                "Categories and Subject Descriptors F.2 [Analysis of Algorithms and Problem Complexity]: General; J.4 [Social and Behavioral Sciences]: Economics; K.4.4 [Computer and Society]: Electronic Commerce General Terms Algorithms, Economics, Theory 1.",
                "INTRODUCTION In recent years, with the rapid development of the Internet, many protocols and algorithms have been proposed to make the Internet more efficient and reliable.",
                "The Internet is a complex distributed system where a multitude of heterogeneous agents cooperate to achieve some common goals, and the existing protocols and algorithms often assume that all agents will follow the prescribed rules without deviation.",
                "However, in some settings where the agents are selfish instead of altruistic, it is more reasonable to assume these agents are rational - maximize their own profits - according to the neoclassic economics, and new models are needed to cope with the selfish behavior of such agents.",
                "Towards this end, Nisan and Ronen [14] proposed the framework of algorithmic mechanism design and applied VCG mechanisms to some fundamental problems in computer science, including shortest paths, minimum spanning trees, and scheduling on unrelated machines.",
                "The VCG mechanisms [5, 11, 21] are applicable to mechanism design problems whose outputs optimize the utilitarian objective function, which is simply the sum of all agents valuations.",
                "Unfortunately, some objective functions are not utilitarian; even for those problems with a utilitarian objective function, sometimes it is impossible to find the optimal output in polynomial time unless P=NP.",
                "Some mechanisms other than VCG mechanism are needed to address these issues.",
                "Archer and Tardos [2] studied a scheduling problem where it is NP-Hard to find the optimal output.",
                "They pointed out that a certain monotonicity property of the output work load is a necessary and sufficient condition for the existence of a truthful mechanism for their scheduling problem.",
                "Auletta et al. [3] studied a similar scheduling problem.",
                "They provided a family of deterministic truthful (2 + )-approximation mechanisms for any fixed number of machines and several (1 + )-truthful mechanisms for some NP-hard restrictions of their scheduling problem.",
                "Lehmann et al. [12] studied the single-minded combinatorial auction and gave a√ m-approximation truthful mechanism, where m is the number of goods.",
                "They also pointed out that a certain monotonicity in the allocation rule can lead to a truthful mechanism.",
                "The work of Mualem and Nisan [13] is the closest in spirit to our work.",
                "They characterized all truthful mechanisms based on a certain monotonicity property in a single-minded auction setting.",
                "They also showed how to used MAX and IF-THEN-ELSE to combine outputs from subproblems.",
                "As shown in this paper, the MAX and IF-THEN-ELSE combinations are special cases of the composition-based techniques that we present in this paper for computing the payments in polynomial time under mild assumptions.",
                "More generally, we study how to design truthful mechanisms for binary demand games where the allocation of an agent is either selected or not selected.",
                "We also assume that the valuations 213 of agents are uncorrelated, i.e., the valuation of an agent only depends on its own allocation and type.",
                "Recall that a mechanism M = (O, P) consists of two parts, an allocation rule O and a payment scheme P. Previously, it is often assumed that there is an objective function g and an allocation rule O, that either optimizes g exactly or approximately.",
                "In contrast to the VCG mechanisms, we do not require that the allocation should optimize the objective function.",
                "In fact, we do not even require the existence of an objective function.",
                "Given any allocation rule O for a binary <br>demand game</br>, we showed that a truthful mechanism M = (O, P) exists for the game if and only if O satisfies a certain monotonicity property.",
                "The monotonicity property only guarantees the existence of a payment scheme P such that (O, P) is truthful.",
                "We complement this existence theorem with a general framework to design such a payment scheme P. Furthermore, we present general techniques to compute the payment when the output is a composition of the outputs of subgames through the operators or and and; through round-based combinations; or through intermediate results, which may be themselves computed from other subproblems.",
                "The remainder of the paper is organized as follows.",
                "In Section 2, we discuss preliminaries and previous works, define binary demand games and discuss the basic assumptions about binary demand games.",
                "In Section 3, we show that O satisfying a certain monotonicity property is a necessary and sufficient condition for the existence of a truthful mechanism M = (O, P).",
                "A framework is then proposed in Section 4 to compute the payment P in polynomial time for several types of allocation rules O.",
                "In Section 5, we provide several examples to demonstrate the effectiveness of our general framework.",
                "We conclude our paper in Section 6 with some possible future directions. 2.",
                "PRELIMINARIES 2.1 Mechanism Design As usually done in the literatures about the designing of algorithms or protocols with inputs from individual agents, we adopt the assumption in neoclassic economics that all agents are rational, i.e., they respond to well-defined incentives and will deviate from the protocol only if the deviation improves their gain.",
                "A standard model for mechanism design is as follows.",
                "There are n agents 1, . . . , n and each agent i has some private information ti, called its type, only known to itself.",
                "For example, the type ti can be the cost that agent i incurs for forwarding a packet in a network or can be a payment that the agent is willing to pay for a good in an auction.",
                "The agents types define the type vector t = (t1, t2, . . . , tn).",
                "Each agent i has a set of strategies Ai from which it can choose.",
                "For each input vector a = (a1, . . . , an) where agent i plays strategy ai ∈ Ai, the mechanism M = (O, P) computes an output o = O(a) and a payment vector p(a) = (p1(a), . . . , pn(a)).",
                "Here the payment pi(·) is the money given to agent i and depends on the strategies used by the agents.",
                "A game is defined as G = (S, M), where S is the setting for the game G. Here, S consists the parameters of the game that are set before the game starts and do not depend on the players strategies.",
                "For example, in a unicast routing game [14], the setting consists of the topology of the network, the source node and the destination node.",
                "Throughout this paper, unless explicitly mentioned otherwise, the setting S of the game is fixed and we are only interested in how to design P for a given allocation rule O.",
                "A valuation function v(ti, o) assigns a monetary amount to agent i for each possible output o.",
                "Everything about a game S, M , including the setting S, the allocation rule O and the payment scheme P, is public knowledge except the agent is actual type ti, which is private information to agent i.",
                "Let ui(ti, o) denote the utility of agent i at the outcome of the game o, given its preferences ti.",
                "Here, following a common assumption in the literature, we assume the utility for agent i is quasi-linear, i.e., ui(ti, o) = v(ti, o) + Pi(a).",
                "Let a|i ai = (a1, · · · , ai−1, ai, ai+1, · · · , an), i.e., each agent j = i plays an action aj except that the agent i plays ai.",
                "Let a−i = (a1, · · · , ai−1, ai+1, · · · , an) denote the actions of all agents except i.",
                "Sometimes, we write (a−i, bi) as a|i bi.",
                "An action ai is called dominant for i if it (weakly) maximizes the utility of i for all possible strategies b−i of other agents, i.e., ui(ti, O(b−i, ai)) ≥ ui(ti, O(b−i, ai)) for all ai = ai and b−i.",
                "A direct-revelation mechanism is a mechanism in which the only actions available to each agent are to report its private type either truthfully or falsely to the mechanism.",
                "An incentive compatible (IC) mechanism is a direct-revelation mechanism in which if an agent reports its type ti truthfully, then it will maximize its utility.",
                "Then, in a direct-revelation mechanism satisfying IC, the payment scheme should satisfy the property that, for each agent i, v(ti, O(t)) + pi(t) ≥ v(ti, O(t|i ti)) + pi(t|i ti).",
                "Another common requirement in the literature for mechanism design is so called individual rationality or voluntary participation: the agents utility of participating in the output of the mechanism is not less than the utility of the agent of not participating.",
                "A direct-revelation mechanism is strategproof if it satisfies both IC and IR properties.",
                "Arguably the most important positive result in mechanism design is the generalized Vickrey-Clarke-Groves (VCG) mechanism by Vickrey [21], Clarke [5], and Groves [11].",
                "The VCG mechanism applies to (affine) maximization problems where the objective function is utilitarian g(o, t) = P i v(ti, o) (i.e., the sum of all agents valuations) and the set of possible outputs is assumed to be finite.",
                "A direct revelation mechanism M = (O(t), P(t)) belongs to the VCG family if (1) the allocation O(t) maximizesP i v(ti, o), and (2) the payment to agent i is pi(t) = P j=i vj(tj, O(t))+ hi (t−i), where hi () is an arbitrary function of t−i.",
                "Under mild assumptions, VCG mechanisms are the only truthful implementations for utilitarian problems [10].",
                "The allocation rule of a VCG mechanism is required to maximize the objective function in the range of the allocation function.",
                "This makes the mechanism computationally intractable in many cases.",
                "Furthermore, replacing an optimal algorithm for computing the output with an approximation algorithm usually leads to untruthful mechanisms if a VCG payment scheme is used.",
                "In this paper, we study how to design a truthful mechanism that does not optimize a utilitarian objective function. 2.2 Binary Demand Games A binary <br>demand game</br> is a game G = (S, M), where M = (O, P) and the range of O is {0, 1}n .",
                "In other words, the output is a n-tuple vector O(t) = (O1(t), O2(t), . . . , On(t)), where Oi(t) = 1 (respectively, 0) means that agent i is (respectively, is not) selected.",
                "Examples of binary demand games include: unicast [14, 22, 9] and multicast [23, 24, 8] (generally subgraph construction by selecting some links/nodes to satisfy some property), facility location [7], and a certain auction [12, 2, 13].",
                "Hereafter, we make the following further assumptions. 1.",
                "The valuation of the agents are not correlated, i.e., v(ti, o) is a function of v(ti, oi) only is denoted as v(ti, oi). 2.",
                "The valuation v(ti, oi) is a publicly known value and is normalized to 0.",
                "This assumption is needed to guarantee the IR property.",
                "Thus, throughout his paper, we only consider these direct-revelation mechanisms in which every agent only needs to reveal its valuation vi = v(ti, 1). 214 Notice that in applications where agents providing service and receiving payment, e.g., unicast and job scheduling, the valuation vi of an agent i is usually negative.",
                "For the convenience of presentation, we define the cost of agent as ci = −v(ti, 1), i.e., it costs agent i ci to provide the service.",
                "Throughout this paper, we will use ci instead of vi in our analysis.",
                "All our results can apply to the case where the agents receive the service rather than provide by setting ci to negative, as in auction.",
                "In a binary <br>demand game</br>, if we want to optimize an objective function g(o, t), then we call it a binary optimization <br>demand game</br>.",
                "The main differences between the binary demand games and those problems that can be solved by VCG mechanisms are: 1.",
                "The objective function is utilitarian (or affine maximization problem) for a problem solvable by VCG while there is no restriction on the objective function for a binary <br>demand game</br>. 2.",
                "The allocation rule O studied here does not necessarily optimize an objective function, while a VCG mechanism only uses the output that optimizes the objective function.",
                "We even do not require the existence of an objective function. 3.",
                "We assume that the agents valuations are not correlated in a binary <br>demand game</br>, while the agents valuations may be correlated in a VCG mechanism.",
                "In this paper, we assume for technical convenience that the objective function g(o, c), if exists, is continuous with respect to the cost ci, but most of our results are directly applicable to the discrete case without any modification. 2.3 Previous Work Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, each agent i (1 ≤ i ≤ n) only wants to buy a subset Si ⊆ S with private price ci.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "In [12], it is assumed that the set of goods allocated to an agent i is either Si or ∅, which is known as exactness.",
                "Lehmann et al. gave a greedy round-based allocation algorithm, based on the rank ai |Si|1/2 , that has an approximation ratio √ m, where m is the number of goods in S. Based on the approximation algorithm, they gave a truthful payment scheme.",
                "For an allocation rule satisfying (1) exactness: the set of goods allocated to an agent i is either Si or ∅; (2) monotonicity: proposing more money for fewer goods cannot cause a bidder to lose its bid, they proposed a truthful payment scheme as follows: (1) charge a winning bidder a certain amount that does not depend on its own bidding; (2) charge a losing bidder 0.",
                "Notice the assumption of exactness reveals that the single minded auction is indeed a binary <br>demand game</br>.",
                "Their payment scheme inspired our payment scheme for binary <br>demand game</br>.",
                "In [1], Archer et al. studied the combinatorial auctions where multiple copies of many different items are on sale, and each bidder i desires only one subset Si.",
                "They devised a randomized rounding method that is incentive compatible and gave a truthful mechanism for combinatorial auctions with single parameter agents that approximately maximizes the social value of the auction.",
                "As they pointed out, their method is strongly truthful in sense that it is truthful with high probability 1 − , where is an error probability.",
                "On the contrary, in this paper, we study how to design a deterministic mechanism that is truthful based on some given allocation rules.",
                "In [2], Archer and Tardos showed how to design truthful mechanisms for several combinatorial problems where each agents private information is naturally expressed by a single positive real number, which will always be the cost incurred per unit load.",
                "The mechanisms output could be arbitrary real number but their valuation is a quasi-linear function t · w, where t is the private per unit cost and w is the work load.",
                "Archer and Tardos characterized that all truthful mechanism should have decreasing work curves w and that the truthful payment should be Pi(bi) = Pi(0) + biwi(bi) − R bi 0 wi(u)du Using this model, Archer and Tardos designed truthful mechanisms for several scheduling related problems, including minimizing the span, maximizing flow and minimizing the weighted sum of completion time problems.",
                "Notice when the load of the problems is w = {0, 1}, it is indeed a binary <br>demand game</br>.",
                "If we apply their characterization of the truthful mechanism, their decreasing work curves w implies exactly the monotonicity property of the output.",
                "But notice that their proof is heavily based on the assumption that the output is a continuous function of the cost, thus their conclusion cant directly apply to binary demand games.",
                "The paper of Ahuva Mualem and Noam Nisan [13] is closest in spirit to our work.",
                "They clearly stated that we only discussed a limited class of bidders, single minded bidders, that was introduced by [12].",
                "They proved that all truthful mechanisms should have a monotonicity output and their payment scheme is based on the cut value.",
                "With a simple generalization, we get our conclusion for general binary <br>demand game</br>.",
                "They proposed several combination methods including MAX, IF-THEN-ELSE construction to perform partial search.",
                "All of their methods required the welfare function associated with the output satisfying bitonic property.",
                "Distinction between our contributions and previous results: It has been shown in [2, 6, 12, 13] that for the single minded combinatorial auction, there exists a payment scheme which results in a truthful mechanism if the allocation rule satisfies a certain monotonicity property.",
                "Theorem 4 also depends on the monotonicity property, but it is applicable to a broader setting than the single minded combinatorial auction.",
                "In addition, the binary <br>demand game</br> studied here is different from the traditional packing IPs: we only require that the allocation to each agent is binary and the allocation rule satisfies a certain monotonicity property; we do not put any restrictions on the objective function.",
                "Furthermore, the main focus of this paper is to design some general techniques to find the truthful payment scheme for a given allocation rule O satisfying a certain monotonicity property. 3.",
                "GENERAL APPROACHES 3.1 Properties of Strategyproof Mechanisms We discuss several properties that mechanisms need to satisfy in order to be truthful.",
                "THEOREM 1.",
                "If a mechanism M = (O, P) satisfies IC, then ∀i, if Oi(t|i ti1 ) = Oi(t|i ti2 ), then pi(t|i ti1 ) = pi(t|i ti2 ).",
                "COROLLARY 2.",
                "For any strategy-proof mechanism for a binary <br>demand game</br> G with setting S, if we fix the cost c−i of all agents other than i, the payment to agent i is a constant p1 i if Oi(c) = 1, and it is another constant p0 i if Oi(c) = 0.",
                "THEOREM 3.",
                "Fixed the setting S for a binary <br>demand game</br>, if mechanism M = (O, P) satisfies IC, then mechanism M = (O, P ) with the same output method O and pi(c) = pi(c) − δi(c−i) for any function δi(c−i) also satisfies IC.",
                "The proofs of above theorems are straightforward and thus omitted due to space limit.",
                "This theorem implies that for the binary demand games we can always normalize the payment to an agent i such that the payment to the agent is 0 when it is not selected.",
                "Hereafter, we will only consider normalized payment schemes. 215 3.2 Existence of Strategyproof Mechanisms Notice, given the setting S, a mechanism design problem is composed of two parts: the allocation rule O and a payment scheme P. In this paper, given an allocation rule O we focus our attention on how to design a truthful payment scheme based on O.",
                "Given an allocation rule O for a binary <br>demand game</br>, we first present a sufficient and necessary condition for the existence of a truthful payment scheme P. DEFINITION 1 (MONOTONE NON-INCREASING PROPERTY (MP)).",
                "An output method O is said to satisfy the monotone non-increasing property if for every agent i and two of its possible costs ci1 < ci2 , Oi(c|i ci2 ) ≤ Oi(c|i ci1 ).",
                "This definition is not restricted only to binary demand games.",
                "For binary demand games, this definition implies that if Oi(c|i ci2 ) = 1 then Oi(c|i ci1 ) = 1.",
                "THEOREM 4.",
                "Fix the setting S, c−i in a binary <br>demand game</br> G with the allocation rule O, the following three conditions are equivalent: 1.",
                "There exists a value κi(O, c−i)(which we will call a cut value, such that Oi(c) = 1 if ci < κi(O, c−i) and Oi(c) = 0 if ci > κi(O, c−i).",
                "When ci = κi(O, c−i), Oi(c) can be either 0 or 1 depending on the tie-breaker of the allocation rule O. Hereafter, we will not consider the tie-breaker scenario in our proofs. 2.",
                "The allocation rule O satisfies MP. 3.",
                "There exists a truthful payment scheme P for this binary <br>demand game</br>.",
                "PROOF.",
                "The proof that Condition 2 implies Condition is straightforward and is omitted here.",
                "We then show Condition 3 implies Condition 2.",
                "The proof of this is similar to a proof in [13].",
                "To prove this direction, we assume there exists an agent i and two valuation vectors c|i ci1 and c|i ci2 , where ci1 < ci2 , Oi(c|i ci2 ) = 1 and Oi(c|i ci1 ) = 0.",
                "From corollary 2, we know that pi(c|i ci1 ) = p0 i and pi(c|i ci2 ) = p1 i .",
                "Now fix c−i, the utility for i when ci = ci1 is ui(ci1 ) = p0 i .",
                "When agent i lies its valuation to ci2 , its utility is p1 i − ci1 .",
                "Since M = (O, P) is truthful, we have p0 i > p1 i − ci1 .",
                "Now consider the scenario when the actual valuation of agent i is ci = ci2 .",
                "Its utility is p1 i − ci2 when it reports its true valuation.",
                "Similarly, if it lies its valuation to ci1 , its utility is p0 i .",
                "Since M = (O, P) is truthful, we have p0 i < p1 i − ci2 .",
                "Consequently, we have p1 i −ci2 > p0 i > p1 i −ci1 .",
                "This inequality implies that ci1 > ci2 , which is a contradiction.",
                "We then show Condition 1 implies Condition 3.",
                "We prove this by constructing a payment scheme and proving that this payment scheme is truthful.",
                "The payment scheme is: If Oi(c) = 1, then agent i gets payment pi(c) = κi(O, c−i); else it gets payment pi(c) = 0.",
                "From condition 1, if Oi(c) = 1 then ci > κi(O, c−i).",
                "Thus, its utility is κi(O, c−i) − ci > 0, which implies that the payment scheme satisfies the IR.",
                "In the following we prove that this payment scheme also satisfies IC property.",
                "There are two cases here.",
                "Case 1: ci < κ(O, c−i).",
                "In this case, when i declares its true cost ci, its utility is κi(O, c−i) − ci > 0.",
                "Now consider the situation when i declares a cost di = ci.",
                "If di < κi(O, c−i), then i gets the same payment and utility since it is still selected.",
                "If di > κi(O, c−i), then its utility becomes 0 since it is not selected anymore.",
                "Thus, it has no incentive to lie in this case.",
                "Case 2: ci ≥ κ(O, c−i).",
                "In this case, when i reveals its true valuation, its payment is 0 and the utility is 0.",
                "Now consider the situation when i declares a valuation di = ci.",
                "If di > κi(O, c−i), then i gets the same payment and utility since it is still not selected.",
                "If di ≤ κi(O, c−i), then its utility becomes κi(O, c−i) − ci ≤ 0 since it is selected now.",
                "Thus, it has no incentive to lie.",
                "The equivalence of the monotonicity property of the allocation rule O and the existence of a truthful mechanism using O can be extended to games beyond binary demand games.",
                "The details are omitted here due to space limit.",
                "We now summarize the process to design a truthful payment scheme for a binary <br>demand game</br> based on an output method O.",
                "General Framework 1 Truthful mechanism design for a binary <br>demand game</br> Stage 1: Check whether the allocation rule O satisfies MP.",
                "If it does not, then there is no payment scheme P such that mechanism M = (O, P) is truthful.",
                "Otherwise, define the payment scheme P as follows.",
                "Stage 2: Based on the allocation rule O, find the cut value κi(O, c−i) for agent i such that Oi(c|i di) = 1 when di < κi(O, c−i), and Oi(c|i di) = 0 when di > κi(O, c−i).",
                "Stage 3: The payment for agent i is 0 if Oi(c) = 0; the payment is κi(O, c−i) if Oi(c) = 1.",
                "THEOREM 5.",
                "The payment defined by our general framework is minimum among all truthful payment schemes using O as output. 4.",
                "COMPUTING CUT VALUE FUNCTIONS To find the truthful payment scheme by using General Framework 1, the most difficult stage seems to be the stage 2.",
                "Notice that binary search does not work generally since the valuations of agents may be continuous.",
                "We give some general techniques that can help with finding the cut value function under certain circumstances.",
                "Our basic approach is as follows.",
                "First, we decompose the allocation rule into several allocation rules.",
                "Next find the cut value function for each of these new allocation rules.",
                "Then, we compute the original cut value function by combining these cut value functions of the new allocation rules. 4.1 Simple Combinations In this subsection, we introduce techniques to compute the cut value function by combining multiple allocation rules with conjunctions or disconjunctions.",
                "For simplicity, given an allocation rule O, we will use κ(O, c) to denote a n-tuple vector (κ1(O, c−1), κ2(O, c−2), . . . , κn(O, c−n)).",
                "Here, κi(O, c−i) is the cut value for agent i when the allocation rule is O and the costs c−i of all other agents are fixed.",
                "THEOREM 6.",
                "With a fixed setting S of a binary <br>demand game</br>, assume that there are m allocation rules O1 , O2 , · · · , Om satisfying the monotonicity property, and κ(Oi , c) is the cut value vector for Oi .",
                "Then the allocation rule O(c) = Wm i=1 Oi (c) satisfies the monotonicity property.",
                "Moreover, the cut value for O is κ(O, c) = maxm i=1{κ(Oi , c)} Here κ(O, c) = maxm i=1{κ(Oi , c)} means, ∀j ∈ [1, n], κj(O, c−j) = maxm i=1{κj(Oi , c−j)} and O(c) =Wm i=1 Oi (c) means, ∀j ∈ [1, n], Oj(c) = O1 j (c) ∨ O2 j (c) ∨ · · · ∨ Om j (c).",
                "PROOF.",
                "Assume that ci > ci and Oi(c) = 1.",
                "Without loss of generality, we assume that Ok i (c) = 1 for some k, 1 ≤ k ≤ m. From the assumption that Ok i (c) satisfies MP, we obtain that 216 Ok i (c|i ci) = 1.",
                "Thus, Oi(c|i ci) = Wm j=1 Oj (c) = 1.",
                "This proves that O(c) satisfies MP.",
                "The correctness of the cut value function follows directly from Theorem 4.",
                "Many algorithms indeed fall into this category.",
                "To demonstrate the usefulness of Theorem 6, we discuss a concrete example here.",
                "In a network, sometimes we want to deliver a packet to a set of nodes instead of one.",
                "This problem is known as multicast.",
                "The most commonly used structure in multicast routing is so called shortest path tree (SPT).",
                "Consider a network G = (V, E, c), where V is the set of nodes, and vector c is the actual cost of the nodes forwarding the data.",
                "Assume that the source node is s and the receivers are Q ⊂ V .",
                "For each receiver qi ∈ Q, we compute the shortest path (least cost path), denoted by LCP(s, qi, d), from the source s to qi under the reported cost profile d. The union of all such shortest paths forms the shortest path tree.",
                "We then use General Framework 1 to design the truthful payment scheme P when the SPT structure is used as the output for multicast, i.e., we design a mechanism M = (SPT, P).",
                "Notice that VCG mechanisms cannot be applied here since SPT is not an affine maximization.",
                "We define LCP(s,qi) as the allocation corresponds to the path LCP(s, qi, d), i.e., LCP (s,qi) k (d) = 1 if and only if node vk is in LCP(s, qi, d).",
                "Then the output SPT is defined as W qi∈Q LCP(s,qi) .",
                "In other words, SPTk(d) = 1 if and only if qk is selected in some LCP(s, qi, d).",
                "The shortest path allocation rule is a utilitarian and satisfies MP.",
                "Thus, from Theorem 6, SPT also satisfies MP, and the cut value function vector for SPT can be calculated as κ(SPT, c) = maxqi∈Q κ(LCP(s,qi) , c), where κ(LCP(s,qi) , c) is the cut value function vector for the shortest path LCP(s, qi, c).",
                "Consequently, the payment scheme above is truthful and the minimum among all truthful payment schemes when the allocation rule is SPT.",
                "THEOREM 7.",
                "Fixed the setting S of a binary <br>demand game</br>, assume that there are m output methods O1 , O2 , · · · , Om satisfying MP, and κ(Oi , c) are the cut value functions respectively for Oi where i = 1, 2, · · · , m. Then the allocation rule O(c) =Vm i=1 Oi (c) satisfies MP.",
                "Moreover, the cut value function for O is κ(O, c) = minm i=1{κ(Oi , c)}.",
                "We show that our simple combination generalizes the IF-THENELSE function defined in [13].",
                "For an agent i, assume that there are two allocation rules O1 and O2 satisfying MP.",
                "Let κi(O1 , c−i), κi(O2 , c−i) be the cut value functions for O1 , O2 respectively.",
                "Then the IF-THEN-ELSE function Oi(c) is actually Oi(c) = [(ci ≤ κi(O1 , c−i) + δ1(c−i)) ∧ O2 (c−i, ci)] ∨ (ci < κi(O1 , c−i) − δ2(c−i)) where δ1(c−i) and δ2(c−i) are two positive functions.",
                "By applying Theorems 6 and 7, we know that the allocation rule O satisfies MP and consequently κi(O, c−i) = max{min(κi(O1 , c−i)+ δ1(c−i), κi(O2 , c−i)), κi(O1 , c−i) − δ2(c−i))}. 4.2 Round-Based Allocations Some approximation algorithms are round-based, where each round of an algorithm selects some agents and updates the setting and the cost profile if necessary.",
                "For example, several approximation algorithms for minimum weight vertex cover [19], maximum weight independent set, minimum weight set cover [4], and minimum weight Steiner [18] tree fall into this category.",
                "As an example, we discuss the minimum weighted vertex cover problem (MWVC) [16, 15] to show how to compute the cut value for a round-based output.",
                "Given a graph G = (V, E), where the nodes v1, v2, . . . , vn are the agents and each agent vi has a weight ci, we want to find a node set V ⊆ V such that for every edge (u, v) ∈ E at least one of u and v is in V .",
                "Such V is called a vertex cover of G. The valuation of a node i is −ci if it is selected; otherwise its valuation is 0.",
                "For a subset of nodes V ∈ V , we define its weight as c(V ) = P i∈V ci.",
                "We want to find a vertex cover with the minimum weight.",
                "Hence, the objective function to be implemented is utilitarian.",
                "To use the VCG mechanism, we need to find the vertex cover with the minimum weight, which is NP-hard [16].",
                "Since we are interested in mechanisms that can be computed in polynomial time, we must use polynomial-time computable allocation rules.",
                "Many algorithms have been proposed in the literature to approximate the optimal solution.",
                "In this paper, we use a 2-approximation algorithm given in [16].",
                "For the sake of completeness, we briefly review this algorithm here.",
                "The algorithm is round-based.",
                "Each round selects some vertices and discards some vertices.",
                "For each node i, w(i) is initialized to its weight ci, and when w(i) drops to 0, i is included in the vertex cover.",
                "To make the presentation clear, we say an edge (i1, j1) is lexicographically smaller than edge (i2, j2) if (1) min(i1, j1) < min(i2, j2), or (2) min(i1, j1) = min(i2, j2) and max(i1, j1) < max(i2, j2).",
                "Algorithm 2 Approximate Minimum Weighted Vertex Cover Input: A node weighted graph G = (V, E, c).",
                "Output: A vertex cover V . 1: Set V = ∅.",
                "For each i ∈ V , set w(i) = ci. 2: while V is not a vertex cover do 3: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 4: Let m = min(w(i), w(j)). 5: Update w(i) to w(i) − m and w(j) to w(j) − m. 6: If w(i) = 0, add i to V .",
                "If w(j) = 0, add j to V .",
                "Notice, selecting an edge using the lexicographic order is crutial to guarantee the monotonicity property.",
                "Algorithm 2 outputs a vertex cover V whose weight is within 2 times of the optimum.",
                "For convenience, we use VC(c) to denote the vertex cover computed by Algorithm 2 when the cost vector of vertices is c. Below we generalize Algorithm 2 to a more general scenario.",
                "Typically, a round-based output can be characterized as follows (Algorithm 3).",
                "DEFINITION 2.",
                "An updating rule Ur is said to be crossingindependent if, for any agent i not selected in round r, (1) Sr+1 and cr+1 −i do not depend on cr j (2) for fixed cr −i, cr i1 ≤ cr i2 implies that cr+1 i1 ≤ cr+1 i2 .",
                "We have the following theorem about the existence of a truthful payment using a round based allocation rule A. THEOREM 8.",
                "A round-based output A, with the framework defined in Algorithm 3, satisfies MP if the output methods Or satisfy MP and all updating rules Ur are crossing-independent.",
                "PROOF.",
                "Consider an agent i and fixed c−i.",
                "We prove that when an agent i is selected with cost ci, then it is also selected with cost di < ci.",
                "Assume that i is selected in round r with cost ci.",
                "Then under cost di, if agent i is selected in a round before r, our claim holds.",
                "Otherwise, consider in round r. Clearly, the setting Sr and the costs of all other agents are the same as what if agent i had cost ci since i is not selected in the previous rounds due to the crossindependent property.",
                "Since i is selected in round r with cost ci, i is also selected in round r with di < ci due to the reason that Or satisfies MP.",
                "This finishes the proof. 217 Algorithm 3 A General Round-Based Allocation Rule A 1: Set r = 0, c0 = c, and G0 = G initially. 2: repeat 3: Compute an output or using a deterministic algorithm Or : Sr × cr → {0, 1}n .",
                "Here Or , cr and Sr are allocation rule, cost vector and game setting in game Gr , respectively.",
                "Remark: Or is often a simple greedy algorithm such as selecting the agents that minimize some utilitarian function.",
                "For the example of vertex cover, Or will always select the light-weighted node on the lexicographically least uncovered edge (i, j). 4: Let r = r + 1.",
                "Update the game Gr−1 to obtain a new game Gr with setting Sr and cost vector cr according to some rule Ur : Or−1 × (Sr−1 , cr−1 ) → (Sr , cr ).",
                "Here we updates the cost and setting of the game.",
                "Remark: For the example of vertex cover, the updating rule will decrease the weight of vertices i and j by min(w(i), w(j)). 5: until a valid output is found 6: Return the union of the set of selected players of each round as the final output.",
                "For the example of vertex cover, it is the union of nodes selected in all rounds.",
                "Algorithm 4 Compute Cut Value for Round-Based Algorithms Input: A round-based output A, a game G1 = G, and a updating function vector U.",
                "Output: The cut value x for agent k. 1: Set r = 0 and ck = ζ.",
                "Recall that ζ is a value that can guarantee Ak = 0 when an agent reports the cost ζ. 2: repeat 3: Compute an output or using a deterministic algorithm based on setting Sr using allocation rule Or : Sr ×cr → {0, 1}n . 4: Find the cut value for agent k based on the allocation rule Or for costs cr −k.",
                "Let r = κk(Or , cr −k) be the cut value. 5: Set r = r + 1 and obtain a new game Gr from Gr−1 and or according to the updating rule Ur . 6: Let cr be the new cost vector for game Gr . 7: until a valid output is found. 8: Let gi(x) be the cost of ci k when the original cost vector is c|k x. 9: Find the minimum value x such that 8 >>>>>< >>>>>: g1(x) ≥ 1; g2(x) ≥ 2; ... gt−1(x) ≥ t−1; gt(x) ≥ t. Here, t is the total number of rounds. 10: Output the value x as the cut value.",
                "If the round-based output satisfies monotonicity property, the cut-value always exists.",
                "We then show how to find the cut value for a selected agent k in Algorithm 4.",
                "The correctness of Algorithm 4 is straightforward.",
                "To compute the cut value, we assume that (1) the cut value r for each round r can be computed in polynomial time; (2) we can solve the equation gr(x) = r to find x in polynomial time when the cost vector c−i and b are given.",
                "Now we consider the vertex cover problem.",
                "For each round r, we select a vertex with the least weight and that is incident on the lexicographically least uncovered edge.",
                "The output satisfies MP.",
                "For agent i, we update its cost to cr i − cr j iff edge (i, j) is selected.",
                "It is easy to verify this updating rule is crossing-independent, thus we can apply Algorithm 4 to compute the cut value for the set cover game as shown in Algorithm 5.",
                "Algorithm 5 Compute Cut Value for MVC.",
                "Input: A node weighted graph G = (V, E, c) and a node k selected by Algorithm 2.",
                "Output: The cut value κk(V C, c−k). 1: For each i ∈ V , set w(i) = ci. 2: Set w(k) = ∞, pk = 0 and V = ∅. 3: while V is not a vertex cover do 4: Pick an uncovered edge (i, j) with the least lexicographic order among all uncovered edges. 5: Set m = min(w(i), w(j)). 6: Update w(i) = w(i) − m and w(j) = w(j) − m. 7: If w(i) = 0, add i to V ; else add j to V . 8: If i == k or j == k then set pk = pk + m. 9: Output pk as the cut value κk(V C, c−k). 4.3 Complex Combinations In subsection 4.1, we discussed how to find the cut value function when the output of the binary <br>demand game</br> is a simple combination of some outputs, whose cut values can be computed through other means (typically VCG).",
                "However, some algorithms cannot be decomposed in the way described in subsection 4.1.",
                "Next we present a more complex way to combine allocation rules, and as we may expected, the way to find the cut value is also more complicated.",
                "Assume that there are n agents 1 ≤ i ≤ n with cost vector c, and there are m binary demand games Gi with objective functions fi(o, c), setting Si and allocation rule ψi where i = 1, 2, · · · , m. There is another binary <br>demand game</br> with setting S and allocation rule O, whose input is a cost vector d = (d1, d2, · · · , dm).",
                "Let f be the function vector (f1, f2, · · · , fm), ψ be the allocation rule vector (ψ1 , ψ2 , · · · , ψm ) and ∫ be the setting vector (S1, S2, · · · , Sm).",
                "For notation simplicity, we define Fi(c) = fi(ψi (c), c), for each 1 ≤ i ≤ m, and F(c) = (F1(c), F2(c), · · · , Fm(c)).",
                "Let us see a concrete example of these combinations.",
                "Consider a link weighted graph G = (V, E, c), and a subset of q nodes Q ⊆ V .",
                "The Steiner tree problem is to find a set of links with minimum total cost to connect Q.",
                "One way to find an approximation of the Steiner tree is as follows: (1) we build a virtual complete graph H using Q as its vertices, and the cost of each edge (i, j) is the cost of LCP(i, j, c) in graph G; (2) build the minimum spanning tree of H, denoted as MST(H); (3) an edge of G is selected iff it is selected in some LCP(i, j, c) and edge (i, j) of H is selected to MST(H).",
                "In this game, we define q(q − 1)/2 games Gi,j, where i, j ∈ Q, with objective functions fi,j(o, c) being the minimum cost of 218 connecting i and j in graph G, setting Si being the original graph G and allocation rule is LCP(i, j, c).",
                "The game G corresponds to the MST game on graph H. The cost of the pair-wise q(q − 1)/2 shortest paths defines the input vector d = (d1, d2, · · · , dm) for game MST.",
                "More details will be given in Section 5.2.",
                "DEFINITION 3.",
                "Given an allocation rule O and setting S, an objective function vector f, an allocation rule vector ψ and setting vector ∫, we define a compound binary <br>demand game</br> with setting S and output O ◦ F as (O ◦ F)i(c) = Wm j=1(Oj(F(c)) ∧ ψj i (c)).",
                "The allocation rule of the above definition can be interpreted as follows.",
                "An agent i is selected if and only if there is a j such that (1) i is selected in ψj (c), and (2) the allocation rule O will select index j under cost profile F(c).",
                "For simplicity, we will use O ◦ F to denote the output of this compound binary <br>demand game</br>.",
                "Notice that a truthful payment scheme using O ◦ F as output exists if and only if it satisfies the monotonicity property.",
                "To study when O ◦F satisfies MP, several necessary definitions are in order.",
                "DEFINITION 4.",
                "Function Monotonicity Property (FMP) Given an objective function g and an allocation rule O, a function H(c) = g(O(c), c) is said to satisfy the function monotonicity property, if, given fixed c−i, it satisfies: 1.",
                "When Oi(c) = 0, H(c) does not increase over ci. 2.",
                "When Oi(c) = 1, H(c) does not decrease over ci.",
                "DEFINITION 5.",
                "Strong Monotonicity Property (SMP) An allocation rule O is said to satisfy the strong monotonicity property if O satisfies MP, and for any agent i with Oi(c) = 1 and agent j = i, Oi(c|j cj) = 1 if cj ≥ cj or Oj(c|j cj) = 0.",
                "LEMMA 1.",
                "For a given allocation rule O satisfying SMP and cost vectors c, c with ci = ci, if Oi(c) = 1 and Oi(c ) = 0, then there must exist j = i such that cj < cj and Oj(c ) = 1.",
                "From the definition of the strong monotonicity property, we have Lemma 1 directly.",
                "We now can give a sufficient condition when O ◦ F satisfies the monotonicity property.",
                "THEOREM 9.",
                "If ∀i ∈ [1, m], Fi satisfies FMP, ψi satisfies MP, and the output O satisfies SMP, then O ◦ F satisfies MP.",
                "PROOF.",
                "Assuming for cost vector c we have (O ◦ F)i(c) = 1, we should prove for any cost vector c = c|i ci with ci < ci, (O ◦ F)i(c ) = 1.",
                "Noticing that (O ◦ F)i(c) = 1, without loss of generality, we assume that Ok(F(c)) = 1 and ψk i (c) = 1 for some index 1 ≤ k ≤ m. Now consider the output O with the cost vector F(c )|k Fk(c).",
                "There are two scenarios, which will be studied one by one as follows.",
                "One scenario is that index k is not chosen by the output function O.",
                "From Lemma 1, there must exist j = k such that Fj(c ) < Fj(c) (1) Oj(F(c )|k Fk(c)) = 1 (2) We then prove that agent i will be selected in the output ψj (c ), i.e., ψj i (c ) = 1.",
                "If it is not, since ψj (c) satisfies MP, we have ψj i (c) = ψj i (c ) = 0 from ci < ci.",
                "Since Fj satisfies FMP, we know Fj(c ) ≥ Fj(c), which is a contradiction to the inequality (1).",
                "Consequently, we have ψj i (c ) = 1.",
                "From Equation (2), the fact that index k is not selected by allocation rule O and the definition of SMP, we have Oj(F(c )) = 1, Thus, agent i is selected by O ◦ F because of Oj(F(c )) = 1 and ψj i (c ) = 1.",
                "The other scenario is that index k is chosen by the output function O.",
                "First, agent i is chosen in ψk (c ) since the output ψk (c) satisfies the monotonicity property and ci < ci and ψk i (c) = 1.",
                "Secondly, since the function Fk satisfies FMP, we know that Fk(c ) ≤ Fk(c).",
                "Remember that output O satisfies the SMP, thus we can obtain Ok(F(c )) = 1 from the fact that Ok(F(c )|k Fk(c)) = 1 and Fk(c ) ≤ Fk(c).",
                "Consequently, agent i will also be selected in the final output O ◦ F. This finishes our proof.",
                "This theorem implies that there is a cut value for the compound output O ◦ F. We then discuss how to find the cut value for this output.",
                "Below we will give an algorithm to calculate κi(O ◦ F) when (1) O satisfies SMP, (2) ψj satisfies MP, and (3) for fixed c−i, Fj(c) is a constant, say hj, when ψj i (c) = 0, and Fj(c) increases when ψj i (c) = 1.",
                "Notice that here hj can be easily computed by setting ci = ∞ since ψj satisfies the monotonicity property.",
                "When given i and fixed c−i, we define (Fi j )−1 (y) as the smallest x such that Fj(c|i x) = y.",
                "For simplicity, we denote (Fi j )−1 as F−1 j if no confusion is caused when i is a fixed agent.",
                "In this paper, we assume that given any y, we can find such x in polynomial time.",
                "Algorithm 6 Find Cut Value for Compound Method O ◦ F Input: allocation rule O, objective function vector F and inverse function vector F−1 = {F−1 1 , · · · , F−1 m }, allocation rule vector ψ and fixed c−i.",
                "Output: Cut value for agent i based on O ◦ F. 1: for 1 ≤ j ≤ m do 2: Compute the outputs ψj (ci). 3: Compute hj = Fj(c|i ∞). 4: Use h = (h1, h2, · · · , hm) as the input for the output function O. Denote τj = κj(O, h−j) as the cut value function of output O based on input h. 5: for 1 ≤ j ≤ m do 6: Set κi,j = F−1 j (min{τj, hj}). 7: The cut value for i is κi(O ◦ F, c−i) = maxm j=1 κi,j.",
                "THEOREM 10.",
                "Algorithm 6 computes the correct cut value for agent i based on the allocation rule O ◦ F. PROOF.",
                "In order to prove the correctness of the cut value function calculated by Algorithm 6, we prove the following two cases.",
                "For our convenience, we will use κi to represent κi(O ◦ F, c−i) if no confusion caused.",
                "First, if di < κi then (O ◦ F)i(c|i di) = 1.",
                "Without loss of generality, we assume that κi = κi,j for some j.",
                "Since function Fj satisfies FMP and ψj i (c|i di) = 1, we have Fj(c|i di) < Fj(κi).",
                "Notice di < κi,j, from the definition of κi,j = F−1 j (min{τj, hj}) we have (1) ψj i (c|i di) = 1, (2) Fj(c|i di) < τj due to the fact that Fj(x) is a non-decreasing function when j is selected.",
                "Thus, from the monotonicity property of O and τj is the cut value for output O, we have Oj(h|j Fj(c|i di)) = 1. (3) If Oj(F(c|i di)) = 1 then (O◦F)i(c|i di) = 1.",
                "Otherwise, since O satisfies SMP, Lemma 1 and equation 3 imply that there exists at least one index k such that Ok(F(c|i di)) = 1 and Fk(c|i di) < hk.",
                "Note Fk(c|i di) < hk implies that i is selected in ψk (c|i di) since hk = Fk(ci|i ∞).",
                "In other words, agent i is selected in O◦F. 219 Second, if di ≥ κi(O ◦ F, c−i) then (O ◦ F)i(c|i di) = 0.",
                "Assume for the sake of contradiction that (O ◦ F)i(c|i di) = 1.",
                "Then there exists an index 1 ≤ j ≤ m such that Oj(F(c|i di)) = 1 and ψj i (c|i di) = 1.",
                "Remember that hk ≥ Fk(c|i di) for any k. Thus, from the fact that O satisfies SMP, when changing the cost vector from F(c|i di) to h|j Fj(c|i di), we still have Oj(h|j Fj(c|i di)) = 1.",
                "This implies that Fj(c|i di) < τj.",
                "Combining the above inequality and the fact that Fj(c|i c|i di) < hj, we have Fj(c|i di) < min{hj, τj}.",
                "This implies di < F−1 j (min{hj, τj}) = κi,j < κi(O ◦ F, c−i). which is a contradiction.",
                "This finishes our proof.",
                "In most applications, the allocation rule ψj implements the objective function fj and fj is utilitarian.",
                "Thus, we can compute the inverse of F−1 j efficiently.",
                "Another issue is that it seems the conditions when we can apply Algorithm 6 are restrictive.",
                "However, lots of games in practice satisfy these properties and here we show how to deduct the MAX combination in [13].",
                "Assume A1 and A2 are two allocation rules for single minded combinatorial auction, then the combination MAX(A1, A2) returns the allocation with the larger welfare.",
                "If algorithm A1 and A2 satisfy MP and FMP, the operation max(x, y) which returns the larger element of x and y satisfies SMP.",
                "From Theorem 9 we obtain that combination MAX(A1, A2) also satisfies MP.",
                "Further, the cut value of the MAX combination can be found by Algorithm 6.",
                "As we will show in Section 5, the complex combination can apply to some more complicated problems. 5.",
                "CONCRETE EXAMPLES 5.1 Set Cover In the set cover problem, there is a set U of m elements needed to be covered, and each agent 1 ≤ i ≤ n can cover a subset of elements Si with a cost ci.",
                "Let S = {S1, S2, · · · , Sn} and c = (c1, c2, · · · , cn).",
                "We want to find a subset of agents D such that U ⊆ S i∈D Si.",
                "The selected subsets is called the set cover for U.",
                "The social efficiency of the output D is defined as P i∈D ci, which is the objective function to be minimized.",
                "Clearly, this is a utilitarian and thus VCG mechanism can be applied if we can find the subset of S that covers U with the minimum cost.",
                "It is well-known that finding the optimal solution is NP-hard.",
                "In [4], an algorithm of approximation ratio of Hm has been proposed and it has been proved that this is the best ratio possible for the set cover problem.",
                "For the completeness of presentation, we review their method here.",
                "Algorithm 7 Greedy Set Cover (GSC) Input: Agent is subset Si covered and cost ci. (1 ≤ i ≤ n).",
                "Output: A set of agents that can cover all elements. 1: Initialize r = 1, T0 = ∅, and R = ∅. 2: while R = U do 3: Find the set Sj with the minimum density cj |Sj −Tr| . 4: Set Tr+1 = Tr S Sj and R = R S j. 5: r = r + 1 6: Output R. Let GSC(S) be the sets selected by the Algorithm 7.Notice that the output set is a function of S and c. Some works assume that the type of an agent could be ci, i.e., Si is assumed to be a public knowledge.",
                "Here, we consider a more general case in which the type of an agent is (Si, ci).",
                "In other words, we assume that every agent i can not only lie about its cost ci but also can lie about the set Si.",
                "This problem now looks similar to the combinatorial auction with single minded bidder studied in [12], but with the following differences: in the set cover problem we want to cover all the elements and the sets chosen can have some overlap while in combinatorial auction the chosen sets are disjoint.",
                "We can show that the mechanism M = (GSC, PV CG ), using Algorithm 7 to find a set cover and apply VCG mechanism to compute the payment to the selected agents, is not truthful.",
                "Obviously, the set cover problem is a binary <br>demand game</br>.",
                "For the moment, we assume that agent i wont be able to lie about Si.",
                "We will drop this assumption later.",
                "We show how to design a truthful mechanism by applying our general framework. 1.",
                "Check the monotonicity property: The output of Algorithm 7 is a round-based output.",
                "Thus, for an agent i, we first focus on the output of one round r. In round r, if i is selected by Algorithm 7, then it has the minimum ratio ci |Si−Tr| among all remaining agents.",
                "Now consider the case when i lies its cost to ci < ci, obviously ci |Si−Tr| is still minimum among all remaining agents.",
                "Consequently, agent i is still selected in round r, which means the output of round r satisfies MP.",
                "Now we look into the updating rules.",
                "For every round, we only update the Tr+1 = Tr S Sj and R = R S j, which is obviously cross-independent.",
                "Thus, by applying Theorem 8, we know the output by Algorithm 7 satisfies MP. 2.",
                "Find the cut value: To calculate the cut value for agent i with fixed cost vector c−i, we follow the steps in Algorithm 4.",
                "First, we set ci = ∞ and apply Algorithm 7.",
                "Let ir be the agent selected in round r and T−i r+1 be the corresponding set.",
                "Then the cut value of round r is r = cir |Sir − T−i r | · |Si − T−i r |.",
                "Remember the updating rule only updates the game setting but not the cost of the agent, thus we have gr(x) = x ≥ r for 1 ≤ r ≤ t. Therefore, the final cut value for agent i is κi(GSC, c−i) = max r { cir |Sir − T−i r | · |Si − T−i r |} The payment to an agent i is κi if i is selected; otherwise its payment is 0.",
                "We now consider the scenario when agent i can lie about Si.",
                "Assume that agent i cannot lie upward, i.e., it can only report a set Si ⊆ Si.",
                "We argue that agent i will not lie about its elements Si.",
                "Notice that the cut value computed for round r is r = cir |Sir −T −i r | · |Si − T−i r |.",
                "Obviously |Si − T−i r | ≤ |Si − T−i r | for any Si ⊆ Si.",
                "Thus, lying its set as Si will not increase the cut value for each round.",
                "Thus lying about Si will not improve agent is utility. 5.2 Link Weighted Steiner Trees Consider any link weighted network G = (V, E, c), where E = {e1, e2, · · · , em} are the set of links and ci is the weight of the link ei.",
                "The link weighted Steiner tree problem is to find a tree rooted at source node s spanning a given set of nodes Q = {q1, q2, · · · , qk} ⊂ V .",
                "For simplicity, we assume that qi = vi, for 1 ≤ i ≤ k. Here the links are agents.",
                "The total cost of links in a graph H ⊆ G is called the weight of H, denoted as ω(H).",
                "It is NP-hard to find the minimum cost multicast tree when given an arbitrary link weighted 220 graph G [17, 20].",
                "The currently best polynomial time method has approximation ratio 1 + ln 3 2 [17].",
                "Here, we review and discuss the first approximation method by Takahashi and Matsuyama [20].",
                "Algorithm 8 Find LinkWeighted SteinerTree (LST) Input: Network G = (V, E, c) where c is the cost vector for link set E. Source node s and receiver set Q.",
                "Output: A tree LST rooted at s and spanned all receivers. 1: Set r = 1, G1 = G, Q1 = Q and s1 = s. 2: repeat 3: In graph Gr, find the receiver, say qi, that is closest to the source s, i.e., LCP(s, qi, c) has the least cost among the shortest paths from s to all receivers in Qr . 4: Select all links on LCP(s, qi, c) as relay links and set their cost to 0.",
                "The new graph is denoted as Gr+1. 5: Set tr as qi and Pr = LCP(s, qi, c). 6: Set Qr+1 = Qr \\qi and r = r + 1. 7: until all receivers are spanned.",
                "Hereafter, let LST(G) be the final tree constructed using the above method.",
                "It is shown in [24] that mechanism M = (LST, pV CG ) is not truthful, where pV CG is the payment calculated based on VCG mechanism.",
                "We then show how to design a truthful payment scheme using our general framework.",
                "Observe that the output Pr, for any round r, satisfies MP, and the update rule for every round satisfies crossing-independence.",
                "Thus, from Theorem 8, the roundbased output LST satisfies MP.",
                "In round r, the cut value for a link ei can be obtained by using the VCG mechanism.",
                "Now we set ci = ∞ and execute Algorithm 8.",
                "Let w−i r (ci) be the cost of the path Pr(ci) selected in the rth round and Πi r(ci) be the shortest path selected in round r if the cost of ci is temporarily set to −∞.",
                "Then the cut value for round r is r = wi r(c−i) − |Πi r(c−i)| where |Πi r(c−i)| is the cost of the path Πi r(c−i) excluding node vi.",
                "Using Algorithm 4, we obtain the final cut value for agent i: κi(LST, c−i) = maxr{ r}.",
                "Thus, the payment to a link ei is κi(LST, c−i) if its reported cost is di < κi(LST, d−i); otherwise, its payment is 0. 5.3 Virtual Minimal Spanning Trees To connect the given set of receivers to the source node, besides the Steiner tree constructed by the algorithms described before, a virtual minimum spanning tree is also often used.",
                "Assume that Q is the set of receivers, including the sender.",
                "Assume that the nodes in a node-weighted graph are all agents.",
                "The virtual minimum spanning tree is constructed as follows.",
                "Algorithm 9 Construct VMST 1: for all pairs of receivers qi, qj ∈ Q do 2: Calculate the least cost path LCP(qi, qj, d). 3: Construct a virtual complete link weighted graph K(d) using Q as its node set, where the link qiqj corresponds to the least cost path LCP(qi, qj, d), and its weight is w(qiqj) = |LCP(qi, qj, d)|. 4: Build the minimum spanning tree on K(d), denoted as V MST(d). 5: for every virtual link qiqj in V MST(d) do 6: Find the corresponding least cost path LCP(qi, qj, d) in the original network. 7: Mark the agents on LCP(qi, qj, d) selected.",
                "The mechanism M = (V MST, pV CG ) is not truthful [24], where the payment pV CG to a node is based on the VCG mechanism.",
                "We then show how to design a truthful mechanism based on the framework we described. 1.",
                "Check the monotonicity property: Remember that in the complete graph K(d), the weight of a link qiqj is |LCP(qi, qj, d)|.",
                "In other words, we implicitly defined |Q|(|Q| − 1)/2 functions fi,j, for all i < j and qi ∈ Q and qj ∈ Q, with fi,j(d) = |LCP(qi, qj, d)|.",
                "We can show that the function fi,j(d) = |LCP(qi, qj, d)| satisfies FMP, LCP satisfies MP, and the output MST satisfies SMP.",
                "From Theorem 9, the allocation rule VMST satisfies the monotonicity property. 2.",
                "Find the cut value: Notice VMST is the combination of MST and function fi,j, so cut value for VMST can be computed based on Algorithm 6 as follows. (a) Given a link weighted complete graph K(d) on Q, we should find the cut value function for edge ek = (qi, qj) based on MST.",
                "Given a spanning tree T and a pair of terminals p and q, clearly there is a unique path connecting them on T. We denote this path as ΠT (p, q), and the edge with the maximum length on this path as LE(p, q, T).",
                "Thus, the cut value can be represented as κk(MST, d) = LE(qi, qj, MST(d|k ∞)) (b) We find the value-cost function for LCP.",
                "Assume vk ∈ LCP(qi, qj, d), then the value-cost function is xk = yk − |LCPvk (qi, qj, d|k 0)|.",
                "Here, LCPvk (qi, qj, d) is the least cost path between qi and qj with node vk on this path. (c) Remove vk and calculate the value K(d|k ∞).",
                "Set h(i,j) = |LCP(qi, qj, d|∞ ))| for every pair of node i = j and let h = {h(i,j)} be the vector.",
                "Then it is easy to show that τ(i,j) = |LE(qi, qj, MST(h|(i,j) ∞))| is the cut value for output VMST.",
                "It easy to verify that min{h(i,j), τ(i,j)} = |LE(qi, qj, MST(h)|.",
                "Thus, we know κ (i,j) k (V MST, d) is |LE(qi, qj, MST(h)|− |LCPvk (qi, qj, d|k 0)|.",
                "The cut value for agent k is κk(V MST, d−k) = max0≤i,j≤r κij k (V MST, d−k). 3.",
                "We pay agent k κk(V MST, d−k) if and only if k is selected in V MST(d); else we pay it 0. 5.4 Combinatorial Auctions Lehmann et al. [12] studied how to design an efficient truthful mechanism for single-minded combinatorial auction.",
                "In a singleminded combinatorial auction, there is a set of items S to be sold and there is a set of agents 1 ≤ i ≤ n who wants to buy some of the items: agent i wants to buy a subset Si ⊆ S with maximum price mi.",
                "A single-minded bidder i declares a bid bi = Si, ai with Si ⊆ S and ai ∈ R+ .",
                "Two bids Si, ai and Sj, aj conflict if Si ∩ Sj = ∅.",
                "Given the bids b1, b2, · · · , bn, they gave a greedy round-based algorithm as follows.",
                "First the bids are sorted by some criterion ( ai |Si|1/2 is used in[12]) in an increasing order and let L be the list of sorted bids.",
                "The first bid is granted.",
                "Then the algorithm exams each bid of L in order and grants the bid if it does not conflict with any of the bids previously granted.",
                "If it does, it is denied.",
                "They proved that this greedy allocation scheme using criterion ai |Si|1/2 approximates the optimal allocation within a factor of √ m, where m is the number of goods in S. In the auction settings, we have ci = −ai.",
                "It is easy to verify the output of the greedy algorithm is a round-based output.",
                "Remember after bidder j is selected for round r, every bidder has conflict 221 with j will not be selected in the rounds after.",
                "This equals to update the cost of every bidder having conflict with j to 0, which satisfies crossing-independence.",
                "In addition, in any round, if bidder i is selected with ai then it will still be selected when it declares ai > ai.",
                "Thus, for every round, it satisfies MP and the cut value is |Si|1/2 · ajr |Sjr |1/2 where jr is the bidder selected in round r if we did not consider the agent i at all.",
                "Notice ajr |Sjr |1/2 does not increase when round r increases, so the final cut value is |Si|1/2 · aj |Sj |1/2 where bj is the first bid that has been denied but would have been selected were it not only for the presence of bidder i.",
                "Thus, the payment by agent i is |Si|1/2 · aj |Sj |1/2 if ai ≥ |Si|1/2 · aj |Sj |1/2 , and 0 otherwise.",
                "This payment scheme is exactly the same as the payment scheme in [12]. 6.",
                "CONCLUSIONS In this paper, we have studied how to design a truthful mechanism M = (O, P) for a given allocation rule O for a binary <br>demand game</br>.",
                "We first showed that the allocation rule O satisfying the MP is a necessary and sufficient condition for a truthful mechanism M to exist.",
                "We then formulate a general framework for designing payment P such that the mechanism M = (O, P) is truthful and computable in polynomial time.",
                "We further presented several general composition-based techniques to compute P efficiently for various allocation rules O.",
                "Several concrete examples were discussed to demonstrate our general framework for designing P and for composition-based techniques of computing P in polynomial time.",
                "In this paper, we have concentrated on how to compute P in polynomial time.",
                "Our algorithms do not necessarily have the optimal running time for computing P given O.",
                "It would be of interest to design algorithms to compute P in optimal time.",
                "We have made some progress in this research direction in [22] by providing an algorithm to compute the payments for unicast in a node weighted graph in optimal O(n log n + m) time.",
                "Another research direction is to design an approximation allocation rule O satisfying MP with a good approximation ratio for a given binary <br>demand game</br>.",
                "Many works [12, 13] in the mechanism design literature are in this direction.",
                "We point out here that the goal of this paper is not to design a better allocation rule for a problem, but to design an algorithm to compute the payments efficiently when O is given.",
                "It would be of significance to design allocation rules with good approximation ratios such that a given binary <br>demand game</br> has a computationally efficient payment scheme.",
                "In this paper, we have studied mechanism design for binary demand games.",
                "However, some problems cannot be directly formulated as binary demand games.",
                "The job scheduling problem in [2] is such an example.",
                "For this problem, a truthful payment scheme P exists for an allocation rule O if and only if the workload assigned by O is monotonic in a certain manner.",
                "It wound be of interest to generalize our framework for designing a truthful payment scheme for a binary <br>demand game</br> to non-binary demand games.",
                "Towards this research direction, Theorem 4 can be extended to a general allocation rule O, whose range is R+ .",
                "The remaining difficulty is then how to compute the payment P under mild assumptions about the valuations if a truthful mechanism M = (O, P) does exist.",
                "Acknowledgements We would like to thank Rakesh Vohra, Tuomas Sandholm, and anonymous reviewers for helpful comments and discussions. 7.",
                "REFERENCES [1] A. ARCHER, C. PAPADIMITRIOU, K. T., AND TARDOS, E. An approximate truthful mechanism for combinatorial auctions with single parameter agents.",
                "In ACM-SIAM SODA (2003), pp. 205-214. [2] ARCHER, A., AND TARDOS, E. Truthful mechanisms for one-parameter agents.",
                "In Proceedings of the 42nd IEEE FOCS (2001), IEEE Computer Society, p. 482. [3] AULETTA, V., PRISCO, R. D., PENNA, P., AND PERSIANO, P. Deterministic truthful approximation schemes for scheduling related machines. [4] CHVATAL, V. A greedy heuristic for the set covering problem.",
                "Mathematics of Operations Research 4, 3 (1979), 233-235. [5] CLARKE, E. H. Multipart pricing of public goods.",
                "Public Choice (1971), 17-33. [6] R. Muller, and R. V. Vohra.",
                "On Dominant Strategy Mechanisms.",
                "Working paper, 2003. [7] DEVANUR, N. R., MIHAIL, M., AND VAZIRANI, V. V. Strategyproof cost-sharing mechanisms for set cover and facility location games.",
                "In ACM Electronic Commerce (EC03) (2003). [8] FEIGENBAUM, J., KRISHNAMURTHY, A., SAMI, R., AND SHENKER, S. Approximation and collusion in multicast cost sharing (abstract).",
                "In ACM Economic Conference (2001). [9] FEIGENBAUM, J., PAPADIMITRIOU, C., SAMI, R., AND SHENKER, S. A BGP-based mechanism for lowest-cost routing.",
                "In Proceedings of the 2002 ACM Symposium on Principles of Distributed Computing. (2002), pp. 173-182. [10] GREEN, J., AND LAFFONT, J. J.",
                "Characterization of satisfactory mechanisms for the revelation of preferences for public goods.",
                "Econometrica (1977), 427-438. [11] GROVES, T. Incentives in teams.",
                "Econometrica (1973), 617-631. [12] LEHMANN, D., OCALLAGHAN, L. I., AND SHOHAM, Y.",
                "Truth revelation in approximately efficient combinatorial auctions.",
                "Journal of ACM 49, 5 (2002), 577-602. [13] MUALEM, A., AND NISAN, N. Truthful approximation mechanisms for restricted combinatorial auctions: extended abstract.",
                "In 18th National Conference on Artificial intelligence (2002), American Association for Artificial Intelligence, pp. 379-384. [14] NISAN, N., AND RONEN, A. Algorithmic mechanism design.",
                "In Proc. 31st Annual ACM STOC (1999), pp. 129-140. [15] E. Halperin.",
                "Improved approximation algorithms for the vertex cover problem in graphs and hypergraphs.",
                "In Proceedings of the 11th Annual ACM-SIAM Symposium on Discrete Algorithms, pages 329-337, 2000. [16] R. Bar-Yehuda and S. Even.",
                "A local ratio theorem for approximating the weighted vertex cover problem.",
                "Annals of Discrete Mathematics, Volume 25: Analysis and Design of Algorithms for Combinatorial Problems, pages 27-46, 1985.",
                "Editor: G. Ausiello and M. Lucertini [17] ROBINS, G., AND ZELIKOVSKY, A.",
                "Improved steiner tree approximation in graphs.",
                "In Proceedings of the 11th annual ACM-SIAM SODA (2000), pp. 770-779. [18] A. Zelikovsky.",
                "An 11/6-approximation algorithm for the network Steiner problem.",
                "Algorithmica, 9(5):463-470, 1993. [19] D. S. Hochbaum.",
                "Efficient bounds for the stable set, vertex cover, and set packing problems, Discrete Applied Mathematics, 6:243-254, 1983. [20] TAKAHASHI, H., AND MATSUYAMA, A.",
                "An approximate solution for the steiner problem in graphs.",
                "Math.",
                "Japonica 24 (1980), 573-577. [21] VICKREY, W. Counterspeculation, auctions and competitive sealed tenders.",
                "Journal of Finance (1961), 8-37. [22] WANG, W., AND LI, X.-Y.",
                "Truthful low-cost unicast in selfish wireless networks.",
                "In 4th IEEE Transactions on Mobile Computing (2005), to appear. [23] WANG, W., LI, X.-Y., AND SUN, Z.",
                "Design multicast protocols for non-cooperative networks.",
                "IEEE INFOCOM 2005, to appear. [24] WANG, W., LI, X.-Y., AND WANG, Y. Truthful multicast in selfish wireless networks.",
                "ACM MobiCom, 2005. 222"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Dada cualquier regla de asignación o para un \"juego de demanda\" binario, demostramos que existe un mecanismo veraz M = (O, P) para el juego si y solo si o satisface una determinada propiedad de monotonicidad.juego de demanda",
                "En este artículo, estudiamos cómo diseñar un mecanismo veraz que no optimice una función objetivo utilitaria.2.2 Juegos de demanda binaria Un \"juego de demanda\" binario es un juego g = (s, m), donde m = (o, p) y el rango de o es {0, 1} n.juego de demanda",
                "En un \"juego de demanda\" binario, si queremos optimizar una función objetivo G (O, T), entonces lo llamamos un \"juego de demanda\" de optimización binaria.juego de demanda",
                "La función objetivo es utilitario (o problema de maximización afín) para un problema solucionable por VCG, mientras que no hay restricción en la función objetivo de un \"juego de demanda\" binario.2. Juego de demanda",
                "Suponemos que las valoraciones de los agentes no están correlacionadas en un \"juego de demanda\" binario, mientras que las valoraciones de los agentes pueden correlacionarse en un mecanismo de VCG.juego de demanda",
                "Observe la suposición de exactitud revela que la subasta de mentalidad individual es de hecho un \"juego de demanda\" binario.juego de demanda",
                "Su esquema de pago inspiró nuestro esquema de pago para el \"juego de demanda\" binario.juego de demanda",
                "Observe cuándo la carga de los problemas es w = {0, 1}, de hecho es un \"juego de demanda\" binario.juego de demanda",
                "Con una simple generalización, obtenemos nuestra conclusión para el \"juego de demanda\" binario general.juego de demanda",
                "Además, el \"juego de demanda\" binario estudiado aquí es diferente de las IP de embalaje tradicionales: solo requerimos que la asignación a cada agente sea binaria y la regla de asignación satisfaga una cierta propiedad de monotonicidad;No ponemos ninguna restricción en la función objetivo.juego de demanda",
                "Para cualquier mecanismo a prueba de estrategia para un \"juego de demanda\" binario G con la configuración S, si solucionamos el costo C-I de todos los agentes que no sean yo, el pago al Agente I es una p1 I If If Oi (C) = 1, y es otra constante p0 i si oi (c) = 0. juego de demanda",
                "Se corrigió la configuración S para un \"juego de demanda\" binario, si el mecanismo m = (O, p) satisface el IC, entonces el mecanismo M = (O, P) con el mismo método de salida O y Pi (C) = pi (c) - - -ΔI (C - I) para cualquier función ΔI (C - I) también satisface IC.juego de demanda",
                "Dada una regla de asignación o para un \"juego de demanda\" binario, primero presentamos una condición suficiente y necesaria para la existencia de un esquema de pago veraz P. Definición 1 (propiedad monótona no aumentable (MP)).juego de demanda",
                "Arregle la configuración S, C - I en un \"juego de demanda\" binario G con la regla de asignación O, las siguientes tres condiciones son equivalentes: 1. Juego de demanda",
                "Existe un esquema de pago veraz P para este \"juego de demanda\" binario.juego de demanda",
                "Ahora resumimos el proceso para diseñar un esquema de pago veraz para un \"juego de demanda\" binario basado en un método de salida O. Game de demanda",
                "Marco general 1 Diseño de mecanismo veraz para un \"juego de demanda\" binario Etapa 1: Compruebe si la regla de asignación o satisface el MP.juego de demanda",
                "Con una configuración fija de un \"juego de demanda\" binario, suponga que existen reglas de asignación M O1, O2, · ·, om que satisface la propiedad de monotonicidad, y κ (OI, C) es el vector de valor cortado para OI.juego de demanda",
                "Se corrigió la configuración de un \"juego de demanda\" binario, suponga que hay m métodos de salida O1, O2, · · ·, om satisfecho de MP y κ (OI, C) son las funciones de valor cortado respectivamente para OI donde i = 1, 2, · · ·, m.Entonces la regla de asignación o (c) = vm i = 1 oi (c) satisface mp.juego de demanda",
                "Salida: el valor de corte κK (V C, C - K).1: Para cada i ∈ V, establecer w (i) = ci.2: establecer w (k) = ∞, pk = 0 y v = ∅.3: Si bien V no es una cubierta de vértice Do 4: Elija un borde descubierto (I, J) con el menor orden lexicográfico entre todos los bordes descubiertos.5: establecer m = min (w (i), w (j)).6: Actualización w (i) = w (i) - my w (j) = w (j) - m.7: Si w (i) = 0, agregue i a v;de lo contrario agregue j a v.8: si i == k o j == k luego establece pk = pk + m.9: Salida PK como valor cortado κK (V C, C - K).4.3 Combinaciones complejas en la subsección 4.1, discutimos cómo encontrar la función del valor de corte cuando la salida del \"juego de demanda\" binario es una combinación simple de algunas salidas, cuyos valores de corte se pueden calcular a través de otros medios (típicamente VCG).juego de demanda",
                "Suponga que hay n agentes 1 ≤ i ≤ n con el vector de costos C, y hay M Juegos de demanda binarios GI con funciones objetivas fi (O, C), configuración de Si y regla de asignación ψi donde i = 1, 2, · · ·, m.Hay otro \"juego de demanda\" binario con la configuración S y la regla de asignación O, cuya entrada es un vector de costo d = (d1, d2, · · ·, dm).juego de demanda",
                "Dada una regla de asignación O y configuración S, un vector de función objetivo F, un vector de regla de asignación ψ y vector de configuración ∫, definimos un \"juego de demanda\" binario compuesto con la configuración S y la salida O ◦ F as (O ◦ F) I (c) = Wm J = 1 (Oj (F (c)) ∧ ψj I (c)).juego de demanda",
                "Para simplificar, usaremos O ◦ F para denotar el resultado de este \"juego de demanda\" binario compuesto.juego de demanda",
                "Obviamente, el problema de la portada del conjunto es un \"juego de demanda\" binario.juego de demanda",
                "Conclusiones En este artículo, hemos estudiado cómo diseñar un mecanismo veraz M = (O, P) para una regla de asignación dada O para un \"juego de demanda\" binario.juego de demanda",
                "Otra dirección de investigación es diseñar una regla de asignación de aproximación o satisfacer a MP con una buena relación de aproximación para un \"juego de demanda\" binario dado.juego de demanda",
                "Sería importante diseñar reglas de asignación con buenas relaciones de aproximación de modo que un \"juego de demanda\" binario dado tenga un esquema de pago computacionalmente eficiente.juego de demanda",
                "Sería interesante generalizar nuestro marco para diseñar un esquema de pago veraz para un \"juego de demanda\" binario a los juegos de demanda no binarios.juego de demanda"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}