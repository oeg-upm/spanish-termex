{
    "id": "C-40",
    "original_text": "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time. They are filled with autonomous, mutable virtual content which is continuously augmented by the users. To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds. In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium. In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability. Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting. We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query. Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments. The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination. We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization. We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future. Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1. INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments. Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side. To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability. In this paper, we mainly focus on the first two requirements. Dynamic extensibility allows regular game-users to deploy their own created content. This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems. Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers. Another important requirement is scalability. Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world. By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported. Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3]. Second Life [4] is the first successfully deployed MMOG system that meets both requirements. To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform. But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5]. In this model, a server continuously transmits both update events and geometry data to every connected user. As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space. One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user. The traditional visibility determination approach, however, has an object popping problem. For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a). As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b). If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience. The visibility calculation for each user not only needs to be accurate, but also fast. This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds. To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing). Our two novel methods represent the main contributions of this work. The organization of this paper is as follows. Section 2 presents related work. Section 3 describes our new view method. In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations. We also discuss its optimization issues. Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments. Finally, we conclude and address future research directions in Section 7. 2. RELATED WORK Visibility determination has been widely explored in the field of 3D graphics. Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline. View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6]. However, these algorithms assume that all the candidate visible objects have been stored locally. If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases. Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5]. Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7]. However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments. On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities. In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users. Here we recognize that such graphics related issues have a very close similarity to spatial database problems. Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments. To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing. The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR). The grid-based partitioning model is a special case of fixed partitioning. Recently, it has been re-discovered since it can be efficient in highly dynamic environments. Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12]. A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism. Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table. Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments. In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely. The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree. SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries. Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently. Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects. As long as any object resides in this region, all the query results are guaranteed to be valid in the system. If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly. Our indexing method is very similar to the above approaches. The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3. OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model. We then propose our own model, and finally we discuss its strengths and limitations. To begin with, we define the terminologies commonly used throughout this paper. Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars. The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities. The spectator entity corresponds to a players viewpoint, but is invisible to other entities. It has no shape and is represented only by a point location. It is designed to allow a game participant to see from a third-person viewpoint. It functions similar to a camera control in the 3D graphics field. It also has a higher degree of mobility than other entities. The avatar represents a normal game user who can freely navigate in the space and interact with other entities. It possesses both features: its own viewpoint and visibility. For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity. The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence. It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility. Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other. To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity. Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area. However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world. The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not. As the user navigates, she continuously searches for all the entities within her AOI. Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model. However, the user-initiated model has a serious object popping problem during navigation. Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely. A large AOI, however, may lead to a significant system degradation. To overcome the object popping problem, we propose a new view model which we call object-initiated view model. All object entities have their own AOI centered at their current location while all spectator entities have no AOI. Every user entity recognizes the objects whose AOIs cover its point location. The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes. A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure. One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view. We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model. To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4. Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time. For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 . Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image. In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4. DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model. Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4. Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting. The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world. Second Life is the classic example of such an approach. A virtual space is partitioned into equal-sized sub-worlds. The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A. As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI. Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure). The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R. Every sub-world is managed by its dedicated server machine. Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities. For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells. Figure 2 shows the 4 × 4 grid enclosed by the dashed lines. Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells. Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2. There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in. This retrieval process is interchangeably called a user (or query) evaluation. Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved. Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell. In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell. Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell. Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell. We also define two data structures for storing and retrieving the tokens: a node and an edge. A node is a data structure that stores ITs of a cell. Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region. An edge is another data structure for two adjacent cells that stores their ATs or DTs. If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE). The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j. The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ). Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10]. To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing. Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query. In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location. For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query. Due to the use of a simple point geometry for entities, this allows for lightweight index updates. Much of the existing work falls into this category. However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead. For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case. One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13]. For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a). Every cell stores IT entities that intersect with its region. Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid. Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures. With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated. In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures. If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M). Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2. Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures. If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1. The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2. Lemma 1. Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information. Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25. To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing. Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated. Generally, this is done through a twostep algorithm [13] that works as follows. The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step). After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user. After all the cells are evaluated, the algorithm starts over. The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations. In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures. Let us assume that the system maintains the row-wise edges. The leftmost node structures are assumed to be obtained in advance. Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges. We repeat this computation until we reach the rightmost cell. Hence, without any column-wise edges we can obtain all the node structures successfully. As a result, we reduce the complexity of the index construction and update by a factor of two. Figure 3(c) illustrates the concept of our row-wise edge indexing method. The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT). The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells. In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2. As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}. E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}. Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}. If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}. The above calculation also corresponds to our intuition. P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4. When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged. Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set. Obviously, edge indexing is inefficient for indexing a point geometry. Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement. Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case. In such a situation, we take advantage of using both according to the spatial property of entity extension. In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas. Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation. Let us assume that an edge index is realized with a hash table. Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant. However, the token removal time depends on the expected number of tokens per hash bucket. Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities. Two-table edge indexing is designed to make the token removal overhead constant. First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties. Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq). It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance. It is represented by the number of cell units. structures. If an entity is not moving, its tokens will be placed in a stationary edge structure. Otherwise, it will be placed with a moving edge. Second, all moving edge structures are periodically reconstructed. After the reconstruction, all grid cells are evaluated to compute their visible sets. Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows. As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities. A singly linked list implementation is used for the moving edge structure. 5. ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time. In this analysis, we assume that node and edge structures are implemented with hash tables. For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan. Their processing costs are denoted by Ta, Td, and Ts, respectively. A token scan operation reads the tokens in a hash bucket sequentially. It is extensively used during cell evaluations. Ts and Td are a function of the number of tokens in the bucket while Ta is constant. For the purpose of analysis, we define two random variables. One variable, denoted by mo, represents the side length of the AOI of an entity o. The side lengths are uniformly distributed in the range of [mmin, mmax]. The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval. The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v]. For a simple calculation, both random variables are expressed as the number of cell units. Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities. Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities. Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects. Table 2 summarizes these results. In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing. Different grid cell partitioning with edge methods will lead to different memory requirements. For example, here are two grids: a M × M grid and a 2M × 2M grid. The memory requirement for the user entities is unchanged because it depends only on the total number of user entities. The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid. Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations. For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance. Similar to edge indexing, node indexing has two update policies: full update and incremental update. Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes. The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period. In this analysis, we only consider incremental node indexing. To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5. We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O. As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0). If an object resides in the same cell, there will be no update. If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0). The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed. Roughly speaking, its worst-case processing cost is the same as Tedgefull per update . Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3. In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)). However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2). Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta. Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods. The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v). The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation. After the lookup, Td executes the reverse operation of Ta. Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets. From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing. Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI. In this figure we assume that the average side length of the AOI is 0.1 (or 10 %). The node indexing method, however, depends not only on the side length but also on the reachable distance. Thus the entity update in node indexing is much heavier than the full update for edge indexing. As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node. Therefore, it would take |Q|×Ts to scan all user entities. If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts. If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts. The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1). In this analysis, we do not consider any data delivery overhead after a cell evaluation. Note that in single-table edge indexing we need to scan all the tokens for cell evaluations. Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation. Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation. Table 4 shows the expected complexities of different cell evaluation scenarios. If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|). However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations. In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing. The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement. First of all, Td is very predictable and a more lightweight procedure than Td. All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant. In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing. Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform. Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific. The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9. Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second. Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6. EVALUATION This section presents two simulation setups and their performance results. Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity. Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15]. P is the ratio of relevant, retrieved items to all retrieved items. A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client. A higher P value means a higher network traffic load than required. R is the ratio of relevant, retrieved items to all relevant items. A lower R value means that more objects that should be recognized are ignored. From the R measure, we can quantitatively estimate the occurrence of object popping. In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15]. The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important. If β is less than 1, P becomes more important. Otherwise, R will affect the E-measure significantly. A lower E-measure value implies that the tested view model has a higher quality. The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI. PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}. RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}. Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing. If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes. Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell. Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result. It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well. Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1). The populated entities are uniformly located in the unit space. The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space. The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP. We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range. A smaller side length leads to higher accuracy but lower comprehensiveness. For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%. Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client. But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered. Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects. To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation. E-measure Distribution: Figure 8 reveals two trends. First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR. Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR. It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR. Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model. We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme. We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes. While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI. As expected, fine-grained grid partitioning showed a smaller E-measure value. The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths. As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP. From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment. As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation. To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell. We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory. We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update. However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal. Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist. Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments. However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment. Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput. In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP. Figure 8: E-measure value as a function of Precision value P when β = 1. Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes. Exhaustive search methods do not maintain any intermediate results. They simply compute whether a given user point is inside a given object AOI. They can tolerate unpredictable behavior of object movement. In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination. Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude. As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI. Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally. Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7. CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing. Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity. Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations. However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain. Currently, we are developing another edge indexing method to make the indexing complexity constant. Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data. We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8. REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech. Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput. Graph. Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib. Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J. Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411",
    "original_translation": "Indexación de borde en una cuadrícula para entornos virtuales altamente dinámicos ∗ Beomjoo SEO bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 Resumen Sistemas de aplicaciones recientemente emergentes como el segundo como el segundo como el segundo como el segundoLife1 proporciona entornos virtuales 3D donde múltiples usuarios interactúan entre sí en tiempo real. Están llenos de contenido virtual autónomo y mutable que los usuarios aumentan continuamente. Para que los sistemas sean altamente escalables y dinámicamente extensibles, generalmente se basan en una división de subespacio de cuadrícula basada en el cliente-servidor donde los mundos virtuales se dividen en sub-mundo manejables. En cada sub-mundo, el usuario recibe continuamente actualizaciones de geometría relevantes de objetos en movimiento de servidores conectados remotamente y los hace de acuerdo con su punto de vista, en lugar de recuperarlos de un medio de almacenamiento local. En tales sistemas, la determinación del conjunto de objetos que son visibles desde el punto de vista de los usuarios es uno de los factores principales que afectan el rendimiento del servidor y la escalabilidad. Específicamente, realizar pruebas de visibilidad en tiempo real en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y los menos millones de usuarios activos se están moviendo e interactuando. Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de base de datos espacial y, por lo tanto, asignamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una base de datos espacial mientras modelamos cada avatar como un objeto espacial y un objeto espacial y un objeto espacialconsulta en movimiento. Desafortunadamente, los métodos de indexación espacial existentes no son adecuados para este tipo de entornos nuevos. El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimice el estallido inesperado de objetos y admite una determinación de visibilidad en tiempo real altamente escalable. Luego descubrimos muchas propiedades útiles de esta estructura y comparamos la estructura de índice con varios métodos de indexación espacial en términos de calidad de consulta, rendimiento del sistema y utilización de recursos. Esperamos nuestro enfoque para sentar las bases para los marcos virtuales de próxima generación que pueden fusionarse con los servicios basados en la web existentes en el futuro cercano. Categorías y descriptores de sujetos: C.2.4 [computadora - redes de comunicación]: sistemas distribuidos - cliente/servidor, aplicaciones distribuidas, bases de datos distribuidas;I.3.7 [gráficos por computadora]: gráficos tridimensionales y realismo - Términos generales de realidad virtual: algoritmos, diseño, rendimiento 1. Introducción Recientemente, los juegos en línea multijugador masivo (MMOGS) se han estudiado como un marco para entornos virtuales de próxima generación. Sin embargo, muchas aplicaciones de MMOG aún se limitan a un enfoque de diseño tradicional donde su complejidad de la escena 3D se controla cuidadosamente por adelantado para cumplir con las limitaciones de representación en tiempo real en el lado de la consola del cliente. Para habilitar un paisaje virtual en entornos de próxima generación que sea perfecto, interminable e ilimitado, Marshall et al.[1] identificó cuatro nuevos requisitos2: Extensibilidad dinámica (un sistema permite la adición o el cambio de componentes en tiempo de ejecución);escalabilidad (aunque aumenta el número de usuarios concurrentes, el sistema continúa funcionando de manera efectiva);interactibilidad;e interoperabilidad. En este artículo, nos centramos principalmente en los dos primeros requisitos. La extensibilidad dinámica permite que los usuarios de juegos regulares implementen su propio contenido creado. Este es un concepto poderoso, pero desafortunadamente, el contenido creado por el usuario tiende a crear desequilibrios entre la complejidad de la escena existente, causando problemas de rendimiento en todo el sistema. El apoyo total para la extensibilidad dinámica, por lo tanto, continuará siendo uno de los mayores desafíos para los desarrolladores de juegos. Otro requisito importante es la escalabilidad. Aunque los desarrolladores de MMOG proclaman que sus sistemas pueden soportar cientos de miles de usuarios concurrentes, generalmente no significa que todos los usuarios puedan interactuar entre sí en el mismo mundo. Al dividir cuidadosamente el mundo en múltiples sub-mundo o replicar mundos en ubicaciones geográficamente dispersas, se puede admitir un número masivo de usuarios concurrentes. Por lo general, el número máximo de usuarios en el mismo mundo administrado por un solo servidor o un clúster de servidor se limita a varios miles, suponiendo un mundo bastante estacario [2, 3]. Second Life [4] es el primer sistema MMOG implementado con éxito que cumple con ambos requisitos. Para mitigar la dinámica del mundo del juego, donde una gran cantidad de objetos autónomos se mueven continuamente, divide el espacio de manera similar a la red y originalmente, estos requisitos se especificaron para su plataforma dedicada. Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales.402 Avatar Objeto Poppingautónomos Entidades (a) en el tiempo t (b) en el tiempo t+δ Figura 1: El estallido del objeto ocurrió a medida que un usuario avanza (capturas de pantalla desde la segunda vida) donde δ = 2 segundos.Emplea un modelo de transmisión de objetos 3D basado en el cliente/servidor [5]. En este modelo, un servidor transmite continuamente eventos de actualización y datos de geometría a cada usuario conectado. Como resultado, este entorno de juego extensible ha acelerado la implementación de contenido creado por los usuarios y proporciona a los usuarios libertad ilimitada para seguir una experiencia de navegación en su espacio. Una de las principales operaciones en aplicaciones MMOG que transmiten objetos 3D es calcular con precisión todos los objetos que son visibles para un usuario. Sin embargo, el enfoque de determinación de visibilidad tradicional tiene un problema de explotación de objetos. Por ejemplo, una casa fuera de un rango visible de los usuarios no se dibuja en el tiempo t, ilustrada en la Figura 1 (a). A medida que el usuario avanza, la casa aparecerá repentinamente en el momento (t + δ) como se muestra en la Figura 1 (b). Si δ es pequeño, o la casa es lo suficientemente grande como para colisionar con el usuario, interrumpirá la experiencia de navegación de los usuarios. El cálculo de visibilidad para cada usuario no solo debe ser preciso, sino también rápido. Este desafío se ilustra por el hecho de que el número máximo de usuarios concurrentes por servidor de Second Life sigue siendo un orden de magnitud más pequeño que para mundos estacionarios. Para abordar estos desafíos, proponemos un método que identifica los objetos visibles más relevantes de una base de datos de geometría dada (modelo de vista) y luego presentamos un método de indexación rápida que calcula los objetos visibles para cada usuario (indexación espacial). Nuestros dos métodos novedosos representan las principales contribuciones de este trabajo. La organización de este documento es la siguiente. La Sección 2 presenta trabajo relacionado. La Sección 3 describe nuestro nuevo método de vista. En la Sección 4, presentamos suposiciones en nuestra aplicación objetivo e presentamos un nuevo método de indexación espacial diseñado para admitir los cálculos de visibilidad en tiempo real. También discutimos sus problemas de optimización. La Sección 5 informa sobre el análisis cuantitativo y la Sección 6 presenta resultados preliminares de nuestros experimentos basados en simulación. Finalmente, concluimos y abordamos las futuras direcciones de investigación en la Sección 7. 2. La determinación de la visibilidad del trabajo relacionada se ha explorado ampliamente en el campo de los gráficos 3D. Se han propuesto varios algoritmos de representación locales para eliminar objetos innecesarios antes de renderizar o en cualquier etapa de la tubería de representación. El sacrificio de visión-frustum, el sacrificio de la cara posterior y el sacrificio de oclusión son algunas de las técnicas de sacrificio de visibilidad bien conocidas [6]. Sin embargo, estos algoritmos suponen que todos los objetos visibles candidatos se han almacenado localmente. Si los objetos de destino se almacenan en servidores remotos, los clientes reciben los elementos de geometría que son necesarios para representar desde las bases de datos del servidor. Teller et al.describió un algoritmo de programación de datos de geometría que maximiza la calidad de la velocidad de cuadro con el tiempo en tutoriales remotos de escenas 3D complejas de una ruta de navegación de usuarios [5]. Funkhouser et al.demostró que la representación multisolutiva, como los niveles de detalle (LOD), puede usarse para mejorar las velocidades de cuadro de representación y la utilización de la memoria durante la visualización interactiva [7]. Sin embargo, estos algoritmos de optimización en línea no logran abordar el problema de rendimiento en el servidor en entornos altamente llenos de gente. Por otro lado, nuestro modelo de cálculo de visibilidad, un representante de esta categoría, se basa en diferentes supuestos en la representación de datos de entidades virtuales. En el área gráfica, ha habido poco trabajo para admitir cálculos de visibilidad en tiempo real para un número masivo de objetos y usuarios en movimiento. Aquí reconocemos que tales problemas relacionados con los gráficos tienen una similitud muy cercana con los problemas de la base de datos espacial. Recientemente, varias publicaciones han abordado el problema de escalabilidad sobre cómo apoyar un número masivo de objetos y consultas en entornos altamente dinámicos. Para admitir actualizaciones frecuentes, se han estudiado dos políticas de partición en profundidad: (1) indexación espacial basada en el árbol R y (2) indexación espacial basada en la cuadrícula. El árbol R es una estructura de índice espacial bien conocida que permite la superposición entre las regiones en diferentes ramas que están representadas por rectángulos mínimos delimitadores (MBR). El modelo de partición basado en la cuadrícula es un caso especial de partición fija. Recientemente, se ha vuelto a descubrir, ya que puede ser eficiente en entornos altamente dinámicos. Muchos estudios han informado que el árbol R y sus variantes (R+ Tree, R ∗ -tree) sufren de una degradación inaceptable del rendimiento en un entorno altamente dinámico, principalmente debido a la complejidad computacional del algoritmo dividido [8, 9, 10, 11, 12]. Una estrategia de actualización ascendente propuesta para R-árboles [9] optimiza las operaciones de actualización del índice mientras se mantiene un mecanismo de procesamiento de consultas de arriba hacia abajo. En lugar de atravesar un árbol desde el nodo raíz para las solicitudes de actualización frecuentes (enfoque de arriba hacia abajo), accede directamente al nodo hoja del objeto a actualizarse a través de una tabla hash de objeto. El índice Q [13, 11] es uno de los trabajos anteriores que redescubre la utilidad de la partición espacial basada en la cuadrícula para entornos de objetos móviles emergentes. A diferencia de los métodos de indexación espacial tradicionales que construyen un índice en los objetos móviles, construye un índice en las consultas de rango continuo, suponiendo que las consultas se muevan con poca frecuencia mientras los objetos se mueven libremente. La idea básica del Q+Rtree [14] es separar las estructuras de indexación para objetos cuasistacionarios y objetos en movimiento: los objetos de movimiento rápido se indexan en un quadtree y los objetos cuasi-estacionarios se almacenan en un tree r ∗. Se propuso que SINA [10] proporcionara evaluaciones de consulta eficientes para cualquier combinación de objetos estacionarios/móviles y consultas estacionarias/móviles. Específicamente, este enfoque solo detecta las actualizaciones de objetos recién descubiertos (positivos) o no relevantes (negativos) de manera eficiente. A diferencia de otros métodos de indexación espacial que se centran en reducir el costo de evaluación de consultas, Hu et al.[12] propuso un marco general que minimiza el costo de comunicación para las actualizaciones de ubicación al mantener un área rectangular llamada región segura alrededor de objetos móviles. Mientras cualquier objeto reside en esta región, se garantiza que todos los resultados de la consulta son válidos en el sistema. Si los objetos se mudan de su región, las solicitudes de actualización de ubicación deben entregarse al servidor de la base de datos y las consultas afectadas se reevalúan sobre la marcha. Nuestro método de indexación es muy similar a los enfoques anteriores. La principal diferencia es que nos estamos concentrando más en la determinación de visibilidad en tiempo real, mientras que otros asumen limitaciones de tiempo suelto.3. Modelo de vista iniciado por objetos En esta sección, ilustramos cómo el problema de estallido de objetos puede asociarse con un modelo de decisión de vista típico. Luego proponemos nuestro propio modelo, y finalmente discutimos sus fortalezas y limitaciones. Para empezar, definimos las terminologías comúnmente utilizadas en este documento. Las entidades en un espacio virtual se pueden clasificar en tres tipos 403 en función de su rol: entidades autónomas, entidades espectadoras y avatares. El término entidad autónoma se refiere a un objeto geométrico móvil ordinario o estacionario que puede ser visible para otras entidades. La entidad del espectador corresponde al punto de vista de un jugador, pero es invisible para otras entidades. No tiene forma y está representado solo por una ubicación de punto. Está diseñado para permitir que un participante del juego vea desde un punto de vista en tercera persona. Funciona similar al control de una cámara en el campo de gráficos 3D. También tiene un mayor grado de movilidad que otras entidades. El avatar representa un usuario normal del juego que puede navegar libremente en el espacio e interactuar con otras entidades. Posee ambas características: su propio punto de vista y visibilidad. Para el resto, utilizamos la entidad del objeto término para referirnos a una entidad autónoma o un avatar mientras usamos la entidad de usuario para denotar un avatar o una entidad espectadora. El rango visible de una entidad se refiere a la extensión espacial dentro del cual cualquier otra entidad puede reconocer su existencia. Se basa en las suposiciones de que siempre existe una distancia visible óptima entre un usuario y un objeto en cualquier momento y cada usuario posee la misma visibilidad. Por lo tanto, el usuario y el objeto, solo cuando su distancia actual es más pequeña o igual a la óptima, pueden verse entre sí. Para especificar el rango visible, mucha literatura en el área gráfica [5, 6] utiliza un área circular de interés (AOI) cuyo centro es la ubicación de una entidad. Su naturaleza omnidireccional permite cambios direccionales rápidos sin ninguna interrupción de visualización en la periferia del área visible. Sin embargo, empleamos un AOI squarado a expensas de la precisión porque la extensión espacial de forma cuadrada es muy simple y eficiente para ser indexada en un mundo dividido en la cuadrícula. El modelo de vista tradicional, que llamamos modelo de vista iniciado por el usuario, supone que una entidad de usuario tiene una AOI, mientras que una entidad de objeto no. A medida que el usuario navega, busca continuamente todas las entidades dentro de su AOI. Debido a su diseño simple y su sobrecarga de baja indexación, muchos servicios basados en la ubicación (LBSS) y las aplicaciones de juegos utilizan este modelo. Sin embargo, el modelo iniciado por el usuario tiene un problema grave de estallido de objetos durante la navegación. Recuerde, como se muestra en la Figura 1, que la casa que habrá aparecido en el momento t + δ no aparece en el momento t porque el usuario no puede reconocer objetos que están fuera de su AOI en el momento t.De hecho, resultó que la longitud lateral de su AOI era más pequeña que la distancia óptima entre el usuario y la casa en el momento t.Por lo tanto, no hay otra manera que aumentar el rango visible del usuario en este modelo para hacer que tal experiencia sea poco probable. Sin embargo, un AOI grande puede conducir a una degradación significativa del sistema. Para superar el problema de estallido de objetos, proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objetos. Todas las entidades de objetos tienen su propia AOI centrada en su ubicación actual, mientras que todas las entidades de espectadores no tienen AOI. Cada entidad de usuario reconoce los objetos cuyos AOIS cubren su ubicación de punto. Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema de estallido de objetos siempre que el sistema subyacente pueda administrar el rango óptimo visible de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecida de variascambios conductuales y temporales. Un objeto enorme puede tener un rango más visible que uno pequeño;Un objeto tiene un rango visible más amplio durante el día que por la noche;Incluso durante la noche, el rango visible de un objeto que posee una fuente de luz tendrá un área visible mucho más amplia que un objeto no iluminado;Si se encuentra un objeto dentro de un edificio, su rango visible estaría limitado por la estructura circundante. Uno de los argumentos potenciales contra la visión iniciada por el objeto es que la indexación de la extensión espacial de un objeto es demasiado compleja para ser práctico, en comparación con la vista iniciada por el usuario. Estamos de acuerdo con el cliente E2 E1 A S Client Un Sub-World Server Figura 2: Sistema de destino en una partición de cuadrícula 4 × 4.que los métodos de indexación espacial existentes son ineficientes para soportar nuestro modelo de vista. Para refutar este argumento, proponemos una nueva solución de indexación espacial detallada en la Sección 4.4. Nuestra solución de indexación espacial ofrece un rendimiento muy prometedor incluso con una gran cantidad de entidades móviles y cálculos de visibilidad en tiempo real. Para el resto del documento, nuestro alcance de diseño se limita a un espacio 2D, aunque nuestra aplicación está dirigida a entornos 3D3. Tenga en cuenta que nuestro modelo de vista no tiene la intención de rivalizar con un algoritmo sofisticado de decisión de visibilidad, como el sacrificio de visibilidad [6], sino para filtrar eficientemente entidades innecesarias que no contribuyen a la imagen final. En la Sección 6.1 evaluamos ambos modelos a través de medidas cuantitativamente, como el grado de expresividad y la calidad de los dos modelos de vista, y discutimos los resultados de la simulación.4. Diseño de indexación de borde en la Sección 4.1 Introducimos nuestro modelo de aplicación objetivo. A continuación, la Sección 4.2 presenta una abstracción de nuestras estructuras de nodo y borde cuyos métodos detallados de indexación y evaluación celular se explican más adelante en las Secciones 4.3 y 4.4. Varios problemas de optimización para la indexación de borde siguen en la Sección 4.5.4.1 Aplicación de destino Nuestra aplicación de destino asume tanto la transmisión de objetos 3D como el alojamiento del sub-mundo. El alojamiento del sub-mundo es un entorno virtual colaborativo donde cada servidor aloja un sub-mundo, construyendo así un solo mundo. Second Life es el ejemplo clásico de tal enfoque. Un espacio virtual se divide en sub-mundo de tamaño igual. La muestra del sub-mundo separado con líneas con negrita en la Figura 2 contiene cuatro entidades virtuales: dos entidades autónomas (E1, E2);una entidad espectadora;y un avatar A. Como se menciona en la Sección 3, todas las entidades de objetos (E1, E2, A) tienen su propio AOI en forma cuadrada. Dos entidades de usuario (s, a) están asociadas con máquinas clientes individuales (Cliente S y Cliente A en la figura). La condición espacial de que la ubicación puntual de S reside dentro del AOI de E2 puede simbolizarse como S.P ∈ E2.R. Cada sub-mundo es administrado por su máquina de servidor dedicada. Cada servidor indexa todas las entidades, ofrece cualquier evento nuevo (es decir, un nuevo usuario entra en el sub-mundo o un objeto se mueve de un lugar a otro) a los clientes, y resuelve cualquier inconsistencia entre las entidades. Para la gestión eficiente de las entidades móviles, un servidor divide aún más su sub-mundo en particiones más pequeñas, llamadas celdas de cuadrícula. La Figura 2 muestra la cuadrícula 4 × 4 encerrada por las líneas discontinuas. En lugar de indexar las entidades de objeto con una estructura de entidad de usuario, nuestro sistema indexa sus regiones visibles en las celdas de la cuadrícula. La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y DE3 Un mejor método de indexación para un espacio 3D es el trabajo en progreso.404 tokens: it (e1) it (e2) it (a) it (s) tokens: at (e1) dt (e1) at (e2) dt (e2) at (a) dt (a) it (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s)A) Indexación de nodos (b) indexación de borde (c) indexación de borde con evaluación de celda de hilera Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos e indexación de borde para el espacio de muestra en la Figura 2. Hay tres entidades de objetos, {e1, e2, a} y dos entidades de usuario, {s, a} en el mundo.Librea de los índices almacenados en la celda en la que se encuentra. Este proceso de recuperación se denomina evaluación de usuario (o consulta). Nuestra aplicación solo considera la indexación eficiente de las entidades virtuales y la búsqueda de las entidades más relevantes, es decir, cuántas entidades por sub -mundo están indexadas y qué tan rápido se reconocen y recuperan las actualizaciones de índice. La entrega eficiente de datos de geometría real recuperados está fuera del alcance de este documento.4.2 Abstracción Definimos un token como una abstracción de una entidad virtual que satisface una relación espacial específica con una célula dada. En nuestra aplicación, utilizamos tres tipos de tokens: el token de inclusión (IT) indica que su entidad se superpone o está cubierta por la celda dada. El token de apariencia (AT) denota que su entidad es una TI para la célula dada, pero no para la célula previamente adyacente. El token de desaparición (DT) es lo contrario de AT, lo que significa que si bien su entidad no satisface la relación de TI con la célula dada, lo hace con la célula previamente adyacente. También definimos dos estructuras de datos para almacenar y recuperar los tokens: un nodo y un borde. Un nodo es una estructura de datos que almacena su de una celda. Por lo tanto, el nodo para la celda I se define como un conjunto de entidades de TI y se expresa formalmente como ni = {o | o.r∩i.r = ∅}, donde r es una región AOI o una celda. Un borde es otra estructura de datos para dos celdas adyacentes que almacena sus AT o DT. Si el borde solo almacena las entidades AT, se denomina un borde de apariencia (AE);De lo contrario, si almacena DTS, se denomina un borde de desaparición (DE). El AE para dos células adyacentes I y J se define como un conjunto de ATS y se expresa como E+(I, J) = NJ - (Ni ∩ NJ) (1) donde Ni y Nj son las estructuras de nodo para las celdas I y J. El DE para dos células adyacentes I, J se define como un conjunto de DTS, satisfactorios: e− (i, j) = ni - (ni ∩ nj) (2) en un mapa 2D, dependiendo de la relación adyacencia entre dos vecinosLas celdas, los bordes se clasifican adicionalmente como cualquiera de las filas, si dos vecinos son adyacentes horizontalmente (ER), o en columna, si son adyacentes verticalmente (EC). En consecuencia, los bordes son de cuatro tipos diferentes, de acuerdo con su tipo de token y adyacencia: ER +(I, J), ER - (I, J), EC +(I, J) y EC - (I, J).4.3 La partición de la cuadrícula de indexación de nodos es un método de subdivisión espacial popular que recientemente ha ganado popularidad para indexar entidades en movimiento en entornos virtuales altamente dinámicos [12, 8, 13, 10]. Para resaltar la diferencia en nuestro método recientemente propuesto, calificamos todas las indexación de nodos de métodos de indexación basados en divididos de cuadrícula existentes. La indexación de nodos divide el espacio en subespacios de tamaño Equi (celdas de cuadrícula), indexa entidades en cada celda y busca entidades que satisfagan una condición espacial con una consulta dada. En muchas aplicaciones de LBS, la indexación de nodos mantiene una estructura de nodo por celda y almacena un índice de entidades cuya extensión espacial es una ubicación puntual. Para una consulta de rango dada, se realiza una búsqueda a partir de las estructuras de nodo de las células cuya región se cruza con la extensión espacial de la consulta de rango. Debido al uso de una geometría de punto simple para entidades, esto permite actualizaciones de índice livianos. Gran parte del trabajo existente cae en esta categoría. Sin embargo, si la extensión espacial de una entidad es una geometría compleja como el rectángulo, la indexación de nodos sufrirá una degradación significativa del sistema debido a la costos de actualización. Por ejemplo, un solo movimiento de una entidad cuya extensión espacial se superpone con 100 células de cuadrícula requiere 100 deleciones de tokens e 100 inserciones de tokens, en el peor de los casos. Se ha informado que uno de los métodos populares de indexación de nodos, la indexación de consultas, tiene dicha degradación del rendimiento durante la actualización de consultas de rango en forma de rectángulo [13]. Para el espacio de muestra que se muestra en la Figura 2, el concepto de indexación de nodos se ilustra en la Figura 3 (a). Cada celda almacena entidades que se cruzan con su región. El procesamiento de la consulta para el Spectator S significa buscar en la estructura del nodo cuya región celular se cruza con S. En la Figura 3 (a), E2 se indexa en la misma celda, lo que se entrega al cliente S después de la evaluación de la consulta.4.4 Indexación de borde Nuestro nuevo método de indexación, la indexación de borde, está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula. Sus características son (1) una estructura de borde y (2) actualización de entidad periódica y evaluación celular.4.4.1 Estructura del borde de la idea La característica principal de nuestro enfoque es que mantiene estructuras de borde en lugar de usar estructuras de nodo. Con este enfoque, se elimina la redundante entre dos células adyacentes (Ni ∩nj). En un mapa de cuadrícula 2d m × m, cada celda I está rodeada por cuatro células vecinas (i− 1), (i+ 1), (i− m), (i+ m) (excepto las 405 células más exteriores) y ocho diferentesEstructuras de borde. Si las dos primeras células vecinas están adyacentes horizontalmente a I y las dos últimas células (I - M), (i +m) están verticalmente cerca, las estructuras de ocho borde son EC +(i - M, I), EC - (I (I−m, i), er +(i - 1, i), er - (i - 1, i), er +(i, i +1), er - (i, i +1), ec +(i,i + m), y ec - (i, i + m). La Figura 3 (b) ilustra cómo se construyen las estructuras de borde a partir de las estructuras de nodo, utilizando las ecuaciones 1 y 2. Inversamente, el proceso de evaluación celular con indexación de borde deriva estructuras de nodos de las estructuras de borde. Si alguna estructura de nodo y todas las estructuras de borde se conocen a priori, podemos derivar todas las estructuras de nodo según lo definido por Lemma 1. La prueba del lema 1 es trivial, ya que se induce fácilmente de las ecuaciones 1 y 2. Lema 1. NJ, un conjunto de su de una célula J se puede derivar de un conjunto de su Cell I, Ni y sus bordes E+(i, J) - E− (i, J): NJ = Ni+E+(i, j)-e− (i, j) Las estructuras de borde de la columna y las columnas, sin embargo, capturan cierta información redundante. Por lo tanto, la indexación de borde na¨ıve almacena más tokens que la indexación de nodos: el número total de tokens de borde que se muestran en la Figura 3 (b) es 35 (17 ATS + 17 dts + 1 it);Para la indexación de nodos en la Figura 3 (a) el número es 25. Para reducir dicha redundancia, se puede aplicar un algoritmo posterior de dos pasos a la indexación de borde original. Actualización periódica de la entidad y evaluación celular Muchos objetos se mueven continuamente y, por lo tanto, las estructuras de índice deben actualizarse regularmente. En general, esto se realiza a través de un algoritmo de TWOSTEP [13] que funciona de la siguiente manera. El algoritmo comienza actualizando todos los índices correspondientes de entidades recién movidas (el paso de actualización de la entidad) y luego calcula las estructuras de nodo de cada celda (el paso de evaluación de la celda). Después de una evaluación de una celda, se recuperan las entidades de usuario indexadas y la estructura de nodo calculada se entrega para cada cliente asociado con un usuario. Después de que se evalúan todas las células, el algoritmo comienza de nuevo. El algoritmo de dos pasos también se puede utilizar para nuestra indexación de borde actualizando las estructuras de borde de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lemma 1 durante las evaluaciones celulares. Además de esta adaptabilidad, el lema también revela otra propiedad importante de las evaluaciones celulares: los bordes de fila o los bordes de la columna son suficientes para obtener todas las estructuras de nodos. Supongamos que el sistema mantiene los bordes en cuanto a hileras. Se supone que las estructuras de nodo más a la izquierda se obtienen de antemano. Una vez que conocemos la estructura del nodo de la celda más a la izquierda por fila, podemos calcular la de su celda de la mano derecha desde la estructura del nodo más a la izquierda y los bordes en términos de hilera. Repetimos este cálculo hasta llegar a la célula más derecha. Por lo tanto, sin ningún bordes de columna podemos obtener todas las estructuras de nodo con éxito. Como resultado, reducimos la complejidad de la construcción y actualización del índice en un factor de dos. La Figura 3 (c) ilustra el concepto de nuestro método de indexación de borde de hilera. El número total de tokens se reduce a 17 (8 ATS + 8 DTS + 1 IT). El análisis detallado de su complejidad de indexación se presenta en la Sección 5. 4.4.2 Otro ejemplo, la Figura 4 ilustra cómo construir estructuras de borde a partir de dos células cercanas. En la figura, dos células adyacentes 3 y 4 en cuanto a hileras tienen dos transiciones de borde en cuanto a hilera entre ellas, E+(3, 4), E− (3, 4);Entidades de dos puntos P1, P2;y dos entidades poligonales R1, R2. Como se muestra en la figura, los índices N3 {P2, R1, R2} y N4 mantienen los índices de {P1, R2}. E+(3, 4) se obtiene de la ecuación 1: n4 - (n3 ∩ n4) = {p1}. Del mismo modo, e− (3, 4) = n3 - celda 3 celda 4 e+(3, 4) = {p1} e_ (3, 4) = {p2, r1} p2 p1 r2 r1 Figura 4: Ejemplo de indexación de borde deEntidades de dos puntos {P1, P2} y dos entidades poligonales {R1, R2} entre dos celdas adyacentes en cuanto a filas.(N3 ∩ n4) = {p2, r1}. Si sabemos N3, E+(3, 4) y E− (3, 4), podemos calcular N4 de acuerdo con Lemma 1, N4 = N3+E+(3, 4) - E− (3, 4) = {{P1, R2}. El cálculo anterior también corresponde a nuestra intuición. P2, R1, R2 se superponen con la celda 3, mientras que P1, R2 se superpone con la célula 4. Al transmitir de la celda 3 a 4, el algoritmo reconocerá que P2, R1 desaparecen y P1 aparece recientemente, mientras que la condición espacial de R2 no cambia. Por lo tanto, podemos insertar P2, R1 en el conjunto de borde de desaparición e insertar P1 en el conjunto de borde de apariencia. Obviamente, la indexación de borde es ineficiente para indexar una geometría puntual. La indexación de nodos tiene una entidad de TI por punto y requiere una eliminación de tokens y una inserción en cualquier movimiento de ubicación. La indexación de borde, sin embargo, requiere una entidad DT por punto y dos eliminaciones de tokens y dos inserciones durante la actualización, en el peor de los casos. En tal situación, aprovechamos el uso de ambos de acuerdo con la propiedad espacial de la extensión de la entidad. En resumen, como se muestra en la Figura 3 (c), nuestro método de indexación de borde utiliza estructuras de borde para las entidades habilitadas para AOI (A, E1, E2) mientras usa estructuras de nodos para la (s) entidad puntual.4.5 Problemas de optimización En esta sección, describimos varias técnicas de optimización para la indexación de borde, lo que reduce significativamente la complejidad del algoritmo.4.5.1 Enfoque de la tabla única: Actualizar típicamente, existen dos políticas prácticas para una actualización de la región: la actualización completa simplemente elimina cada token de la región de la entidad anterior y vuelve a insertar tokens recientemente actualizados en áreas recién posicionadas. La actualización incremental solo elimina los tokens cuya relación espacial con las celdas cambió en una actualización y las inserta en nuevas estructuras de borde que satisfacen las nuevas condiciones espaciales.4.5.2 Enfoque de dos tablas: separar entidades móviles de entidades estacionarias Hasta ahora, no hemos abordado ningún efecto secundario de las eliminaciones de tokens durante la operación de actualización. Supongamos que se realiza un índice de borde con una tabla hash. Insertar un token se implementa insertándolo en la cabeza del cubo hash correspondiente, por lo tanto, el tiempo de procesamiento se vuelve constante. Sin embargo, el tiempo de eliminación de tokens depende del número esperado de tokens por cubo hash. Por lo tanto, la implementación del hash puede sufrir una penalización significativa en el sistema cuando se usa con una gran cantidad de entidades pobladas. La indexación de bordes de dos tablas está diseñada para que la eliminación de token sea constante. Primero, dividimos una estructura de borde único que indexa entidades estacionarias y en movimiento en dos borde separado 406 Tabla 1: Resumen de anotaciones para entidades virtuales y sus propiedades. Símbolo Significado U Conjunto de entidades de objetos poblados o conjunto de entidades de objetos en movimiento, o ⊆ u uq conjunto de entidades de usuario pobladas q conjunto de entidades de usuario en movimiento, q ⊆ uq un conjunto de avatares, a = {a | a ∈ U ∩ uq}I.P ubicación de la entidad I donde i ∈ (u ∪ uq) i.r aoi de entidad i donde i ∈ (u ∪ uq) mi longitud lateral de la entidad i donde i ∈ (u ∪ uq). Está representado por el número de unidades celulares.M Longitud del lado promedio de la varianza AOI de Entidades V AR (MI) de la distancia de la variable aleatoria MI V Máxima distancia accesible. Está representado por el número de unidades celulares.estructuras. Si una entidad no se mueve, sus tokens se colocarán en una estructura de borde estacionaria. De lo contrario, se colocará con un borde en movimiento. En segundo lugar, todas las estructuras de borde en movimiento se reconstruyen periódicamente. Después de la reconstrucción, todas las células de la cuadrícula se evalúan para calcular sus conjuntos visibles. Una vez que se evalúan todas las células, los bordes móviles se destruyen y el paso de reconstrucción sigue. Como resultado, las operaciones de búsqueda en las estructuras del borde en movimiento ya no son necesarias y el sistema se vuelve insensible a cualquier patrón de distribución subyacente y la velocidad de movimiento de las entidades. Se utiliza una implementación de la lista vinculada individualmente para la estructura del borde móvil.5. Análisis Analizamos tres esquemas de indexación cuantitativamente (indexación de nodos, indexación de bordes e indexación de borde de dos tablas) en términos de utilización de memoria y tiempo de procesamiento. En este análisis, suponemos que las estructuras de nodo y borde se implementan con tablas hash. Para las manipulaciones de tabla hash, asumimos tres funciones de acceso de memoria: inserción del token, eliminación de tokens y escaneo de tokens. Sus costos de procesamiento son denotados por TA, TD y TS, respectivamente. Una operación de escaneo de tokens lee los tokens en un cubo hash secuencialmente. Se usa ampliamente durante las evaluaciones celulares. TS y TD son una función del número de tokens en el cubo, mientras que TA es constante. A los fines del análisis, definimos dos variables aleatorias. Una variable, denotada por Mo, representa la longitud lateral de la AOI de una entidad o. Las longitudes laterales se distribuyen uniformemente en el rango de [mmin, mmax]. El valor promedio de Mo se denota por m.La segunda variable aleatoria V denota la distancia máxima diireccional o ydireccional de una entidad móvil durante un intervalo de tiempo. El movimiento simulado de una entidad durante el tiempo dado también se distribuye uniformemente en el rango de [0, V]. Para un cálculo simple, ambas variables aleatorias se expresan como el número de unidades celulares. La Tabla 1 resume las anotaciones simbólicas y su significado.5.1 Los requisitos de memoria permiten que el tamaño del token se denote por s.La indexación de nodos usa S · | UQ |Unidades de memoria para entidades de usuario y S · èo∈U (Mo + 1) 2 ≈ S (M2 + 2M + 1 + V AR (Mo)) | U |Unidades para entidades de objetos. La indexación de borde de una sola mesa consume S · | UQ |Unidades de almacenamiento para las entidades de usuario y S · èo∈U 2 (Mo + 1) ≈ 2s (m + 1) | U |para las entidades objeto. La indexación de borde de dos tablas ocupa S · | UQ |Unidades para los usuarios y S {èi∈O 2 (Mi+1)+èj∈ (U - O) 2 (MJ +1)} ≈ 2s (m+1) | U |Unidades para los objetos. La Tabla 2 resume estos resultados. En nuestro objetivo, APTIBLE 2: Requisitos de memoria de diferentes métodos de indexación.Método de indexación Entidades de usuario Entidades de objeto Indexación del nodo S · | UQ |s ((m + 1) 2 + v ar (mo)) | u |borde de una mesa única s · | uq |2s (m + 1) | u |Edge de dos tablas S · | UQ |2s (m + 1) | u |PLICACIÓN, nuestros métodos de indexación de borde consumen aproximadamente m+1 2 veces menos espacio de memoria que la indexación de nodos. Diferentes particiones de celdas de cuadrícula con métodos de borde conducirán a diferentes requisitos de memoria. Por ejemplo, aquí hay dos cuadrículas: una cuadrícula M × M y una cuadrícula de 2 m × 2m. El requisito de memoria para las entidades de usuario no cambia porque depende solo del número total de entidades de usuario. Los requisitos de memoria para las entidades de objeto son aproximadamente 2s (m + 1) | U |En el caso de la cuadrícula M × M y 2s (2m + 1) | U |para la cuadrícula (2m) × (2m). Por lo tanto, un tamaño de celda cuatro veces mayor conducirá a un número de tokens aproximadamente dos veces menor.5.2 Costo de procesamiento En esta sección, nos centramos en el análisis de costos de las operaciones de actualización y las evaluaciones celulares. Para una comparación justa de los diferentes métodos, solo analizamos la complejidad del tiempo de ejecución de los objetos en movimiento y los usuarios de mudanza.5.2.1 Costo de actualización Suponemos que un conjunto de objetos móviles o y un conjunto de usuarios móviles Q son conocidos de antemano. Similar a la indexación de borde, la indexación de nodos tiene dos políticas de actualización: actualización completa y actualización incremental. La actualización completa, implementada en el índice Q [13] y Sina [10], elimina todos los tokens antiguos de las estructuras de nodo celular antiguas e inserta todos los tokens nuevos en los nodos de celdas nuevas. La política de actualización incremental, implementada por ningún trabajo existente, elimina e inserta todos los tokens cuya condición espacial cambió durante un período. En este análisis, solo consideramos la indexación de nodos incrementales. Para analizar el costo de actualización de la indexación de nodos, presentamos la distancia máxima accesible (v), donde la siguiente ubicación de una entidad móvil, cuya ubicación anterior estaba en la celda (0,0), se distribuye uniformemente sobre (± V, ±v) espacio de celda de cuadrícula como se ilustra en la Figura 5. También suponemos que la distancia máxima alcanzable dada es menor que cualquier longitud lateral del AOI de los objetos en el sistema;es decir, v <mo donde o ∈ O. Como se ve en la Figura 5, la siguiente ubicación puede caer en tres categorías: áreas A, B y el área de la celda central (0,0). Si un objeto reside en la misma celda, no habrá actualización. Si el objeto se mueve hacia el área A, habrá (i + j) (Mo + 1) - IJ Insercios y eliminaciones, donde 1 ≤ I, J ≤ v. De lo contrario, habrá k (Mo + 1) Tokeninserciones y eliminaciones, donde 1 ≤ k ≤ v. Por lo tanto, el tiempo de procesamiento esperado de una actualización de objeto para la indexación de nodos es la suma de tres tipos de movimiento diferentes t nodo por actualización (o) = 4 · (a) + 4 · (b (b) (2v + 1) 2 · (ta + td) = v (v + 1) {v (4mo + 3 - v) + 2 (mo + 1)} (2v + 1) 2 · (ta + td) (3) y el tiempo de procesamiento esperado de cualquier objeto para la indexación de nodos se obtiene mediante el nodo t por actualización = èo∈O, v <mo t nodo por actualización (o) | o |= V (V + 1) {V (4M + 3 - V) + 2M + 1)} (2V + 1) 2 · (Ta + Td) (4).407 Tabla 3: Costo de tiempo de actualización para cualquier evento de actualización único donde V <MQ, MO y Q ∈ Q. Consultas del método de indexación × (Ta + Td) (segundos) Objetos × (Ta + Td) (segundos) Indeportación con actualización incremental| P || O |· V (V+1) {V (4M+3-V) +2 (M+1)} (2V+1) 2 Independiente de borde de una sola mesa con actualización completa | Q || O |· 2 (m + 1) indexación de borde de una sola mesa con actualización incremental | Q || O |· V (4m (1+2v)+9v+5) (2v+1) 2 indexación de borde de dos table | Q |· Ta ta+td | o |· 2 (M + 1) Ta Ta + Td Distancia máxima alcanzable (V) (0,0) I J (I, J) A A AA B B B B Figura 5: Ilustración de la siguiente ubicación de celda, celda (i, j), de un movimiento en movimientoentidad cuya ubicación inicial estaba en la celda (0, 0). El tiempo esperado de cualquier actualización de la entidad para la indexación de borde con actualización completa es: t EdgeFull por actualización = èo∈O t EdgeFull por actualización (o) | o |= 2 (m + 1) (ta + td) (5) El análisis del tiempo esperado de cualquier actualización de entidad para la indexación de borde con actualización incremental se vuelve complicado porque el costo de tiempo depende tanto de la longitud lateral de la entidad AOI como enla velocidad de movimiento. En términos generales, su peor costo de procesamiento es el mismo que Tedgefull por actualización. Debido a las limitaciones de espacio, solo mostramos el resultado del análisis del tiempo de procesamiento esperado cuando v de cualquier objeto o ∈ O es más pequeño que Mo: tedingincremental por actualización = èo∈O, v <mo tedgeincincremental por actualización (o) | o |= v (4m (1 + 2v) + 9v + 5) (2v + 1) 2 · (ta + td) = v (4m (1 + 2v) + 9v + 5) (2v + 1) 2 · 2 (m+ 1) · Tedgefull por actualización (6) Todas las complejidades de actualización se resumen en la Tabla 3. En esta tabla, es evidente que, si bien el costo de actualización de la indexación de borde en peor de los casos (indexación de borde de la tabla única con política de actualización completa) depende solo de M, el de la mejor indexación de nodo (indexación de nodos con política de actualización incremental) todavía es proporcional a dos variables, V y M.Para un valor más pequeño de V (V = 1), el costo de actualización de la indexación de nodos supera ligeramente el de la indexación de borde (es decir, 12m + 8 9 vs. 2 (m + 1)). Sin embargo, a medida que V aumenta, la ganancia de rendimiento se invierte inmediatamente (es decir, 60m + 24 25 versus 2 (m + 1), donde v = 2). Otro resultado interesante es que la indexación de bordes de dos table depende solo del costo de inserción del token, TA. Por lo general, TD es ligeramente 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Distancia máxima accesible (v) (%) #fagedTokens Indexación de dos tiendas indexación incremental indexación de borde completo indexación de nodo incremental Figura 6: Resultados de simulación deActualizar complejidad de diferentes métodos de indexación. La complejidad de la actualización, el número esperado de eliminaciones de tokens e inserciones por actualización del objeto, se dibuja en función de la distancia máxima accesible (v). La longitud lateral promedio del objeto AOIS es el 10% de la longitud lateral de un mapa 2-D dado.mayor que TA porque TD requiere al menos una operación de búsqueda de tokens. Después de la búsqueda, TD ejecuta la operación inversa de TA. Por lo tanto, TD puede expresarse como (ta + tlookup) y puede simplificarse como (ta + | e | 2 · b · ts) donde | e |es el tamaño de la estructura del borde y B es el número de sus cubos hash. A partir de esta observación, podemos inferir esa actualización completa de la indexación de borde de una sola mesa lleva al menos el doble de tiempo que la actualización de la indexación de borde de dos tablas. La Figura 6 muestra que la actualización completa de la indexación de borde cuando la distancia máxima alcanzable es menor que la longitud lateral de cualquier entidad móvil tarda constantemente en actualizar las estructuras de borde correspondientes, que depende principalmente de la longitud lateral de la AOI dada. En esta figura, suponemos que la longitud del lado promedio del AOI es 0.1 (o 10 %). Sin embargo, el método de indexación de nodos depende no solo de la longitud lateral sino también de la distancia alcanzable. Por lo tanto, la actualización de la entidad en la indexación de nodos es mucho más pesada que la actualización completa para la indexación de borde. Como se esperaba, estos resultados de simulación validan una creencia común de que en entornos menos dinámicos, las actualizaciones incrementales reducen la cantidad de inserciones y eliminaciones de token notablemente, mientras que en entornos extremadamente dinámicos la relación de reducción se vuelve insignificante.5.2.2 Evaluación de celdas Costo de inicio de la indexación de nodo Todas las entidades y luego recopila las entidades de usuario indexadas en cada nodo celular. Por lo tanto, tomaría | Q | × TS escanear todas las entidades de usuario. Si cada nodo almacena (m2+2m+1+v ar (mo)) | o |Entidades de objeto M2 En promedio, el tiempo de finalización esperado de una evaluación de una celda será èo∈O (m2+2m+1+v ar (mo)) | o |M2 · ts. Si cada celda tiene como máximo una entidad de usuario, el tiempo de finalización esperado de todas las evaluaciones de células será | Q |· (M2+2m+1+v ar (mo)) | o |M2 · ts. La complejidad en tiempo de ejecución de la evaluación de células de una sola mesa puede 408 Tabla 4: Resumen del costo de evaluación celular.Método de indexación esperado Indeporación de tiempo de tiempo transcurrido TS · | Q |· (M2+2m+1+v ar (mo)) | o |M2 Borde de una mesa única TS · (| Q | + | O | · 2 (M + 1)) Bordamiento de dos table (TS + TD) · (| Q | + | O | · 2 (M + 1)) Be Besimplificado como TS · | o | · 2 (M +1). En este análisis, no consideramos ninguna sobrecarga de entrega de datos después de una evaluación celular. Tenga en cuenta que en la indexación de borde de una sola mesa necesitamos escanear todos los tokens para evaluaciones celulares. La indexación de borde de dos tablas se ejecuta en TD para eliminar los tokens evaluados después de una evaluación celular. A diferencia de la operación TD, la operación TD es mucho más ligera porque no requiere ninguna operación de búsqueda. La Tabla 4 muestra las complejidades esperadas de diferentes escenarios de evaluación celular. Si los conjuntos de resultados calculados previamente se reutilizan durante la próxima ronda de evaluación, el tiempo transcurrido esperado de la indexación de nodos estará unido por el número total de evaluaciones de células (es decir, TS (M2 + 2M + 1 + V AR (Mo)) |O |). Sin embargo, en el peor de los casos, la evaluación celular de la indexación de nodos sigue siendo m+1 2 veces más larga que la de cualquier método de indexación de borde.5.2.3 Ponerlo: costo de monitoreo periódico Como vimos en la Sección 5.2.1, los métodos de indexación de borde superan la indexación del nodo en términos de actualizaciones y evaluaciones de celdas. En esta sección nos centramos en evaluar la diferencia de rendimiento entre la indexación de borde de una sola mesa y la indexación de borde de dos table. El tiempo total transcurrido de la indexación de borde de la mesa única basada en actualización completa para un conjunto dado de entidades móviles es la suma del tiempo transcurrido de las actualizaciones y las evaluaciones celulares: (Ta + Td + Ts) · {| Q |+ | O | 2 (m + 1)} (7) De manera similar, el tiempo total transcurrido de la indexación de bordes de dos tablas es el siguiente: (ta + td + ts) · {| q |+ | O | 2 (m + 1)} (8) De la ecuación 7 y 8 concluimos que la indexación de borde de dos table, a pesar de que representa una optimización menor de la indexación de borde de una mesa única al reemplazar TD impredecible con TD predecible, lograuna mejora significativa del rendimiento. En primer lugar, TD es muy predecible y un procedimiento más liviano que TD. Todos los gastos generales de manipulación de la estructura de datos, como TA, TS y TD, se pueden perfilar fácilmente y todos se vuelven constantes. Además, se garantiza que la indexación dituable superará la indexación de borde de actualización completa de la mesa única. Otra novedad del enfoque de dos tablas es que es muy resistente a la distribución de datos subyacente, independientemente de si es muy sesgado o uniforme. La ecuación 8 también revela el intervalo de tiempo mínimo que satisface los parámetros de entrada dados, ta, ts, td, | q |, | o | y m.Mientras que TA, TS y TD son parámetros específicos del sistema, | O |, | Q | y M son todos específicos de la aplicación. Este último puede ser configurado por el primero y cualquier restricción en tiempo real d. Por lo tanto, el rendimiento del sistema, cuántos objetos y usuarios móviles son compatibles con el sistema dado, se obtiene de la Ecuación 9. Rendimiento máximo del sistema = | Q |+ | O | 2 (m + 1) = t ts + ta + td (9) Por ejemplo, si un sub-mundo dado solo se llena con avatares móviles, a = q = o, cuya longitud del lado promedio es el 10% deLa longitud del lado del mapa, luego TS + TD toma 0.42 microsegundos por evaluación de tokens, y TA toma 0.78 microsegundos, y el sistema manejará aproximadamente 36,231 avatares por segundo. Cada avatar puede navegar en el sub-mundo libremente y el mismo número de clientes conectados remotamente recibe los últimos eventos de actualización continuamente.6. Evaluación Esta sección presenta dos configuraciones de simulación y sus resultados de rendimiento. La Sección 6.1 examina si nuestro nuevo enfoque de vista es superior a los modelos de vista existentes, a pesar de su mayor complejidad de indexación. La Sección 6.2 analiza el grado de practicidad y escalabilidad de nuestro método de indexación diseñado para nuestro nuevo modelo de vista.6.1 Justificación Iniciada con View Modelo 6.1.1 Métricas de evaluación Para cuantificar la calidad de los resultados recuperados del procesamiento de consultas, utilizamos dos métricas de evaluación ampliamente conocidas, precisión (P) y recuerdo (R), que estiman el grado de precisión y comprensión de AConjunto de resultados dado [15]. P es la relación de artículos relevantes y recuperados para todos los artículos recuperados. Un valor más bajo de P implica que el conjunto de resultados de la consulta contiene una gran cantidad de objetos innecesarios que no tienen que ser entregados a un cliente. Un valor P más alto significa una carga de tráfico de red más alta de lo requerido. R es la relación de elementos relevantes y recuperados a todos los artículos relevantes. Un valor R más bajo significa que se ignoran más objetos que deben reconocerse. A partir de la medida R, podemos estimar cuantitativamente la aparición de estallidos de objetos. Además de las métricas P y R, utilizamos una métrica de evaluación de consultas de valor único estandarizado que combina P y R, llamado emasure [15]. La medida E se define como: E = 1-(β2 + 1) PR β2p + R donde β es la importancia relativa de P o R. Si β es igual a 1, P y R son igualmente importantes. Si β es inferior a 1, P se vuelve más importante. De lo contrario, R afectará significativamente la medida. Un valor de medición electrónica más bajo implica que el modelo de vista probado tiene una calidad de mayor calidad. El mejor valor de medida electrónica es cero, donde los mejores valores para P y R son ambos.6.1.2 Configuración de simulación Probamos cuatro esquemas de procesamiento de consultas, que utilizan un modelo de vista iniciado por el usuario o iniciado por el objeto: • Cálculo de visibilidad iniciado por el usuario-RQ-OP: consulta de región-Punto de objeto • Computación de visibilidad orientada a objetos-PQ -OR: Consulta de puntos - Región de objeto - RQ -OR: Consulta de región - Región de objeto - ACQ -OR: Consulta de celda aproximada - Región de objeto RQ -OP es el esquema de cálculo típico que recopila todos los objetos cuya ubicación está dentro de un AOI definido por el usuario. PQ-o recoge un conjunto de objetos cuyo AOI se cruza con un punto de usuario dado, formalmente {o | q.p ∈ O.r}. RQ-o, un esquema de cálculo imaginario, es la combinación de RQ-OP y PQ-OR donde el AOI de un objeto se cruza con la de un usuario, {o | o.r ∩ q.r = ∅}. Por último, ACQ-OR, un modelo de cálculo de visibilidad aproximado, es un esquema especial diseñado para la partición espacial basada en la cuadrícula, que es nuestra elección de la metodología de evaluación celular para la indexación de bordes. Si un espacio virtual se divide en celdas de mosaico y un punto de usuario pertenece a una de las celdas, el ACQ o busca los objetos cuyos AOI 409 Tabla 5: P y R cálculos de diferentes esquemas de determinación de visibilidad. Esquema P r rq-op | {o | o.p ∈Q.r∧q.p ∈O.r)} || {o | o.p ∈Q.r} || {o | o.p ∈Q.r∧q.p ∈O.r)} || {o | q.p ∈O.r} |Pq-or | {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 | {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 rq-or | {o | q.p ∈O.r} || {o | q.r∩o.r = ∅} || {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 acq-or | {o | q.p ∈O.r} || {o | c.r∩o.r = ∅, q.p ∈C.R} || {o | q.p ∈O.r} || {o | q.p ∈O.r} |= 1 se cruzaría con la región de la celda de la cuadrícula correspondiente. Por supuesto, exhibe propiedades similares que RQ-OR, mientras que el conjunto de resultados de su consulta no es un subconjunto del resultado de la consulta RQ-o. Identifica cualquier objeto o satisfacer la condición c.r ∩ o.r = ∅ donde la celda c satisface q.p ∈ C.r también. Nuestro programa de simulación pobló 100k entidades de objetos y 10k entidades de usuario en un espacio de unidades 2D, [0, 1) × [0, 1). Las entidades pobladas están ubicadas uniformemente en el espacio de la unidad. La longitud lateral de su AOI también se asigna uniformemente en el rango de [0.05, 0.14], lo que significa del 5% al 14% de la longitud lateral del espacio de la unidad. El programa realiza pruebas de intersección entre todos los usuarios y todas las entidades de objetos exhaustivamente y calcula los valores P, R y de medición electrónica (que se muestran en la Tabla 5).6.1.3 Distribución de resultados experimentales de la medida P y R: La Figura 7 muestra la distribución de P y R para RQ-OP. Podemos observar que P y R son aproximadamente inversamente proporcionales entre sí al variar una gama AOI de usuario. Una longitud lateral más pequeña conduce a una mayor precisión pero una mayor amplitud. Por ejemplo, el 5% de la longitud lateral de un usuario AOI detecta todos los objetos cuya longitud lateral del AOI es al menos 5%. Por lo tanto, cada objeto recuperado por RQ-OP se garantiza que todo se representa en el cliente. Pero RQ-OP no puede detectar los objetos fuera del AOI del usuario, lo que sufre de demasiados objetos faltantes que deben representarse. Del mismo modo, el usuario cuyo AOI es más amplio que cualquier otro AOI no puede perderse ningún objeto que deba ser representado, pero detecta demasiados objetos innecesarios. Para eliminar cualquier problema de estallido de objetos, la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, lo que puede incurrir en una degradación significativa del sistema. Distribución de la medición electrónica: la Figura 8 revela dos tendencias. Primero, los valores de precisión de RQ-OP se encuentran entre los de ACQ-Or (100 × 100 Grid) y RQ-OR. En segundo lugar, la curva de tendencia de la trama de precisión a la medida de RQ-o muestra la semejanza con la de ACQ-OR. Parece que las dos curvas se encuentran en la misma curva imaginaria, lo que transmite que ACQ o hereda las propiedades de RQ-OR. Efecto del tamaño de la cuadrícula diferente: la Figura 9 muestra la diferencia estadística de los valores de medición electrónica de siete esquemas de partición de cuadrícula diferentes (usando ACQ-OR) y un modelo RQ-OP. Utilizamos una trama de caja y bigotes para mostrar tanto los valores medios como las variaciones de las distribuciones de medidas electrónicas y los valores atípicos de cada esquema. También dibujamos el valor medio de las medidas electrónicas RQ-OP (línea verde) para fines de comparación. Si bien los esquemas ACQ-OR tienen algunos valores atípicos, sus valores de medición electrónica se concentran en torno a los valores medios, por lo tanto, son menos sensibles al objeto AOI. Como se esperaba, la partición de la cuadrícula de grano fino mostró un valor de medida electrónico más pequeño. El esquema RQ-OP mostró una varianza más amplia de su calidad que otros esquemas, que es en gran medida atribuible a diferentes longitudes del lado del usuario. A medida que la medida R se vuelve más importante, la calidad de la consulta de ACQ-o se mejora más evidentemente que la de RQOP. De la Figura 9, el esquema de la cuadrícula 20 × 20 tenía una mejor medida electrónica Tabla 6: tiempo transcurrido medido (segundos) de 100k objetos en movimiento y 10k usuarios en movimiento en un entorno de movimiento lento (V = 1).Indexación de tiempo de actualización Tiempo de evaluación Total Tabla de una sola Tabla ULL 3.48 0.82 4.30 Single-TableIncr 2.08 0.80 2.88 Two-Table 1.74 0.93 2.67 Tabla 7: Tiempo transcurrido medido (segundos) de 100k objetos móviles y 10k usuarios en un entorno altamente dinámico (V = V =15).Indexación Tiempo de evaluación Tiempo Total Total de una sola mesa ULL 3.65 0.77 4.42 Tabla de una sola mesa 3.49 0.74 4.23 Two-Table 1.75 0.93 2.68 Valor en un entorno priorizado que en un entorno de igual prioridad. Como resultado, podemos anticipar aproximadamente que al menos la partición de celdas de cuadrícula 20 × 20 recupera una mayor calidad de conjuntos visibles que el RQ-OP.6.2 Evaluación de la indexación de borde En esta sección, presentamos los resultados preliminares de las simulaciones que examinan la aplicabilidad de nuestra implementación de indexación de borde. Para estimar el grado de soporte en tiempo real de nuestro método de indexación, utilizamos el tiempo total transcurrido de actualizar todas las entidades móviles y calcular conjuntos visibles para cada celda. También experimentamos con diferentes políticas de división de cuadrícula y las comparamos con soluciones de búsqueda exhaustivas.6.2.1 Configuración de simulación Implementamos algoritmos de indexación de borde en C y ejecutó los experimentos en un procesador de itanio de 900MHz de 64 bits con 8 GB de memoria. Implementamos un mecanismo de tabla hash generalizado para almacenar estructuras de nodos y borde.6.2.2 Resultados experimentales Costo de monitoreo periódico: las Tablas 6 y 7 muestran los números de rendimiento de diferentes métodos de indexación de borde variando v. La velocidad de mudanza de las entidades también se asignó uniformemente entre 0 y v. En un entorno de movimiento lento (Tabla 6),El método de indexación de borde incremental supera la indexación de borde de actualización completa, debido a las actualizaciones de índice reducidos;El enfoque de dos tablas supera el rendimiento de los esquemas de una sola mesa, principalmente debido a la falta de búsqueda de tokens durante una actualización. Sin embargo, el método de dos tablas mostró un tiempo de evaluación ligeramente más alto que los dos métodos de mesa única debido a su eliminación de token secuencial. La Tabla 7 ejemplificó el tiempo transcurrido de las actualizaciones de índice y las evaluaciones celulares en un entorno altamente dinámico donde los objetos que se mueven lentamente y se mueven dinámicamente coexisten. En comparación con los resultados que se muestran en la Tabla 6, el enfoque de dos tablas produjo números de rendimiento similares independientemente de los entornos móviles subyacentes. Sin embargo, la ganancia de rendimiento obtenida por la política incremental de la tabla única disminuye en comparación con la del entorno en movimiento lento. Efecto de un tamaño de cuadrícula diferente: cuántas actualizaciones de objetos y evaluaciones de células pueden ser compatibles en un período de tiempo determinado es una métrica de rendimiento importante para cuantificar el rendimiento del sistema. En esta sección, evaluamos los resultados de rendimiento de tres modelos de cálculo de visibilidad diferentes: dos métodos de búsqueda exhaustivos impulsados por el cálculo;y un método de indexación de borde de dos tablas con diferentes tamaños de cuadrícula.410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.7 0.8 0.9 1 Recuerdos (R) Precisión (P) 5% Consulta Rango 6% Consulta de rango 7% Rango de rango 8% Rango de rango 9% RangoConsulta 10% Rango de rango Consulta 11% Consulta de rango 12% Consulta de rango 13% Consulta Rango 14% Rango de rango Optimalidad 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precisión (P) e−Medida de optimización RQ - OP RQ - OR ACQ - OR (Celillas de cuadrícula 100x100) 10x10 20x20 50x50 100x100 200x200 500x500 1KX1K RQ -OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 1 1 Medema E -Medición Media Media de RQ - OP Figura 7 Figura 7: Distribución de P y R medido por RQ-OP. Figura 8: Valor de medición electrónica en función del valor de precisión P cuando β = 1. Figura 9: Valor de medición electrónica en función del esquema de partición de la cuadrícula ACQ-QR cuando β = 2. 10k 50k 100k 10 −1 10 0 10 10 1 10 2 # de actualizaciones de objetos (consultas de 10k) TotalelapsedTime (segundos) Tamaño de la población = 100K, rango visible = 5-15%, movilidad = 1% de búsqueda exhaustiva (prueba de intersección) Búsqueda exhaustiva (medida de distancia euclidiana) 200x200 Dos tesas indexación de borde 100x100 dos - indexación de borde de dos tiends 50x50 indexación de borde de dos tiendles Figura 10: Tiempo total transparentede diferentes esquemas de indexación. Los métodos de búsqueda exhaustivos no mantienen resultados intermedios. Simplemente calculan si un punto de usuario dado está dentro de un objeto dado AOI. Pueden tolerar el comportamiento impredecible del movimiento del objeto. A pesar de su diseño y extensibilidad simples, sufren largos retrasos computacionales para completar la determinación de visibilidad. La Figura 10 revela la diferencia de rendimiento entre las soluciones exhaustivas y los métodos de dos tablas, una diferencia de hasta dos órdenes de magnitud. Como se muestra en la Sección 5, el tiempo total transcurrido de las actualizaciones de objetos y las evaluaciones de celdas es lineal con respecto a la longitud lateral promedio del objeto AOI. Debido a que la longitud lateral está representada por las unidades celulares, un aumento en el número de células aumenta las longitudes laterales proporcionalmente. La Figura 10 ilustra que los resultados de simulación medidos coinciden aproximadamente con la ganancia de rendimiento esperada calculada a partir del análisis.7. Conclusión y trabajo futuro para apoyar la extensibilidad dinámica y la escalabilidad en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el modelo de vista iniciado por objetos y su método de indexación eficiente, indexación de borde. En comparación con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de estallido de objetos que pueda observarse fácilmente en entornos virtuales existentes a expensas de una mayor complejidad de indexación. Sin embargo, nuestro modelo de indexación de bordes puede superar dicha complejidad de indexación dicha al indexar extensiones espaciales a nivel de borde, no a nivel de nodo en un sub-mundo dividido en la cuadrícula y se validó a través de análisis y simulaciones cuantitativas. Sin embargo, por ahora nuestra indexación de borde aún conserva una mayor complejidad, incluso en un dominio bidimensional. Actualmente, estamos desarrollando otro método de indexación de borde para que la complejidad de indexación constante. Una vez que la complejidad de la indexación se vuelve constante, planeamos indexar extensiones espaciales 3D y datos de geometría multi-resolución. Esperamos que nuestra indexación de borde pueda contribuir a la implementación exitosa de entornos de juego de próxima generación.8. Referencias [1] D. Marshall, D. Delaney, S. McLoone y T. Ward, Challeges in Modern Distributed Interactive Application Design, Tech. Rep., Departamento de Ciencias de la Computación, Universidad Nacional de Irlanda, Maynooth, Maynooth, Coronel Kildare, Irlanda, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang y Chin-Laung Lei, Análisis de tráfico de juegos: Una perspectiva MMORPG, en NossDav05.2005, pp. 19-24, ACM Press.[3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon y Yanghee Choi, Traffic Charateristics de un juego de rol en línea multijugador masivo y sus implicaciones, en NetGames 05, octubre de 2005. [4] Philip Rosedale y Cory Ondrejka, lo que permite permitirMundos en línea creados por jugadores con computación y transmisión de cuadrícula, revista Gamastutra, http://www.gamasutra.com/Resource Guide/20030916/Rosedale 01.shtml, septiembre de 2003. [5] Eyal Teler y Dani Lischinski, transmisión de complejo 3DEscenas para tutoriales remotos., Comput. Grafico. Foro, vol.20, no.3, 2001. [6] Gerd Hesina y Dieter Schmalstieg, una arquitectura de red para la representación remota, en el segundo taller internacional sobre simulación interactiva distribuida y aplicaciones en tiempo real, 1998. [7] Thomas A. Funkhouser y Carlo H. Sequin, Adaptive Adaptive.Algoritmo de visualización para velocidades de cuadros interactivas durante la visualización de entornos virtuales complejos, en Siggraph 93, Nueva York, NY, EE. UU., 1993, pp. 247-254, ACM Press.[8] Jussi Myllymaki y James Kaufman, indexación espacial de alto rendimiento para servicios basados en la ubicación, en WWW 03, Nueva York, NY, EE. UU., 2003, pp. 112-117, ACM Press.[9] M. Lee, W. Hsu, C. Jensen, B. Cui y K. Teo, que respalda actualizaciones frecuentes en R-Trees: un enfoque ascendente, en VLDB, páginas 608-619, 2003, 2003.[10] Mohamed F. Mokbel, Xiaopeing Xiong y Walid G. Aref, Sina: procesamiento incremental escalable de consultas continuas en bases de datos espacio-temporales, en ACM Sigmod 04. 2004, págs. 623-634, ACM Press.[11] Dmitri V. Kalashnikov, Sunil Prabhakar y Susanne E. Hambrusch, Evaluación principal de la memoria de consultas de monitoreo sobre objetos en movimiento, distribución. Bases de datos paralelas, vol.15, no.2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu y Dik Lun Lee, un marco genérico para monitorear consultas espaciales continuas sobre objetos en movimiento, en la Conferencia Sigmod, 2005. [13] S. Prabhakar,Y. Xia, D. Kalashnikov, W. Aref y S. Hambrusch, Indexación de consultas e indexación restringida de velocidad: técnicas escalables para consultas continuas en objetos en movimiento, transacciones IEEE en computadoras, vol.51, no.10, pp. 1124-1140, octubre de 2002. [14] Yuni Xia y Sunil Prabhakar, Q+Rtree: indexación eficiente para bases de datos de objetos en movimiento, en Dasfaa 03, Washington, DC, EE. UU., 2003, p.175, IEEE Computer Society.[15] C. J. Van Rijsbergen, Recuperación de información, 2ª edición, Departamento de Ciencias de la Computación, Universidad de Glasgow, 1979. 411",
    "original_sentences": [
        "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
        "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
        "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
        "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
        "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
        "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
        "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
        "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
        "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
        "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
        "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
        "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
        "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
        "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
        "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
        "In this paper, we mainly focus on the first two requirements.",
        "Dynamic extensibility allows regular game-users to deploy their own created content.",
        "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
        "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
        "Another important requirement is scalability.",
        "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
        "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
        "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
        "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
        "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
        "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
        "In this model, a server continuously transmits both update events and geometry data to every connected user.",
        "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
        "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
        "The traditional visibility determination approach, however, has an object popping problem.",
        "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
        "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
        "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
        "The visibility calculation for each user not only needs to be accurate, but also fast.",
        "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
        "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
        "Our two novel methods represent the main contributions of this work.",
        "The organization of this paper is as follows.",
        "Section 2 presents related work.",
        "Section 3 describes our new view method.",
        "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
        "We also discuss its optimization issues.",
        "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
        "Finally, we conclude and address future research directions in Section 7. 2.",
        "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
        "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
        "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
        "However, these algorithms assume that all the candidate visible objects have been stored locally.",
        "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
        "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
        "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
        "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
        "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
        "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
        "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
        "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
        "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
        "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
        "The grid-based partitioning model is a special case of fixed partitioning.",
        "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
        "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
        "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
        "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
        "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
        "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
        "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
        "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
        "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
        "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
        "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
        "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
        "Our indexing method is very similar to the above approaches.",
        "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
        "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
        "We then propose our own model, and finally we discuss its strengths and limitations.",
        "To begin with, we define the terminologies commonly used throughout this paper.",
        "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
        "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
        "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
        "It has no shape and is represented only by a point location.",
        "It is designed to allow a game participant to see from a third-person viewpoint.",
        "It functions similar to a camera control in the 3D graphics field.",
        "It also has a higher degree of mobility than other entities.",
        "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
        "It possesses both features: its own viewpoint and visibility.",
        "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
        "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
        "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
        "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
        "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
        "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
        "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
        "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
        "As the user navigates, she continuously searches for all the entities within her AOI.",
        "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
        "However, the user-initiated model has a serious object popping problem during navigation.",
        "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
        "A large AOI, however, may lead to a significant system degradation.",
        "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
        "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
        "Every user entity recognizes the objects whose AOIs cover its point location.",
        "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
        "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
        "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
        "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
        "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
        "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
        "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
        "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
        "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
        "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
        "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
        "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
        "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
        "Second Life is the classic example of such an approach.",
        "A virtual space is partitioned into equal-sized sub-worlds.",
        "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
        "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
        "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
        "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
        "Every sub-world is managed by its dedicated server machine.",
        "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
        "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
        "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
        "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
        "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
        "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
        "This retrieval process is interchangeably called a user (or query) evaluation.",
        "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
        "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
        "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
        "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
        "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
        "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
        "A node is a data structure that stores ITs of a cell.",
        "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
        "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
        "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
        "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
        "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
        "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
        "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
        "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
        "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
        "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
        "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
        "Much of the existing work falls into this category.",
        "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
        "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
        "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
        "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
        "Every cell stores IT entities that intersect with its region.",
        "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
        "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
        "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
        "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
        "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
        "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
        "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
        "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
        "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
        "Lemma 1.",
        "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
        "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
        "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
        "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
        "Generally, this is done through a twostep algorithm [13] that works as follows.",
        "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
        "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
        "After all the cells are evaluated, the algorithm starts over.",
        "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
        "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
        "Let us assume that the system maintains the row-wise edges.",
        "The leftmost node structures are assumed to be obtained in advance.",
        "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
        "We repeat this computation until we reach the rightmost cell.",
        "Hence, without any column-wise edges we can obtain all the node structures successfully.",
        "As a result, we reduce the complexity of the index construction and update by a factor of two.",
        "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
        "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
        "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
        "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
        "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
        "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
        "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
        "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
        "The above calculation also corresponds to our intuition.",
        "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
        "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
        "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
        "Obviously, edge indexing is inefficient for indexing a point geometry.",
        "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
        "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
        "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
        "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
        "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
        "Let us assume that an edge index is realized with a hash table.",
        "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
        "However, the token removal time depends on the expected number of tokens per hash bucket.",
        "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
        "Two-table edge indexing is designed to make the token removal overhead constant.",
        "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
        "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
        "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
        "It is represented by the number of cell units. structures.",
        "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
        "Otherwise, it will be placed with a moving edge.",
        "Second, all moving edge structures are periodically reconstructed.",
        "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
        "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
        "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
        "A singly linked list implementation is used for the moving edge structure. 5.",
        "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
        "In this analysis, we assume that node and edge structures are implemented with hash tables.",
        "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
        "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
        "A token scan operation reads the tokens in a hash bucket sequentially.",
        "It is extensively used during cell evaluations.",
        "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
        "For the purpose of analysis, we define two random variables.",
        "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
        "The side lengths are uniformly distributed in the range of [mmin, mmax].",
        "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
        "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
        "For a simple calculation, both random variables are expressed as the number of cell units.",
        "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
        "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
        "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
        "Table 2 summarizes these results.",
        "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
        "Different grid cell partitioning with edge methods will lead to different memory requirements.",
        "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
        "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
        "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
        "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
        "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
        "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
        "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
        "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
        "In this analysis, we only consider incremental node indexing.",
        "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
        "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
        "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
        "If an object resides in the same cell, there will be no update.",
        "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
        "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
        "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
        "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
        "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
        "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
        "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
        "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
        "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
        "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
        "After the lookup, Td executes the reverse operation of Ta.",
        "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
        "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
        "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
        "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
        "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
        "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
        "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
        "Therefore, it would take |Q|×Ts to scan all user entities.",
        "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
        "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
        "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
        "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
        "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
        "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
        "Table 4 shows the expected complexities of different cell evaluation scenarios.",
        "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
        "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
        "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
        "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
        "First of all, Td is very predictable and a more lightweight procedure than Td.",
        "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
        "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
        "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
        "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
        "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
        "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
        "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
        "EVALUATION This section presents two simulation setups and their performance results.",
        "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
        "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
        "P is the ratio of relevant, retrieved items to all retrieved items.",
        "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
        "A higher P value means a higher network traffic load than required.",
        "R is the ratio of relevant, retrieved items to all relevant items.",
        "A lower R value means that more objects that should be recognized are ignored.",
        "From the R measure, we can quantitatively estimate the occurrence of object popping.",
        "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
        "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
        "If β is less than 1, P becomes more important.",
        "Otherwise, R will affect the E-measure significantly.",
        "A lower E-measure value implies that the tested view model has a higher quality.",
        "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
        "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
        "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
        "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
        "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
        "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
        "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
        "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
        "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
        "The populated entities are uniformly located in the unit space.",
        "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
        "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
        "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
        "A smaller side length leads to higher accuracy but lower comprehensiveness.",
        "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
        "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
        "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
        "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
        "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
        "E-measure Distribution: Figure 8 reveals two trends.",
        "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
        "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
        "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
        "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
        "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
        "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
        "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
        "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
        "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
        "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
        "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
        "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
        "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
        "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
        "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
        "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
        "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
        "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
        "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
        "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
        "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
        "Figure 8: E-measure value as a function of Precision value P when β = 1.",
        "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
        "Exhaustive search methods do not maintain any intermediate results.",
        "They simply compute whether a given user point is inside a given object AOI.",
        "They can tolerate unpredictable behavior of object movement.",
        "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
        "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
        "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
        "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
        "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
        "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
        "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
        "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
        "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
        "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
        "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
        "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
        "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
        "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
        "Graph.",
        "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
        "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
        "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
    ],
    "error_count": 0,
    "keys": {
        "edge indexing": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "<br>edge indexing</br> in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF <br>edge indexing</br> In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for <br>edge indexing</br> follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) <br>edge indexing</br> (c) <br>edge indexing</br> with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 <br>edge indexing</br> Our new indexing method, <br>edge indexing</br>, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with <br>edge indexing</br> derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve <br>edge indexing</br> stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original <br>edge indexing</br>.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our <br>edge indexing</br> by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise <br>edge indexing</br> method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of <br>edge indexing</br> of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, <br>edge indexing</br> is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "<br>edge indexing</br>, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our <br>edge indexing</br> method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for <br>edge indexing</br>, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table <br>edge indexing</br> is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, <br>edge indexing</br>, and two-table <br>edge indexing</br>) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table <br>edge indexing</br> consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table <br>edge indexing</br> occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our <br>edge indexing</br> methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to <br>edge indexing</br>, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table <br>edge indexing</br> with full update |Q| |O| · 2(m + 1) single-table <br>edge indexing</br> with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for <br>edge indexing</br> with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for <br>edge indexing</br> with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case <br>edge indexing</br> (single-table <br>edge indexing</br> with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table <br>edge indexing</br> depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table <br>edge indexing</br> Incremental <br>edge indexing</br> Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table <br>edge indexing</br> takes at least twice as long as the update for two-table <br>edge indexing</br>.",
                "Figure 6 shows that full update of <br>edge indexing</br> when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for <br>edge indexing</br>.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table <br>edge indexing</br> we need to scan all the tokens for cell evaluations.",
                "Two-table <br>edge indexing</br> executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any <br>edge indexing</br> method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, <br>edge indexing</br> methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table <br>edge indexing</br> and two-table <br>edge indexing</br>.",
                "The total elapsed time of full update based single-table <br>edge indexing</br> for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table <br>edge indexing</br> is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update <br>edge indexing</br>.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for <br>edge indexing</br>.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of <br>edge indexing</br> In this section, we present the preliminary results of the simulations that examine the applicability of our <br>edge indexing</br> implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented <br>edge indexing</br> algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different <br>edge indexing</br> methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental <br>edge indexing</br> method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table <br>edge indexing</br> method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table <br>edge indexing</br> 100x100 Two−table <br>edge indexing</br> 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, <br>edge indexing</br>.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our <br>edge indexing</br> model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our <br>edge indexing</br> still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another <br>edge indexing</br> method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our <br>edge indexing</br> can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "\"Indexación de borde\" en una cuadrícula para entornos virtuales altamente dinámicos ∗ beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu de la Universidad del Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 Sistemas de aplicaciones recién emergentes abstractos como talesComo Second Life1, proporciona entornos virtuales 3D donde múltiples usuarios interactúan entre sí en tiempo real.indexación de bordes",
                "Diseño de \"indexación de borde\" en la Sección 4.1 Introducimos nuestro modelo de aplicación objetivo.indexación de bordes",
                "Varios problemas de optimización para la \"indexación de borde\" siguen en la Sección 4.5.4.1 Aplicación de destino Nuestra aplicación de destino asume tanto la transmisión de objetos 3D como el alojamiento del sub-mundo.indexación de bordes",
                "La recuperación de los objetos indexados para un usuario determinado incluye la búsqueda y DE3 Un mejor método de indexación para un espacio 3D es el trabajo en progreso.404 tokens: it (e1) it (e2) it (a) it (s) tokens: at (e1) dt (e1) at (e2) dt (e2) at (a) dt (a) it (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s) (s)a) Indexación de nodo (b) \"indexación de borde\" (c) \"indexación de borde\" con evaluación de celda de fila Figura 3: Ilustración de diferentes estructuras de datos para la indexación de nodos e indexación de borde para el espacio de muestra en la Figura 2. Indexación de borde",
                "El procesamiento de la consulta para el Spectator S significa buscar en la estructura del nodo cuya región celular se cruza con S. En la Figura 3 (a), E2 se indexa en la misma celda, lo que se entrega al cliente S después de la evaluación de la consulta.4.4 \"Indexación de borde\" Nuestro nuevo método de indexación, \"indexación de borde\", está diseñado para proporcionar un método de indexación eficiente para la extensión espacial específica (cuadrado) de las entidades en una cuadrícula.indexación de bordes",
                "Inversamente, el proceso de evaluación celular con \"indexación de borde\" deriva estructuras de nodos de las estructuras de borde.indexación de bordes",
                "Por lo tanto, la \"indexación de borde\" na¨ı almacena más tokens que la indexación de nodos: el número total de tokens de borde que se muestran en la Figura 3 (b) es 35 (17 ATS + 17 dts + 1 it);Para la indexación de nodos en la Figura 3 (a) el número es 25. Indexación de borde",
                "Para reducir dicha redundancia, se puede aplicar un algoritmo posterior de dos pasos a la \"indexación de borde\" original.indexación de bordes",
                "El algoritmo de dos pasos también se puede utilizar para nuestra \"indexación de borde\" actualizando las estructuras de borde de las entidades que se movieron durante el período de tiempo anterior y aplicando el Lemma 1 durante las evaluaciones celulares.indexación de bordes",
                "La Figura 3 (c) ilustra el concepto de nuestro método de \"indexación de bordes\" en términos de filas.indexación de bordes"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "dynamic virtual environment": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely <br>dynamic virtual environment</br>s is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly <br>dynamic virtual environment</br>s [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Específicamente, realizar pruebas de visibilidad en tiempo real en un \"entorno virtual dinámico\" extremadamente es una tarea muy desafiante, ya que millones de objetos y submillones de usuarios activos se están moviendo e interactuando.entorno virtual dinámico",
                "En consecuencia, los bordes son de cuatro tipos diferentes, de acuerdo con su tipo de token y adyacencia: ER +(I, J), ER - (I, J), EC +(I, J) y EC - (I, J).4.3 La partición de la cuadrícula de indexación de nodos es un método popular de subdivisión espacial que recientemente ha ganado popularidad para indexar entidades en movimiento en \"entorno virtual dinámico\" s [12, 8, 13, 10].entorno virtual dinámico"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "game-based application": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging <br>game-based application</br> systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Indexación de borde en una cuadrícula para entornos virtuales altamente dinámicos ∗ beomjoo SEO bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Departamento de Ciencias de la Computación Universidad del Sur de California Los Ángeles, CA 90089 Resumen de \"Aplicación basada en juegos\" recién emergente Sistemas tales como talesComo Second Life1, proporciona entornos virtuales 3D donde múltiples usuarios interactúan entre sí en tiempo real.aplicación basada en juegos"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "mutable virtual content": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, <br>mutable virtual content</br> which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Están llenos de \"contenido virtual mutable\" autónomo que los usuarios aumentan continuamente.Contenido virtual mutable"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "spatial database": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a <br>spatial database</br> problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a <br>spatial database</br> while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to <br>spatial database</br> problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Reconocemos que los desafíos descritos están estrechamente relacionados con un problema de \"base de datos espacial\" y, por lo tanto, asignamos los objetos de geometría en movimiento en el espacio virtual a un conjunto de objetos multidimensionales en una \"base de datos espacial\" mientras modelamos cada avatar tanto como unobjeto espacial y una consulta móvil.base de datos espacial",
                "Aquí reconocemos que tales problemas relacionados con los gráficos tienen una similitud muy cercana a los problemas de \"base de datos espacial\".base de datos espacial"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "spatial indexing method": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new <br>spatial indexing method</br> designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "En la Sección 4, presentamos suposiciones en nuestra aplicación objetivo e presentamos un nuevo \"método de indexación espacial\" diseñado para admitir los cálculos de visibilidad en tiempo real.Método de indexación espacial"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "real-time visibility test": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing <br>real-time visibility test</br>s in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "Específicamente, realizar una \"prueba de visibilidad en tiempo real\" s en entornos virtuales extremadamente dinámicos es una tarea muy desafiante, ya que millones de objetos y submallons de usuarios activos se están moviendo e interactuando.Prueba de visibilidad en tiempo real"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "object-initiated view model": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "<br>object-initiated view model</br> In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call <br>object-initiated view model</br>.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an <br>object-initiated view model</br>: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the <br>object-initiated view model</br>, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "\"Modelo de vista iniciado por objetos\" En esta sección, ilustramos cómo el problema de estallido de objetos puede asociarse con un modelo de decisión de vista típico.modelo de vista iniciado por objetos",
                "Para superar el problema de estallido de objetos, proponemos un nuevo modelo de vista que llamamos \"modelo de vista iniciado por objetos\".modelo de vista iniciado por objetos",
                "El mejor valor de medida electrónica es cero, donde los mejores valores para P y R son ambos.6.1.2 Configuración de simulación Probamos cuatro esquemas de procesamiento de consultas, que utilizan un \"modelo de vista iniciado por objetos\": • Computación de visibilidad iniciada por el usuario-RQ-OP: consulta de región-Punto de objeto • Visibilidad orientada a objetosCOMPUTACIÓN - PQ -OR: Consulta de puntos - Región de objeto - RQ -OR: Región Consulta - Región de objeto - ACQ -OR: Consulta de celda aproximada - Región de objeto RQ -OP es el esquema de cálculo típico que recolecta todos los objetos cuya ubicación está dentro de un usuarioAOI definido.modelo de vista iniciado por objetos",
                "Conclusión y trabajo futuro para respaldar la extensibilidad dinámica y la escalabilidad en entornos altamente dinámicos, propusimos un nuevo paradigma de vista, el \"modelo de vista iniciado por objetos\" y su método de indexación eficiente, indexación de borde.modelo de vista iniciado por objetos"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "object popping": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected <br>object popping</br> and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: <br>object popping</br> occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an <br>object popping</br> problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the <br>object popping</br> problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious <br>object popping</br> problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the <br>object popping</br> problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no <br>object popping</br> problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of <br>object popping</br>.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any <br>object popping</br> problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any <br>object popping</br> problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El objetivo principal de este documento es presentar una estructura de índice espacial eficiente que minimice el \"estallido de objetos\" inesperado y admite una determinación de visibilidad en tiempo real altamente escalable.estallido de objetos",
                "Pero reconocemos que estos requisitos también son válidos para nuevos entornos virtuales.402 Avatar Objeto Poppingautónomos Entidades (a) en el tiempo t (b) En el momento t+δ Figura 1: \"Popping de objeto\" ocurrió a medida que un usuario avanza (capturas de pantalla de Second Life) donde δ = 2 segundos.Emplea un modelo de transmisión de objetos 3D basado en el cliente/servidor [5].estallido de objetos",
                "Sin embargo, el enfoque de determinación de visibilidad tradicional tiene un problema de \"estallido de objetos\".estallido de objetos",
                "Modelo de vista iniciado por objetos En esta sección, ilustramos cómo el problema de \"estallido de objetos\" puede asociarse con un modelo de decisión de vista típico.estallido de objetos",
                "Sin embargo, el modelo iniciado por el usuario tiene un problema grave de \"estallido de objetos\" durante la navegación.estallido de objetos",
                "Para superar el problema de \"estallido de objetos\", proponemos un nuevo modelo de vista que llamamos modelo de vista iniciado por objetos.estallido de objetos",
                "Las principales fortalezas del nuevo modelo son que (1) no tiene ningún problema de \"estallido de objetos\" siempre que el sistema subyacente pueda administrar el rango óptimo visible de todas las entidades de objetos correctamente y que (2) los creadores de contenido pueden producir una expresividad enriquecidade varios cambios conductuales y temporales.estallido de objetos",
                "A partir de la medida R, podemos estimar cuantitativamente la aparición de \"estallido de objetos\".estallido de objetos",
                "Para eliminar cualquier problema de \"estallido de objetos\", la longitud lateral de cualquier AOI debe ser mayor o igual a la distancia máxima visible de cualquier objeto en el sistema, lo que puede incurrir en una degradación significativa del sistema.estallido de objetos",
                "En comparación con el modelo de vista tradicional, nuestro nuevo modelo de vista promete eliminar cualquier problema de \"estallido de objetos\" que se pueda observar fácilmente en entornos virtuales existentes a expensas de una mayor complejidad de indexación.estallido de objetos"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "3d spatial extension": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "3d object stream": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "object pop problem": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "spatial index": {
            "translated_key": "",
            "is_in_text": true,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient <br>spatial index</br> structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known <br>spatial index</br> structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [
                "El objetivo principal de este documento es presentar una estructura eficiente del \"índice espacial\" que minimice el estallido inesperado de objetos y admite una determinación de visibilidad en tiempo real altamente escalable.índice espacial",
                "El árbol R es una estructura de \"índice espacial\" bien conocida que permite superposición entre las regiones en diferentes ramas que están representadas por rectángulos mínimos delimitadores (MBR).índice espacial"
            ],
            "translated_text": "",
            "candidates": [],
            "error": []
        },
        "visibility model": {
            "translated_key": "",
            "is_in_text": false,
            "original_annotated_sentences": [
                "Edge Indexing in a Grid for Highly Dynamic Virtual Environments∗ Beomjoo Seo bseo@usc.edu Roger Zimmermann rzimmerm@imsc.usc.edu Computer Science Department University of Southern California Los Angeles, CA 90089 ABSTRACT Newly emerging game-based application systems such as Second Life1 provide 3D virtual environments where multiple users interact with each other in real-time.",
                "They are filled with autonomous, mutable virtual content which is continuously augmented by the users.",
                "To make the systems highly scalable and dynamically extensible, they are usually built on a client-server based grid subspace division where the virtual worlds are partitioned into manageable sub-worlds.",
                "In each sub-world, the user continuously receives relevant geometry updates of moving objects from remotely connected servers and renders them according to her viewpoint, rather than retrieving them from a local storage medium.",
                "In such systems, the determination of the set of objects that are visible from a users viewpoint is one of the primary factors that affect server throughput and scalability.",
                "Specifically, performing real-time visibility tests in extremely dynamic virtual environments is a very challenging task as millions of objects and sub-millions of active users are moving and interacting.",
                "We recognize that the described challenges are closely related to a spatial database problem, and hence we map the moving geometry objects in the virtual space to a set of multi-dimensional objects in a spatial database while modeling each avatar both as a spatial object and a moving query.",
                "Unfortunately, existing spatial indexing methods are unsuitable for this kind of new environments.",
                "The main goal of this paper is to present an efficient spatial index structure that minimizes unexpected object popping and supports highly scalable real-time visibility determination.",
                "We then uncover many useful properties of this structure and compare the index structure with various spatial indexing methods in terms of query quality, system throughput, and resource utilization.",
                "We expect our approach to lay the groundwork for next-generation virtual frameworks that may merge into existing web-based services in the near future.",
                "Categories and Subject Descriptors: C.2.4 [Computer - Communication Networks]: Distributed Systems - Client/server, Distributed applications, Distributed databases; I.3.7 [Computer Graphics]: Three-Dimensional Graphics and Realism - Virtual Reality General Terms: Algorithms, Design, Performance 1.",
                "INTRODUCTION Recently, Massively Multiplayer Online Games (MMOGs) have been studied as a framework for next-generation virtual environments.",
                "Many MMOG applications, however, still limit themselves to a traditional design approach where their 3D scene complexity is carefully controlled in advance to meet real-time rendering constraints at the client console side.",
                "To enable a virtual landscape in next-generation environments that is seamless, endless, and limitless, Marshall et al. [1] identified four new requirements2 : dynamic extensibility (a system allows the addition or the change of components at run time); scalability (although the number of concurrent users increases, the system continues to function effectively); interactibility; and interoperability.",
                "In this paper, we mainly focus on the first two requirements.",
                "Dynamic extensibility allows regular game-users to deploy their own created content.",
                "This is a powerful concept, but unfortunately, user-created content tends to create imbalances among the existing scene complexity, causing system-wide performance problems.",
                "Full support for dynamic extensibility will, thus, continue to be one of the biggest challenges for game developers.",
                "Another important requirement is scalability.",
                "Although MMOG developers proclaim that their systems can support hundreds of thousands of concurrent users, it usually does not mean that all the users can interact with each other in the same world.",
                "By carefully partitioning the world into multiple sub-worlds or replicating worlds at geographically dispersed locations, massive numbers of concurrent users can be supported.",
                "Typically, the maximum number of users in the same world managed by a single server or a server-cluster is limited to several thousands, assuming a rather stationary world [2, 3].",
                "Second Life [4] is the first successfully deployed MMOG system that meets both requirements.",
                "To mitigate the dynamics of the game world, where a large number of autonomous objects are continuously moving, it partitions the space in a grid-like manner and 2 Originally, these requirements were specified for their dedicated platform.",
                "But we acknowledge that these requirements are also valid for new virtual environments. 402 Avatar Object PoppingAutonomous Entities (a) At time t (b) At time t+Δ Figure 1: Object popping occurred as a user moves forward (screenshots from Second Life) where Δ = 2 seconds. employs a client/server based 3D object streaming model [5].",
                "In this model, a server continuously transmits both update events and geometry data to every connected user.",
                "As a result, this extensible gaming environment has accelerated the deployment of usercreated content and provides users with unlimited freedom to pursue a navigational experience in its space.",
                "One of the main operations in MMOG applications that stream 3D objects is to accurately calculate all objects that are visible to a user.",
                "The traditional visibility determination approach, however, has an object popping problem.",
                "For example, a house outside a users visible range is not drawn at time t, illustrated in Figure 1(a).",
                "As the user moves forward, the house will suddenly appear at time (t + Δ) as shown in Figure 1(b).",
                "If Δ is small, or the house is large enough to collide with the user, it will disrupt the users navigational experience.",
                "The visibility calculation for each user not only needs to be accurate, but also fast.",
                "This challenge is illustrated by the fact that the maximum number of concurrent users per server of Second Life is still an order of magnitude smaller than for stationary worlds.",
                "To address these challenges, we propose a method that identifies the most relevant visible objects from a given geometry database (view model) and then put forth a fast indexing method that computes the visible objects for each user (spatial indexing).",
                "Our two novel methods represent the main contributions of this work.",
                "The organization of this paper is as follows.",
                "Section 2 presents related work.",
                "Section 3 describes our new view method.",
                "In Section 4, we present assumptions on our target application and introduce a new spatial indexing method designed to support real-time visibility computations.",
                "We also discuss its optimization issues.",
                "Section 5 reports on the quantitative analysis and Section 6 presents preliminary results of our simulation based experiments.",
                "Finally, we conclude and address future research directions in Section 7. 2.",
                "RELATED WORK Visibility determination has been widely explored in the field of 3D graphics.",
                "Various local rendering algorithms have been proposed to eliminate unnecessary objects before rendering or at any stage in the rendering pipeline.",
                "View-frustum culling, back-face culling, and occlusion culling are some of the well-known visibility culling techniques [6].",
                "However, these algorithms assume that all the candidate visible objects have been stored locally.",
                "If the target objects are stored on remote servers, the clients receive the geometry items that are necessary for rendering from the server databases.",
                "Teller et al. described a geometry data scheduling algorithm that maximizes the quality of the frame rate over time in remote walkthroughs of complex 3D scenes from a users navigational path [5].",
                "Funkhouser et al. showed that multi-resolutional representation, such as Levels Of Detail (LOD), can be used to improve rendering frame rates and memory utilization during interactive visualization [7].",
                "However, these online optimization algorithms fail to address performance issue at the server in highly crowded environments.",
                "On the other hand, our visibility computation model, a representative of this category, is based on different assumptions on the data representation of virtual entities.",
                "In the graphics area, there has been little work on supporting real-time visibility computations for a massive number of moving objects and users.",
                "Here we recognize that such graphics related issues have a very close similarity to spatial database problems.",
                "Recently, a number of publications have addressed the scalability issue on how to support massive numbers of objects and queries in highly dynamic environments.",
                "To support frequent updates, two partitioning policies have been studied in depth: (1) R-tree based spatial indexing, and (2) grid-based spatial indexing.",
                "The R-tree is a well-known spatial index structure that allows overlapping between the regions in different branches which are represented by Minimum Bounding Rectangles (MBR).",
                "The grid-based partitioning model is a special case of fixed partitioning.",
                "Recently, it has been re-discovered since it can be efficient in highly dynamic environments.",
                "Many studies have reported that the R-tree and its variants (R+ tree, R∗ -tree) suffer from unacceptable performance degradation in a highly dynamic environment, primarily due to the computational complexity of the split algorithm [8, 9, 10, 11, 12].",
                "A bottom-up update strategy proposed for R-trees [9] optimizes update operations of the index while maintaining a top down query processing mechanism.",
                "Instead of traversing a tree from the root node for frequent update requests (top-down approach), it directly accesses the leaf node of the object to be updated via an object hash table.",
                "Q-Index [13, 11] is one of the earlier work that re-discovers the usefulness of grid-based space partitioning for emerging moving object environments.",
                "In contrast to traditional spatial indexing methods that construct an index on the moving objects, it builds an index on the continuous range queries, assuming that the queries move infrequently while the objects move freely.",
                "The basic idea of the Q+Rtree [14] is to separate indexing structures for quasistationary objects and moving objects: fast-moving objects are indexed in a Quadtree and quasi-stationary objects are stored in an R∗ -tree.",
                "SINA [10] was proposed to provide efficient query evaluations for any combination of stationary/moving objects and stationary/moving queries.",
                "Specifically, this approach only detects newly discovered (positive) or no longer relevant (negative) object updates efficiently.",
                "Unlike other spatial indexing methods that focus on reducing the query evaluation cost, Hu et al. [12] proposed a general framework that minimizes the communication cost for location updates by maintaining a rectangular area called a safe region around moving objects.",
                "As long as any object resides in this region, all the query results are guaranteed to be valid in the system.",
                "If objects move out of their region, location update requests should be delivered to the database server and the affected queries are re-evaluated on the fly.",
                "Our indexing method is very similar to the above approaches.",
                "The major difference is that we are more concentrating on real-time visibility determination while others assume loose timing constraints. 3.",
                "OBJECT-INITIATED VIEW MODEL In this section we illustrate how the object popping problem can be associated with a typical view decision model.",
                "We then propose our own model, and finally we discuss its strengths and limitations.",
                "To begin with, we define the terminologies commonly used throughout this paper.",
                "Entities in a virtual space can be categorized into three types 403 based on their role - autonomous entities, spectator entities, and avatars.",
                "The term autonomous entity refers to an ordinary moving or stationary geometric object that can be visible to other entities.",
                "The spectator entity corresponds to a players viewpoint, but is invisible to other entities.",
                "It has no shape and is represented only by a point location.",
                "It is designed to allow a game participant to see from a third-person viewpoint.",
                "It functions similar to a camera control in the 3D graphics field.",
                "It also has a higher degree of mobility than other entities.",
                "The avatar represents a normal game user who can freely navigate in the space and interact with other entities.",
                "It possesses both features: its own viewpoint and visibility.",
                "For the remainder we use the term object entity to refer to an autonomous entity or an avatar while we use user entity to denote an avatar or a spectator entity.",
                "The visible range of an entity refers to the spatial extent within which any other entity can recognize its existence.",
                "It is based on the assumptions that there always exists an optimal visible distance between a user and an object at any given time and every user possesses equal visibility.",
                "Thus, the user and the object, only when their current distance is smaller than or equal to the optimal, can see each other.",
                "To specify the visible range, much literature in the graphics area [5, 6] uses a circular Area Of Interest (AOI) whose center is the location of an entity.",
                "Its omnidirectional nature allows rapid directional changes without any display disruptions at the periphery of the viewable area.",
                "However, we employ a squareshaped AOI at the expense of accuracy because the square-shaped spatial extension is very simple and efficient to be indexed in a grid partitioned world.",
                "The traditional view model, which we call user-initiated view model, assumes that a user entity has an AOI while an object entity does not.",
                "As the user navigates, she continuously searches for all the entities within her AOI.",
                "Due to its simple design and its low indexing overhead, many Location Based Services (LBSs) and game applications use this model.",
                "However, the user-initiated model has a serious object popping problem during navigation.",
                "Recall, as shown in Figure 1, that the house that will have appeared at time t + Δ does not appear at time t because the user cannot recognize objects that are outside of her AOI at time t. In fact, it turned out that the side length of her AOI was smaller than the optimal distance between the user and the house at the time t. Therefore, there is no other way but to increase the visible range of the user in this model to make such an experience unlikely.",
                "A large AOI, however, may lead to a significant system degradation.",
                "To overcome the object popping problem, we propose a new view model which we call object-initiated view model.",
                "All object entities have their own AOI centered at their current location while all spectator entities have no AOI.",
                "Every user entity recognizes the objects whose AOIs cover its point location.",
                "The main strengths of the new model are that (1) it has no object popping problem as long as the underlying system can manage the optimal visible range of all object entities correctly and that (2) the content creators can produce an enriched expressiveness of various behavioral and temporal changes.",
                "A huge object may have a farther visible range than a small one; an object has a broader visible range during day-time than at night; even during the night the visible range of an object that owns a light source will have a much wider visible area than a non-illuminated object; if an object is located inside a building, its visible range would be constrained by the surrounding structure.",
                "One of the potential arguments against the object-initiated view is that indexing of the spatial extension of an object is too complex to be practical, compared with the user-initiated view.",
                "We agree E2 E1 A S Client S Client A Sub-world Server Figure 2: Target system in a 4 × 4 grid partition. that existing spatial indexing methods are inefficient in supporting our view model.",
                "To refute this argument, we propose a novel spatial indexing solution detailed in Section 4.4.",
                "Our spatial indexing solution offers a very promising performance even with a large number of mobile entities and visibility calculations in real-time.",
                "For the rest of the paper our design scope is limited to a 2D space, although our application is targeted for 3D environments3 .",
                "Note that our view model is not intended to rival a sophisticated visibility decision algorithm such as visibility culling [6], but to efficiently filter out unnecessary entities that do not contribute to the final image.",
                "In Section 6.1 we evaluate both models through quantitatively measures such as the degree of expressiveness and the quality of the two view models and we discuss simulation results. 4.",
                "DESIGN OF EDGE INDEXING In Section 4.1 we introduce our target application model.",
                "Next, Section 4.2 presents an abstraction of our node and edge structures whose detailed indexing and cell evaluation methods are explained later in Sections 4.3 and 4.4.",
                "Several optimization issues for edge indexing follow in Section 4.5. 4.1 Target Application Our target application assumes both 3D object streaming and sub-world hosting.",
                "The sub-world hosting is a collaborative virtual environment where every server hosts one sub-world, thus constructing a single world.",
                "Second Life is the classic example of such an approach.",
                "A virtual space is partitioned into equal-sized sub-worlds.",
                "The sample sub-world separated with bold-dashed lines in Figure 2 contains four virtual entities: two autonomous entities (E1, E2); one spectator entity S; and one avatar A.",
                "As mentioned in Section 3, all object entities (E1, E2, A) have their own square-shaped AOI.",
                "Two user entities (S, A) are associated with individual client machines, (client S and client A in the figure).",
                "The spatial condition that the point location of S resides inside the AOI of E2 can be symbolized as S.P ∈ E2.R.",
                "Every sub-world is managed by its dedicated server machine.",
                "Each server indexes all the entities, delivers any new events (i.e., a new user enters into the sub-world or an object moves from one place to another) to clients, and resolves any inconsistencies among the entities.",
                "For efficient management of moving entities, a server further divides its sub-world into smaller partitions, called grid cells.",
                "Figure 2 shows the 4 × 4 grid enclosed by the dashed lines.",
                "Instead of indexing the object entities with a user entity structure, our system indexes their visible regions on the grid cells.",
                "Retrieval of the indexed objects for a given user includes the search and de3 A better indexing method for a 3D space is work in progress. 404 Tokens: IT(E1) IT(E2) IT(A) IT(S) Tokens: AT(E1) DT(E1) AT(E2) DT(E2) AT(A) DT(A) IT(S) (a) node indexing (b) edge indexing (c) edge indexing with row-wise cell evaluation Figure 3: Illustration of different data structures for node indexing and edge indexing for the sample space in Figure 2.",
                "There are three object entities, {E1, E2, A}, and two user entities, {S, A} in the world. livery of the indices stored on the cell it is located in.",
                "This retrieval process is interchangeably called a user (or query) evaluation.",
                "Our application only considers the efficient indexing of virtual entities and the search for the most relevant entities - that is, how many entities per sub-world are indexed and how quickly index updates are recognized and retrieved.",
                "Efficient delivery of retrieved real geometry data is out of the scope of this paper. 4.2 Abstraction We define a token as an abstraction of a virtual entity that satisfies a specific spatial relationship with a given cell.",
                "In our application, we use three types of tokens: Inclusion Token (IT) indicates that its entity overlaps with or is covered by the given cell.",
                "Appearance Token (AT) denotes that its entity is an IT for the given cell, but not for the previously adjacent cell.",
                "Disappearance Token (DT) is the opposite of AT, meaning that while its entity does not satisfy the IT relationship with the given cell, it does so with the previously adjacent cell.",
                "We also define two data structures for storing and retrieving the tokens: a node and an edge.",
                "A node is a data structure that stores ITs of a cell.",
                "Thus, the node for cell i is defined as a set of IT entities and formally expressed as Ni = {o|o.R∩i.R = ∅}, where R is either an AOI or a cell region.",
                "An edge is another data structure for two adjacent cells that stores their ATs or DTs.",
                "If the edge only stores the AT entities, it is termed an Appearance Edge (AE); otherwise, if it stores DTs, it is termed a Disappearance Edge (DE).",
                "The AE for two adjacent cells i and j is defined as a set of ATs and expressed as E+(i, j) = Nj − (Ni ∩ Nj ) (1) where Ni and Nj are the node structures for the cells i and j.",
                "The DE for two adjacent cells i, j is defined as a set of DTs, satisfying: E−(i, j) = Ni − (Ni ∩ Nj ) (2) In a 2D map, depending on the adjacency relationship between two neighboring cells, edges are further classified as either rowwise, if two neighbors are adjacent horizontally (Er ), or columnwise, if they are adjacent vertically (Ec ).",
                "Consequently, edges are of four different types, according to their token type and adjacency: Er +(i, j), Er −(i, j), Ec +(i, j), and Ec −(i, j). 4.3 Node Indexing Grid partitioning is a popular space subdivision method that has recently gained popularity for indexing moving entities in highly dynamic virtual environments [12, 8, 13, 10].",
                "To highlight the difference to our newly proposed method, we term all existing grid partitioning-based indexing methods node indexing.",
                "Node indexing partitions the space into equi-sized subspaces (grid cells), indexes entities on each cell, and searches for entities that satisfy a spatial condition with a given query.",
                "In many LBS applications, node indexing maintains a node structure per cell and stores an index of entities whose spatial extent is a point location.",
                "For a given range query, a search is performed from the node structures of the cells whose region intersects with the spatial extent of the range query.",
                "Due to the use of a simple point geometry for entities, this allows for lightweight index updates.",
                "Much of the existing work falls into this category.",
                "However, if the spatial extent of an entity is a complex geometry such as rectangle, node indexing will suffer from significant system degradation due to expensive update overhead.",
                "For example, a single movement of an entity whose spatial extent overlaps with 100 grid cells requires 100 token deletions and 100 token insertions, in the worst case.",
                "One of the popular node indexing methods, Query Indexing, has been reported to have such performance degradation during the update of rectangle-shaped range queries [13].",
                "For the sample space shown in Figure 2, the concept of node indexing is illustrated in Figure 3(a).",
                "Every cell stores IT entities that intersect with its region.",
                "Query processing for the spectator S means to search the node structure whose cell region intersects with S. In Figure 3(a), E2 is indexed on the same cell, thus being delivered to the client S after the query evaluation. 4.4 Edge Indexing Our new indexing method, edge indexing, is designed to provide an efficient indexing method for the specific spatial extension (square) of the entities in a grid.",
                "Its features are (1) an edge structure and (2) periodic entity update and cell evaluation. 4.4.1 Idea Edge Structure The main characteristic of our approach is that it maintains edge structures instead of using node structures.",
                "With this approach, redundant ITs between two adjacent cells (Ni ∩Nj ) are eliminated.",
                "In a 2D M × M grid map, each cell i is surrounded by four neighboring cells (i− 1), (i+ 1), (i− M), (i+ M) (except for the 405 outermost cells) and eight different edge structures.",
                "If the first two neighbor cells are horizontally adjacent to i and the last two cells (i−M), (i+M) are vertically nearby, the eight edge structures are Ec +(i−M, i), Ec −(i−M, i), Er +(i−1, i), Er −(i−1, i), Er +(i, i+ 1), Er −(i, i + 1), Ec +(i, i + M), and Ec −(i, i + M).",
                "Figure 3(b) illustrates how edge structures are constructed from node structures, using Equations 1 and 2.",
                "Inversely, the cell evaluation process with edge indexing derives node structures from the edge structures.",
                "If any node structure and all the edge structures are known a priori, we can derive all the node structures as defined by Lemma 1.",
                "The proof of Lemma 1 is trivial as it is easily induced from Equations 1 and 2.",
                "Lemma 1.",
                "Nj , a set of ITs of a given cell j can be derived from a set of ITs of its neighbor cell i, Ni and its edges E+(i, j) − E−(i, j): Nj = Ni + E+(i, j) − E−(i, j) Row-wise and column-wise edge structures, however, capture some redundant information.",
                "Thus, na¨ıve edge indexing stores more tokens than node indexing - the total number of edge tokens shown in Figure 3(b) is 35 (17 ATs + 17 DTs + 1 IT); for node indexing in Figure 3(a) the number is 25.",
                "To reduce such redundancy, a subsequent two-step algorithm can be applied to the original edge indexing.",
                "Periodic Entity Update and Cell Evaluation Many objects are continuously moving and hence index structures must be regularly updated.",
                "Generally, this is done through a twostep algorithm [13] that works as follows.",
                "The algorithm begins by updating all the corresponding indices of newly moved entities (the entity update step) and then computes the node structures of every cell (the cell evaluation step).",
                "After one cell evaluation, the indexed user entities are retrieved and the computed node structure is delivered for every client that is associated with a user.",
                "After all the cells are evaluated, the algorithm starts over.",
                "The two-step algorithm can also be used for our edge indexing by updating the edge structures of the entities that moved during the previous time period and by applying Lemma 1 during the cell evaluations.",
                "In addition to this adaptability, the Lemma also reveals another important property of cell evaluations: either row edges or column edges are enough to obtain all the node structures.",
                "Let us assume that the system maintains the row-wise edges.",
                "The leftmost node structures are assumed to be obtained in advance.",
                "Once we know the node structure of the leftmost cell per row, we can compute that of its right-hand cell from the leftmost node structure and the row-wise edges.",
                "We repeat this computation until we reach the rightmost cell.",
                "Hence, without any column-wise edges we can obtain all the node structures successfully.",
                "As a result, we reduce the complexity of the index construction and update by a factor of two.",
                "Figure 3(c) illustrates the concept of our row-wise edge indexing method.",
                "The total number of tokens is reduced to 17 (8 ATs + 8 DTs + 1 IT).",
                "The detailed analysis of its indexing complexity is presented in Section 5. 4.4.2 Another Example Figure 4 illustrates how to construct edge structures from two nearby cells.",
                "In the figure, two row-wise adjacent cells 3 and 4 have two row-wise edge transitions between them, E+(3, 4), E−(3, 4); two point entities P1, P2; and two polygonal entities R1, R2.",
                "As shown in the figure, N3 indexes {P2, R1, R2} and N4 maintains the indices of {P1, R2}.",
                "E+(3, 4) is obtained from Equation 1: N4 − (N3 ∩ N4) = {P1}.",
                "Similarly, E−(3, 4) = N3 − Cell 3 Cell 4 E+(3, 4)={P1} E_(3, 4)={P2,R1} P2 P1 R2 R1 Figure 4: Example of edge indexing of two point entities {P1, P2} and two polygonal entities {R1, R2} between two row-wise adjacent cells. (N3 ∩ N4) = {P2, R1}.",
                "If we know N3, E+(3, 4), and E−(3, 4), we can compute N4 according to Lemma 1, N4 = N3+E+(3, 4)− E−(3, 4) = {P1, R2}.",
                "The above calculation also corresponds to our intuition.",
                "P2, R1, R2 overlap with cell 3 while P1, R2 overlap with cell 4.",
                "When transiting from cell 3 to 4, the algorithm will recognize that P2, R1 disappear and P1 is newly appearing while the spatial condition of R2 is unchanged.",
                "Thus, we can insert P2, R1 in the disappearance edge set and insert P1 in the appearance edge set.",
                "Obviously, edge indexing is inefficient for indexing a point geometry.",
                "Node indexing has one IT per point entity and requires one token removal and one insertion upon any location movement.",
                "Edge indexing, however, requires one AT and one DT per point entity and two token removals and two insertions during the update, in the worst case.",
                "In such a situation, we take advantage of using both according to the spatial property of entity extension.",
                "In summary, as shown in Figure 3(c), our edge indexing method uses edge structures for the AOI enabled entities (A, E1, E2) while it uses node structures for the point entity (S). 4.5 Optimization Issues In this section, we describe several optimization techniques for edge indexing, which reduces the algorithm complexity significantly. 4.5.1 Single-table Approach: Update Typically, there exist two practical policies for a region update: Full Update simply removes every token of the previous entity region and re-inserts newly updated tokens into newly positioned areas.",
                "Incremental Update only removes the tokens whose spatial relationship with the cells changed upon an update and inserts them into new edge structures that satisfy the new spatial conditions. 4.5.2 Two-table Approach: Separating Moving Entities from Stationary Entities So far, we have not addressed any side-effect of token removals during the update operation.",
                "Let us assume that an edge index is realized with a hash table.",
                "Inserting a token is implemented by inserting it at the head of the corresponding hash bucket, hence the processing time becomes constant.",
                "However, the token removal time depends on the expected number of tokens per hash bucket.",
                "Therefore, the hash implementation may suffer from a significant system penalty when used with a huge number of populated entities.",
                "Two-table edge indexing is designed to make the token removal overhead constant.",
                "First, we split a single edge structure that indexes both stationary and moving entities into two separate edge 406 Table 1: Summary of notations for virtual entities and their properties.",
                "Symbol Meaning U set of populated object entities O set of moving object entities, O ⊆ U Uq set of populated user entities Q set of moving user entities, Q ⊆ Uq A set of avatars, A = {a|a ∈ U ∩ Uq} i.P location of entity i where i ∈ (U ∪ Uq) i.R AOI of entity i where i ∈ (U ∪ Uq) mi side length of entity i where i ∈ (U ∪ Uq).",
                "It is represented by the number of cell units. m average side length of the AOI of entities V ar(mi) variance of random variable mi v maximum reachable distance.",
                "It is represented by the number of cell units. structures.",
                "If an entity is not moving, its tokens will be placed in a stationary edge structure.",
                "Otherwise, it will be placed with a moving edge.",
                "Second, all moving edge structures are periodically reconstructed.",
                "After the reconstruction, all grid cells are evaluated to compute their visible sets.",
                "Once all the cells are evaluated, the moving edges are destroyed and the reconstruction step follows.",
                "As a result, search operations on the moving edge structures are no longer necessary and the system becomes insensitive to any underlying distribution pattern and moving speed of the entities.",
                "A singly linked list implementation is used for the moving edge structure. 5.",
                "ANALYSIS We analyze three indexing schemes quantitatively (node indexing, edge indexing, and two-table edge indexing) in terms of memory utilization and processing time.",
                "In this analysis, we assume that node and edge structures are implemented with hash tables.",
                "For hash table manipulations we assume three memory-access functions: token insertion, token removal, and token scan.",
                "Their processing costs are denoted by Ta, Td, and Ts, respectively.",
                "A token scan operation reads the tokens in a hash bucket sequentially.",
                "It is extensively used during cell evaluations.",
                "Ts and Td are a function of the number of tokens in the bucket while Ta is constant.",
                "For the purpose of analysis, we define two random variables.",
                "One variable, denoted by mo, represents the side length of the AOI of an entity o.",
                "The side lengths are uniformly distributed in the range of [mmin, mmax].",
                "The average value of mo is denoted by m. The second random variable v denotes the x-directional or ydirectional maximum distance of a moving entity during a time interval.",
                "The simulated movement of an entity during the given time is also uniformly distributed in the range of [0, v].",
                "For a simple calculation, both random variables are expressed as the number of cell units.",
                "Table 1 summarizes the symbolic notations and their meaning. 5.1 Memory Requirements Let the token size be denoted by s. Node indexing uses s · |Uq| memory units for user entities and s · Èo∈U (mo + 1)2 ≈ s(m2 + 2m + 1 + V ar(mo))|U| units for object entities.",
                "Single-table edge indexing consumes s · |Uq| storage units for the user entities and s · Èo∈U 2(mo + 1) ≈ 2s(m + 1)|U| for the object entities.",
                "Two-table edge indexing occupies s · |Uq| units for the users and s{ Èi∈O 2(mi+1)+ Èj∈(U−O) 2(mj +1)} ≈ 2s(m+1)|U| units for the objects.",
                "Table 2 summarizes these results.",
                "In our target apTable 2: Memory requirements of different indexing methods. indexing method user entities object entities node indexing s · |Uq| s((m + 1)2 + V ar(mo))|U| single-table edge s · |Uq| 2s(m + 1)|U| two-table edge s · |Uq| 2s(m + 1)|U| plication, our edge indexing methods consume approximately m+1 2 times less memory space than node indexing.",
                "Different grid cell partitioning with edge methods will lead to different memory requirements.",
                "For example, here are two grids: a M × M grid and a 2M × 2M grid.",
                "The memory requirement for the user entities is unchanged because it depends only on the total number of user entities.",
                "The memory requirements for the object entities are approximately 2s(m + 1)|U| in the M × M grid case and 2s(2m + 1)|U| for the (2M) × (2M) grid.",
                "Thus, a four times larger cell size will lead to an approximately two times smaller number of tokens. 5.2 Processing Cost In this section, we focus on the cost analysis of update operations and cell evaluations.",
                "For a fair comparison of the different methods, we only analyze the run-time complexity of moving objects and moving users. 5.2.1 Update Cost We assume that a set of moving objects O and a set of moving users Q are known in advance.",
                "Similar to edge indexing, node indexing has two update policies: full update and incremental update.",
                "Full update, implemented in Q-Index [13] and SINA [10], removes all the old tokens from the old cell node structures and inserts all the new tokens into the new cell nodes.",
                "The incremental update policy, implemented by no existing work, removes and inserts all the tokens whose spatial condition changed during a period.",
                "In this analysis, we only consider incremental node indexing.",
                "To analyze the update cost of node indexing, we introduce the maximum reachable distance (v), where the next location of a moving entity, whose previous location was at cell(0,0), is uniformly distributed over the (±v, ±v) grid cell space as illustrated in Figure 5.",
                "We also assume that the given maximum reachable distance is less than any side length of the AOI of the objects in the system; that is, v < mo where o ∈ O.",
                "As seen in Figure 5, the next location may fall into three categories: areas A, B, and the center cell area (0,0).",
                "If an object resides in the same cell, there will be no update.",
                "If the object moves into the area A, there will be (i + j)(mo + 1) − ij token insertions and removals, where 1 ≤ i, j ≤ v. Otherwise, there will be k(mo + 1) token insertions and removals, where 1 ≤ k ≤ v. Thus, the expected processing time of an object update for node indexing is the summation of three different movement types T node per update(o) = 4 · (A) + 4 · (B) (2v + 1)2 · (Ta + Td) = v(v + 1){v(4mo + 3 − v) + 2(mo + 1)} (2v + 1)2 · (Ta + Td) (3) and the expected processing time of any object for node indexing is obtained by T node per update = Èo∈O,v<mo T node per update(o) |O| = v(v + 1){v(4m + 3 − v) + 2m + 1)} (2v + 1)2 · (Ta + Td) (4) . 407 Table 3: Update time cost for any single update event where v < mq, mo and q ∈ Q. indexing method queries ×(Ta + Td) (seconds) objects ×(Ta + Td) (seconds) node indexing with incremental update |Q| |O| · v(v+1){v(4m+3−v)+2(m+1)} (2v+1)2 single-table edge indexing with full update |Q| |O| · 2(m + 1) single-table edge indexing with incremental update |Q| |O| · v(4m(1+2v)+9v+5) (2v+1)2 two-table edge indexing |Q| · Ta Ta+Td |O| · 2(m + 1) Ta Ta+Td Maximum Reachable Distance (v) (0,0) i j (i,j) A A AA B B B B Figure 5: Illustration of next cell location, cell(i, j), of a moving entity whose initial location was at cell (0, 0).",
                "The expected time of any single entity update for edge indexing with full update is: T edgefull per update = Èo∈O T edgefull per update (o) |O| = 2(m + 1)(Ta + Td) (5) The analysis of the expected time of any single entity update for edge indexing with incremental update becomes complicated because the time cost depends both on the side length of the entity AOI and on the moving speed.",
                "Roughly speaking, its worst-case processing cost is the same as Tedgefull per update .",
                "Due to space limitations we only show the analysis result of the expected processing time when v of any object o ∈ O is smaller than mo: Tedgeincremental per update = Èo∈O,v<mo Tedgeincremental per update (o) |O| = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · (Ta + Td) = v(4m(1 + 2v) + 9v + 5) (2v + 1)2 · 2(m + 1) · Tedgefull per update (6) All update complexities are summarized in Table 3.",
                "In this table, it is evident that while the update cost of the worst-case edge indexing (single-table edge indexing with full update policy) depends only on m, that of the best-case node indexing (node indexing with incremental update policy) is still proportional to two variables, v and m. For a smaller value of v (v = 1), the update cost of node indexing slightly outperforms that of edge indexing (i.e., 12m+8 9 vs. 2(m + 1)).",
                "However, as v increases, the performance gain is then immediately reversed (i.e., 60m+24 25 versus 2(m + 1), where v = 2).",
                "Another interesting result is that two-table edge indexing depends only on the token insertion cost, Ta.",
                "Typically, Td is slightly 1 2 3 4 5 0 5 10 15 20 25 30 35 40 Maximum Reachable Distance (v) (%) #ofAffectedTokens Two−table Edge Indexing Incremental Edge Indexing Full Edge Indexing Incremental Node Indexing Figure 6: Simulation results of update complexity of different indexing methods.",
                "The update complexity, the expected number of token removals and insertions per object update, is drawn as a function of maximum reachable distance (v).",
                "The average side length of object AOIs is 10% of the side length of a given 2-D map. greater than Ta because Td requires at least one token lookup operation.",
                "After the lookup, Td executes the reverse operation of Ta.",
                "Thus, Td may well be expressed as (Ta + Tlookup) and can be simplified as (Ta + |E| 2·b ·Ts) where |E| is the size of the edge structure and b is the number of its hash buckets.",
                "From this observation, we can infer that full update of single-table edge indexing takes at least twice as long as the update for two-table edge indexing.",
                "Figure 6 shows that full update of edge indexing when the maximum reachable distance is less than the side length of any moving entities takes constant time to update the corresponding edge structures, which mainly depends on the side length of the given AOI.",
                "In this figure we assume that the average side length of the AOI is 0.1 (or 10 %).",
                "The node indexing method, however, depends not only on the side length but also on the reachable distance.",
                "Thus the entity update in node indexing is much heavier than the full update for edge indexing.",
                "As expected, these simulation results validate a common belief that in less dynamic environments, incremental updates reduce the amount of token insertions and removals noticeably while in extremely dynamic environments the reduction ratio becomes negligible. 5.2.2 Cell Evaluation Cost Node indexing scans all entities and then collects the user entities indexed on every cell node.",
                "Therefore, it would take |Q|×Ts to scan all user entities.",
                "If every node stores (m2 +2m+1+V ar(mo))|O| M2 object entities on average, the expected completion time of one cell evaluation will then be Èo∈O (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "If every cell has at most one user entity, the expected completion time of all cell evaluations will be |Q| · (m2 +2m+1+V ar(mo))|O| M2 · Ts.",
                "The runtime complexity of the single-table cell evaluation can 408 Table 4: Summary of cell evaluation cost. indexing method expected elapsed time node indexing Ts · |Q| · (m2 +2m+1+V ar(mo))|O| M2 single-table edge Ts · (|Q| + |O| · 2(m + 1)) two-table edge (Ts + Td) · (|Q| + |O| · 2(m + 1)) be simplified as Ts ·|O|·2(m +1).",
                "In this analysis, we do not consider any data delivery overhead after a cell evaluation.",
                "Note that in single-table edge indexing we need to scan all the tokens for cell evaluations.",
                "Two-table edge indexing executes in Td to remove the evaluated tokens after a cell evaluation.",
                "Unlike the Td operation, the Td operation is much lighter because it does not require any lookup operation.",
                "Table 4 shows the expected complexities of different cell evaluation scenarios.",
                "If previously computed result sets are re-used during the next evaluation round, the expected elapsed time of node indexing will be bound by the total number of cell evaluations (i.e., Ts(m2 + 2m + 1 + V ar(mo))|O|).",
                "However, in the worst case, the cell evaluation of node indexing is still m+1 2 times longer than that of any edge indexing method. 5.2.3 Putting it Together: Periodic Monitoring Cost As we saw in Section 5.2.1, edge indexing methods outperform node indexing in terms of updates and cell evaluations.",
                "In this section we focus on evaluating the performance difference between single-table edge indexing and two-table edge indexing.",
                "The total elapsed time of full update based single-table edge indexing for a given set of moving entities is the summation of the elapsed time of updates and cell evaluations: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (7) Similarly, the total elapsed time of two-table edge indexing is as follows: (Ta + Td + Ts) · {|Q| + |O|2(m + 1)} (8) From Equation 7 and 8 we conclude that two-table edge indexing, even though it represents a minor optimization of single-table edge indexing by replacing unpredictable Td with predictable Td, achieves a significant performance improvement.",
                "First of all, Td is very predictable and a more lightweight procedure than Td.",
                "All the data structure manipulation overheads, such as Ta, Ts, and Td can be easily profiled and all become constant.",
                "In addition, twotable indexing is guaranteed to outperform single-table full update edge indexing.",
                "Another novelty of the two-table approach is that it is highly resilient to the underlying data distribution, regardless of whether it is highly skewed or uniform.",
                "Equation 8 also reveals the minimum time interval that satisfies the given input parameters, Ta, Ts, Td, |Q|, |O|, and m. While Ta, Ts and Td are system-specific parameters, |O|, |Q|, and m are all application-specific.",
                "The latter can be configured by the former and any given real-time constraint T. Thus, the system throughput - how many moving objects and users are supported by the given system - is obtained from Equation 9.",
                "Maximum System Throughput = |Q| + |O|2(m + 1) = T Ts + Ta + Td (9) For example, if a given sub-world is only filled with moving avatars, A = Q = O, whose average side length is 10% of the map side length, then Ts + Td takes 0.42 microseconds per token evaluation, and Ta takes 0.78 microseconds, and the system will handle about 36,231 avatars per second.",
                "Every avatar can navigate in the sub-world freely and the same number of remotely connected clients receive the latest update events continuously. 6.",
                "EVALUATION This section presents two simulation setups and their performance results.",
                "Section 6.1 examines whether our new view approach is superior to existing view models, in spite of its higher indexing complexity.",
                "Section 6.2 discusses the degree of practicality and scalability of our indexing method that is designed for our new view model. 6.1 JustificationofObject-initiatedView Model 6.1.1 Evaluation Metrics To quantify the quality of the retrieved results of query processing, we use two widely known evaluation metrics, Precision (P) and Recall (R), that estimate the degree of accuracy and comprehensiveness of a given result set [15].",
                "P is the ratio of relevant, retrieved items to all retrieved items.",
                "A lower value of P implies that the query result set contains a large number of unnecessary objects that do not have to be delivered to a client.",
                "A higher P value means a higher network traffic load than required.",
                "R is the ratio of relevant, retrieved items to all relevant items.",
                "A lower R value means that more objects that should be recognized are ignored.",
                "From the R measure, we can quantitatively estimate the occurrence of object popping.",
                "In addition to the P and R metrics, we use a standardized singlevalued query evaluation metric that combines P and R, called Emeasure [15].",
                "The E-measure is defined as: E = 1 − (β2 + 1)PR β2P + R where β is the relative importance of P or R. If β is equal to 1, P and R are equally important.",
                "If β is less than 1, P becomes more important.",
                "Otherwise, R will affect the E-measure significantly.",
                "A lower E-measure value implies that the tested view model has a higher quality.",
                "The best E-measure value is zero, where the best values for P and R are both ones. 6.1.2 Simulation Setup We tested four query processing schemes, which use either a user-initiated or an object-initiated view model: • User-initiated visibility computation - RQ-OP: Region Query - Object Point • Object-oriented visibility computation - PQ-OR: Point Query - Object Region - RQ-OR: Region Query - Object Region - ACQ-OR: Approximate Cell Query - Object Region RQ-OP is the typical computation scheme that collects all objects whose location is inside a user defined AOI.",
                "PQ-OR collects a set of objects whose AOI intersects with a given user point, formally {o|q.P ∈ o.R}.",
                "RQ-OR, an imaginary computation scheme, is the combination of RQ-OP and PQ-OR where the AOI of an object intersects with that of a user, {o|o.R ∩ q.R = ∅}.",
                "Lastly, ACQ-OR, an approximate visibility computation model, is a special scheme designed for grid-based space partitioning, which is our choice of cell evaluation methodology for edge indexing.",
                "If a virtual space is partitioned into tiled cells and a user point belongs to one of the cells, the ACQ-OR searches the objects whose AOI 409 Table 5: P and R computations of different visibility determination schemes.",
                "Scheme P R RQ-OP |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|o.P ∈q.R}| |{o|o.P ∈q.R∧q.P ∈o.R)}| |{o|q.P ∈o.R}| PQ-OR |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 RQ-OR |{o|q.P ∈o.R}| |{o|q.R∩o.R=∅}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 ACQ-OR |{o|q.P ∈o.R}| |{o|c.R∩o.R=∅,q.P ∈c.R}| |{o|q.P ∈o.R}| |{o|q.P ∈o.R}| = 1 would intersect with the region of the corresponding grid cell.",
                "Of course, it exhibits similar properties as RQ-OR while the result set of its query is not a subset of the RQ-OR query result.",
                "It identifies any object o satisfying the condition c.R ∩ o.R = ∅ where the cell c satisfies q.P ∈ c.R as well.",
                "Our simulation program populated 100K object entities and 10K user entities in a 2D unit space, [0, 1) × [0, 1).",
                "The populated entities are uniformly located in the unit space.",
                "The side length of their AOI is also uniformly assigned in the range of [0.05, 0.14], meaning 5% to 14% of the side length of the unit space.",
                "The program performs intersection tests between all user and all object entities exhaustively and computes the P, R, and E-measure values (shown in Table 5). 6.1.3 Experimental Results Distribution of P and R measure: Figure 7 shows the distribution of P and R for RQ-OP.",
                "We can observe that P and R are roughly inversely proportional to each other when varying a user AOI range.",
                "A smaller side length leads to higher accuracy but lower comprehensiveness.",
                "For example, 5% of the side length of a user AOI detects all objects whose side length of the AOI is at least 5%.",
                "Thus, every object retrieved by RQ-OP is guaranteed to be all rendered at the client.",
                "But RQ-OP cannot detect the objects outside the AOI of the user, thus suffering from too many missing objects that should be rendered.",
                "Similarly, the user whose AOI is wider than any other AOI cannot miss any objects that should be rendered, but detects too many unnecessary objects.",
                "To remove any object popping problem, the side length of any AOI should be greater than or equal to the maximum visible distance of any object in the system, which may incur significant system degradation.",
                "E-measure Distribution: Figure 8 reveals two trends.",
                "First, the precision values of RQ-OP lie in between those of ACQ-OR (100 × 100 grid) and RQ-OR.",
                "Second, the tendency curve of the Precision-to-E-measure plot of RQ-OR shows resemblance to that of ACQ-OR.",
                "It looks as if the two curves lie on the same imaginary curve, which conveys that ACQ-OR inherits the properties of RQ-OR.",
                "Effect of Different Grid Size: Figure 9 shows the statistical difference of E-measure values of seven different grid partitioning schemes (using ACQ-OR) and one RQ-OP model.",
                "We use a boxand-whisker plot to show both median values and the variances of E-measure distributions and the outliers of each scheme.",
                "We also draw the median value of the RQ-OP E-measures (green line) for comparison purposes.",
                "While the ACQ-OR schemes have some outliers, their E-measure values are heavily concentrated around the median values, thus, they are less sensitive to object AOI.",
                "As expected, fine-grained grid partitioning showed a smaller E-measure value.",
                "The RQ-OP scheme showed a wider variance of its quality than other schemes, which is largely attributable to different user side lengths.",
                "As the R measure becomes more important, the query quality of ACQ-OR is improved more evidently than that of RQOP.",
                "From Figure 9, the 20×20 grid scheme had a better E-measure Table 6: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a slowly moving environment (v = 1). indexing Update Time Evaluation Time Total Single-tableF ull 3.48 0.82 4.30 Single-tableIncr 2.08 0.80 2.88 Two-table 1.74 0.93 2.67 Table 7: Measured elapsed time (seconds) of 100K moving objects and 10K moving users in a highly dynamic environment (v = 15). indexing Update Time Evaluation Time Total Single-tableF ull 3.65 0.77 4.42 Single-tableIncr 3.49 0.74 4.23 Two-table 1.75 0.93 2.68 value in a prioritized environment than in an equal-prioritized environment.",
                "As a result, we can roughly anticipate that at least the 20×20 grid cell partitioning retrieves a higher quality of visible sets than the RQ-OP. 6.2 Evaluation of Edge Indexing In this section, we present the preliminary results of the simulations that examine the applicability of our edge indexing implementation.",
                "To estimate the degree of real-time support of our indexing method, we used the total elapsed time of updating all moving entities and computing visible sets for every cell.",
                "We also experimented with different grid partitioning policies and compared them with exhaustive search solutions. 6.2.1 Simulation Setup We implemented edge indexing algorithms in C and ran the experiments on a 64-bit 900MHz Itanium processor with 8 GBs of memory.",
                "We implemented a generalized hash table mechanism to store node and edge structures. 6.2.2 Experimental Results Periodic Monitoring Cost: Tables 6 and 7 show the performance numbers of different edge indexing methods by varying v. The moving speed of entities was also uniformly assigned between 0 and v. In a slowly moving environment (Table 6), the incremental edge indexing method outperforms full update edge indexing, due to reduced index updates; the two-table approach surpasses the performance of single-table schemes, mainly due to the lack of token lookup during an update.",
                "However, the two-table method showed a slightly higher evaluation time than the two single-table methods because of its sequential token removal.",
                "Table 7 exemplified the elapsed time of index updates and cell evaluations in a highly dynamic environment where slowly moving and dynamically moving objects co-exist.",
                "Compared with the results shown in Table 6, the two-table approach produced similar performance numbers regardless of the underlying moving environments.",
                "However, the performance gain obtained by the incremental policy of the single-table is decreased compared with that in the slowly moving environment.",
                "Effect of Different Grid Size: How many object updates and cell evaluations can be supported in a given time period is an important performance metric to quantify system throughput.",
                "In this section, we evaluate the performance results of three different visibility computation models: two computation-driven exhaustive search methods; and one two-table edge indexing method with different grid sizes. 410 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Recall (R) Precision(P) 5% Range Query 6% Range Query 7% Range Query 8% Range Query 9% Range Query 10% Range Query 11% Range Query 12% Range Query 13% Range Query 14% Range Query Optimality 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 Precision (P) E−measure Optimality RQ−OP RQ−OR ACQ−OR (100x100 grid cells) 10x10 20x20 50x50 100x100 200x200 500x500 1Kx1K RQ−OP 0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1 E−Measure Visibility Test Scheme Median of RQ−OP Figure 7: Distribution of P and R measured by RQ-OP.",
                "Figure 8: E-measure value as a function of Precision value P when β = 1.",
                "Figure 9: E-measure value as a function of ACQ-QR grid partitioning scheme when β = 2. 10K 50K 100K 10 −1 10 0 10 1 10 2 # of Object Updates (10K queries) TotalElapsedTime(seconds) Population Size = 100K, visible range = 5−15%, mobility = 1% Exhaustive Search (Intersection Test) Exhaustive Search (Euclidean Distance Measure) 200x200 Two−table Edge Indexing 100x100 Two−table Edge Indexing 50x50 Two−table Edge Indexing Figure 10: Total elapsed time of different indexing schemes.",
                "Exhaustive search methods do not maintain any intermediate results.",
                "They simply compute whether a given user point is inside a given object AOI.",
                "They can tolerate unpredictable behavior of object movement.",
                "In spite of their simple design and extensibility, they suffer from lengthy computational delays to complete the visibility determination.",
                "Figure 10 reveals the performance difference between the exhaustive solutions and the two-table methods, a difference of up to two orders of magnitude.",
                "As shown in Section 5, the total elapsed time of object updates and cell evaluations is linear with respect to the average side length of object AOI.",
                "Because the side length is represented by cell units, an increase in the number of cells increases the side lengths proportionally.",
                "Figure 10 illustrates that the measured simulation results roughly match the expected performance gain computed from the analysis. 7.",
                "CONCLUSION AND FUTURE WORK To support dynamic extensibility and scalability in highly dynamic environments, we proposed a new view paradigm, the object-initiated view model, and its efficient indexing method, edge indexing.",
                "Compared with the traditional view model, our new view model promises to eliminate any object popping problem that can easily be observed in existing virtual environments at the expense of increased indexing complexity.",
                "Our edge indexing model, however, can overcome such higher indexing complexity by indexing spatial extensions at edge-level not at node-level in a grid partitioned sub-world and was validated through quantitative analyses and simulations.",
                "However, for now our edge indexing still retains a higher complexity, even in a two-dimensional domain.",
                "Currently, we are developing another edge indexing method to make the indexing complexity constant.",
                "Once indexing complexity becomes constant, we plan to index 3D spatial extensions and multi-resolutional geometry data.",
                "We expect that our edge indexing can contribute to successful deployment of next-generation gaming environments. 8.",
                "REFERENCES [1] D. Marshall, D. Delaney, S. McLoone, and T. Ward, Challeges in modern distributed interactive application design, Tech.",
                "Rep., Department of Computer Science, National University of Ireland, Maynooth, Maynooth, Col. Kildare, Ireland, 2004. [2] Kuan-Ta Chen, Polly Huang, Chun-Ying Huang, and Chin-Laung Lei, Game traffic analysis: An MMORPG perspective, in NOSSDAV05. 2005, pp. 19-24, ACM Press. [3] Jaecheol Kim, Jaeyoung Choi, Dukhyun Chang, Taekyoung Kwon, and Yanghee Choi, Traffic charateristics of a massively multiplayer online role playing game and its implications, in NetGames 05, Oct 2005. [4] Philip Rosedale and Cory Ondrejka, Enabling player-created online worlds with grid computing and streaming, Gamastutra Magazine, http://www.gamasutra.com/resource guide/20030916/rosedale 01.shtml, September 2003. [5] Eyal Teler and Dani Lischinski, Streaming of complex 3d scenes for remote walkthroughs., Comput.",
                "Graph.",
                "Forum, vol. 20, no. 3, 2001. [6] Gerd Hesina and Dieter Schmalstieg, A network architecture for remote rendering, in Second International Workshop on Distributed Interactive Simulation and Real-Time Applications, 1998. [7] Thomas A. Funkhouser and Carlo H. Sequin, Adaptive display algorithm for interactive frame rates during visualization of complex virtual environments, in SIGGRAPH 93, New York, NY, USA, 1993, pp. 247-254, ACM Press. [8] Jussi Myllymaki and James Kaufman, High-performance spatial indexing for location-based services, in WWW 03, New York, NY, USA, 2003, pp. 112-117, ACM Press. [9] M. Lee, W. Hsu, C. Jensen, B. Cui, and K. Teo, Supporting frequent updates in r-trees: A bottom-up approach, in VLDB, pages 608-619, 2003, 2003. [10] Mohamed F. Mokbel, Xiaopeing Xiong, and Walid G. Aref, Sina: scalable incremental processing of continuous queries in spatio-temporal databases, in ACM SIGMOD 04. 2004, pp. 623-634, ACM Press. [11] Dmitri V. Kalashnikov, Sunil Prabhakar, and Susanne E. Hambrusch, Main memory evaluation of monitoring queries over moving objects, Distrib.",
                "Parallel Databases, vol. 15, no. 2, pp. 117-135, 2004. [12] Haibo Hu, Jianliang Xu, and Dik Lun Lee, A generic framework for monitoring continuous spatial queries over moving objects., in SIGMOD Conference, 2005. [13] S. Prabhakar, Y. Xia, D. Kalashnikov, W. Aref, and S. Hambrusch, Query indexing and velocity constrained indexing: Scalable techniques for continuous queries on moving objects, IEEE Transactions on Computers, vol. 51, no. 10, pp. 1124-1140, Oct. 2002. [14] Yuni Xia and Sunil Prabhakar, Q+rtree: Efficient indexing for moving object databases, in DASFAA 03, Washington, DC, USA, 2003, p. 175, IEEE Computer Society. [15] C. J.",
                "Van Rijsbergen, Information Retrieval, 2nd edition, Dept. of Computer Science, University of Glasgow, 1979. 411"
            ],
            "original_annotated_samples": [],
            "translated_annotated_samples": [],
            "translated_text": "",
            "candidates": [],
            "error": []
        }
    }
}