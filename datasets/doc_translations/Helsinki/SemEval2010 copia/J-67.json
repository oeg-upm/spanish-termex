{
    "original_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter∗ Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu ABSTRACT For the problem of online real-time scheduling of jobs on a single processor, previous work presents matching upper and lower bounds on the competitive ratio that can be achieved by a deterministic algorithm. However, these results only apply to the non-strategic setting in which the jobs are released directly to the algorithm. Motivated by emerging areas such as grid computing, we instead consider this problem in an economic setting, in which each job is released to a separate, self-interested agent. The agent can then delay releasing the job to the algorithm, inflate its length, and declare an arbitrary value and deadline for the job, while the center determines not only the schedule, but the payment of each agent. For the resulting mechanism design problem (in which we also slightly strengthen an assumption from the non-strategic setting), we present a mechanism that addresses each incentive issue, while only increasing the competitive ratio by one. We then show a matching lower bound for deterministic mechanisms that never pay the agents. Categories and Subject Descriptors I.2.11 [Artificial Intelligence]: Distributed Artificial Intelligence-Multiagent systems; J.4 [Social and Behavioral Sciences]: Economics; F.1.2 [Computation by Abstract Devices]: Modes of Computation-Online computation General Terms Algorithms, Economics, Design, Theory 1. INTRODUCTION We consider the problem of online scheduling of jobs on a single processor. Each job is characterized by a release time, a deadline, a processing time, and a value for successful completion by its deadline. The objective is to maximize the sum of the values of the jobs completed by their respective deadlines. The key challenge in this online setting is that the schedule must be constructed in real-time, even though nothing is known about a job until its release time. Competitive analysis [6, 10], with its roots in [12], is a well-studied approach for analyzing online algorithms by comparing them against the optimal oﬄine algorithm, which has full knowledge of the input at the beginning of its execution. One interpretation of this approach is as a game between the designer of the online algorithm and an adversary. First, the designer selects the online algorithm. Then, the adversary observes the algorithm and selects the sequence of jobs that maximizes the competitive ratio: the ratio of the value of the jobs completed by an optimal oﬄine algorithm to the value of those completed by the online algorithm. Two papers paint a complete picture in terms of competitive analysis for this setting, in which the algorithm is assumed to know k, the maximum ratio between the value densities (value divided by processing time) of any two jobs. For k = 1, [4] presents a 4-competitive algorithm, and proves that this is a lower bound on the competitive ratio for deterministic algorithms. The same paper also generalizes the lower bound to (1 + √ k)2 for any k ≥ 1, and [15] then presents a matching (1 + √ k)2 -competitive algorithm. The setting addressed by these papers is completely nonstrategic, and the algorithm is assumed to always know the true characteristics of each job upon its release. However, in domains such as grid computing (see, for example, [7, 8]) this assumption is invalid, because buyers of processor time choose when and how to submit their jobs. Furthermore, sellers not only schedule jobs but also determine the amount that they charge buyers, an issue not addressed in the non-strategic setting. Thus, we consider an extension of the setting in which each job is owned by a separate, self-interested agent. Instead of being released to the algorithm, each job is now released only to its owning agent. Each agent now has four different ways in which it can manipulate the algorithm: it decides when to submit the job to the algorithm after the true release time, it can artificially inflate the length of the job, and it can declare an arbitrary value and deadline for the job. Because the agents are self-interested, they will choose to manipulate the algorithm if doing so will cause 61 their job to be completed; and, indeed, one can find examples in which agents have incentive to manipulate the algorithms presented in [4] and [15]. The addition of self-interested agents moves the problem from the area of algorithm design to that of mechanism design [17], the science of crafting protocols for self-interested agents. Recent years have seen much activity at the interface of computer science and mechanism design (see, e.g., [9, 18, 19]). In general, a mechanism defines a protocol for interaction between the agents and the center that culminates with the selection of an outcome. In our setting, a mechanism will take as input a job from each agent, and return a schedule for the jobs, and a payment to be made by each agent to the center. A basic solution concept of mechanism design is incentive compatibility, which, in our setting, requires that it is always in each agents best interests to immediately submit its job upon release, and to truthfully declare its value, length, and deadline. In order to evaluate a mechanism using competitive analysis, the adversary model must be updated. In the new model, the adversary still determines the sequence of jobs, but it is the self-interested agents who determine the observed input of the mechanism. Thus, in order to achieve a competitive ratio of c, an online mechanism must both be incentive compatible, and always achieve at least 1 c of the value that the optimal oﬄine mechanism achieves on the same sequence of jobs. The rest of the paper is structured as follows. In Section 2, we formally define and review results from the original, non-strategic setting. After introducing the incentive issues through an example, we formalize the mechanism design setting in Section 3. In Section 4 we present our first main result, a ((1 + √ k)2 + 1)-competitive mechanism, and formally prove incentive compatibility and the competitive ratio. We also show how we can simplify this mechanism for the special case in which k = 1 and each agent cannot alter the length of its job. Returning the general setting, we show in Section 5 that this competitive ratio is a lower bound for deterministic mechanisms that do not pay agents. Finally, in Section 6, we discuss related work other than the directly relevant [4] and [15], before concluding with Section 7. 2. NON-STRATEGIC SETTING In this section, we formally define the original, non-strategic setting, and recap previous results. 2.1 Formulation There exists a single processor on which jobs can execute, and N jobs, although this number is not known beforehand. Each job i is characterized by a tuple θi = (ri, di, li, vi), which denotes the release time, deadline, length of processing time required, and value, respectively. The space Θi of possible tuples is the same for each job and consists of all θi such that ri, di, li, vi ∈ + (thus, the model of time is continuous). Each job is released at time ri, at which point its three other characteristics are known. Nothing is known about the job before its arrival. Each deadline is firm (or, hard), which means that no value is obtained for a job that is completed after its deadline. Preemption of jobs is allowed, and it takes no time to switch between jobs. Thus, job i is completed if and only if the total time it executes on the processor before di is at least li. Let θ = (θ1, . . . , θN ) denote the vector of tuples for all jobs, and let θ−i = (θ1, . . . , θi−1, θi+1, . . . , θN ) denote the same vector without the tuple for job i. Thus, (θi, θ−i) denotes a complete vector of tuples. Define the value density ρi = vi li of job i to be the ratio of its value to its length. For an input θ, denote the maximum and minimum value densities as ρmin = mini ρi and ρmax = maxi ρi. The importance ratio is then defined to be ρmax ρmin , the maximal ratio of value densities between two jobs. The algorithm is assumed to always know an upper bound k on the importance ratio. For simplicity, we normalize the range of possible value densities so that ρmin = 1. An online algorithm is a function f : Θ1 × . . . × ΘN → O that maps the vector of tuples (for any number N) to an outcome o. An outcome o ∈ O is simply a schedule of jobs on the processor, recorded by the function S : + → {0, 1, . . . , N}, which maps each point in time to the active job, or to 0 if the processor is idle. To denote the total elapsed time that a job has spent on the processor at time t, we will use the function ei(t) = t 0 µ(S(x) = i)dx, where µ(·) is an indicator function that returns 1 if the argument is true, and zero otherwise. A jobs laxity at time t is defined to be di − t − li + ei(t) , the amount of time that it can remain inactive and still be completed by its deadline. A job is abandoned if it cannot be completed by its deadline (formally, if di −t+ei(t) < li). Also, overload S(·) and ei(·) so that they can also take a vector θ as an argument. For example, S(θ, t) is shorthand for the S(t) of the outcome f(θ), and it denotes the active job at time t when the input is θ. Since a job cannot be executed before its release time, the space of possible outcomes is restricted in that S(θ, t) = i implies ri ≤ t. Also, because the online algorithm must produce the schedule over time, without knowledge of future inputs, it must make the same decision at time t for inputs that are indistinguishable at this time. Formally, let θ(t) denote the subset of the tuples in θ that satisfy ri ≤ t. The constraint is then that θ(t) = θ (t) implies S(θ, t) = S(θ , t). The objective function is the sum of the values of the jobs that are completed by their respective deadlines: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . Let W∗ (θ) = maxo∈O W(o, θ) denote the maximum possible total value for the profile θ. In competitive analysis, an online algorithm is evaluated by comparing it against an optimal oﬄine algorithm. Because the oﬄine algorithm knows the entire input θ at time 0 (but still cannot start each job i until time ri), it always achieves W∗ (θ). An online algorithm f(·) is (strictly) c-competitive if there does not exist an input θ such that c · W(f(θ), θ) < W∗ (θ). An algorithm that is c-competitive is also said to achieve a competitive ratio of c. We assume that there does not exist an overload period of infinite duration. A period of time [ts , tf ] is overloaded if the sum of the lengths of the jobs whose release time and deadline both fall within the time period exceeds the duration of the interval (formally, if tf −ts ≤ i|(ts≤ri,di≤tf ) li). Without such an assumption, it is not possible to achieve a finite competitive ratio [15]. 2.2 Previous Results In the non-strategic setting, [4] presents a 4-competitive algorithm called TD1 (version 2) for the case of k = 1, while [15] presents a (1+ √ k)2 -competitive algorithm called Dover for the general case of k ≥ 1. Matching lower bounds for deterministic algorithms for both of these cases were shown 62 in [4]. In this section we provide a high-level description of TD1 (version 2) using an example. TD1 (version 2) divides the schedule into intervals, each of which begins when the processor transitions from idle to busy (call this time tb ), and ends with the completion of a job. The first active job of an interval may have laxity; however, for the remainder of the interval, preemption of the active job is only considered when some other job has zero laxity. For example, when the input is the set of jobs listed in Table 1, the first interval is the complete execution of job 1 over the range [0.0, 0.9]. No preemption is considered during this interval, because job 2 has laxity until time 1.5. Then, a new interval starts at tb = 0.9 when job 2 becomes active. Before job 2 can finish, preemption is considered at time 4.8, when job 3 is released with zero laxity. In order to decide whether to preempt the active job, TD1 (version 2) uses two more variables: te and p loss. The former records the latest deadline of a job that would be abandoned if the active job executes to completion (or, if no such job exists, the time that the active job will finish if it is not preempted). In this case, te = 17.0. The value te −tb represents the an upper bound on the amount of possible execution time lost to the optimal oﬄine algorithm due to the completion of the active job. The other variable, p loss, is equal to the length of the first active job of the current interval. Because in general this job could have laxity, the oﬄine algorithm may be able to complete it outside of the range [tb , te ].1 If the algorithm completes the active job and this jobs length is at least te −tb +p loss 4 , then the algorithm is guaranteed to be 4-competitive for this interval (note that k = 1 implies that all jobs have the same value density and thus that lengths can used to compute the competitive ratio). Because this is not case at time 4.8 (since te −tb +p loss 4 = 17.0−0.9+4.0 4 > 4.0 = l2), the algorithm preempts job 2 for job 3, which then executes to completion. Job ri di li vi 1 0.0 0.9 0.9 0.9 2 0.5 5.5 4.0 4.0 3 4.8 17.0 12.2 12.2 01 5 17 6 ? 6 ? 6 ? Table 1: Input used to recap TD1 (version 2) [4]. The up and down arrows represent ri and di, respectively, while the length of the box equals li. 3. MECHANISM DESIGN SETTING However, false information about job 2 would cause TD1 (version 2) to complete this job. For example, if job 2s deadline were declared as ˆd2 = 4.7, then it would have zero laxity at time 0.7. At this time, the algorithm would preempt job 1 for job 2, because te −tb +p loss 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 would then complete before the arrival of job 3.2 1 While it would be easy to alter the algorithm to recognize that this is not possible for the jobs in Table 1, our example does not depend on the use of p loss. 2 While we will not describe the significantly more complex In order to address incentive issues such as this one, we need to formalize the setting as a mechanism design problem. In this section we first present the mechanism design formulation, and then define our goals for the mechanism. 3.1 Formulation There exists a center, who controls the processor, and N agents, where the value of N is unknown by the center beforehand. Each job i is owned by a separate agent i. The characteristics of the job define the agents type θi ∈ Θi. At time ri, agent i privately observes its type θi, and has no information about job i before ri. Thus, jobs are still released over time, but now each job is revealed only to the owning agent. Agents interact with the center through a direct mechanism Γ = (Θ1, . . . , ΘN , g(·)), in which each agent declares a job, denoted by ˆθi = (ˆri, ˆdi, ˆli, ˆvi), and g : Θ1×. . .×ΘN → O maps the declared types to an outcome o ∈ O. An outcome o = (S(·), p1, . . . , pN ) consists of a schedule and a payment from each agent to the mechanism. In a standard mechanism design setting, the outcome is enforced at the end of the mechanism. However, since the end is not well-defined in this online setting, we choose to model returning the job if it is completed and collecting a payment from each agent i as occurring at ˆdi, which, according to the agents declaration, is the latest relevant point of time for that agent. That is, even if job i is completed before ˆdi, the center does not return the job to agent i until that time. This modelling decision could instead be viewed as a decision by the mechanism designer from a larger space of possible mechanisms. Indeed, as we will discuss later, this decision of when to return a completed job is crucial to our mechanism. Each agents utility, ui(g(ˆθ), θi) = vi · µ(ei(ˆθ, di) ≥ li) · µ( ˆdi ≤ di) − pi(ˆθ), is a quasi-linear function of its value for its job (if completed and returned by its true deadline) and the payment it makes to the center. We assume that each agent is a rational, expected utility maximizer. Agent declarations are restricted in that an agent cannot declare a length shorter than the true length, since the center would be able to detect such a lie if the job were completed. On the other hand, in the general formulation we will allow agents to declare longer lengths, since in some settings it may be possible add unnecessary work to a job. However, we will also consider a restricted formulation in which this type of lie is not possible. The declared release time ˆri is the time that the agent chooses to submit job i to the center, and it cannot precede the time ri at which the job is revealed to the agent. The agent can declare an arbitrary deadline or value. To summarize, agent i can declare any type ˆθi = (ˆri, ˆdi, ˆli, ˆvi) such that ˆli ≥ li and ˆri ≥ ri. While in the non-strategic setting it was sufficient for the algorithm to know the upper bound k on the ratio ρmax ρmin , in the mechanism design setting we will strengthen this assumption so that the mechanism also knows ρmin (or, equivalently, the range [ρmin, ρmax] of possible value densities).3 Dover , we note that it is similar in its use of intervals and its preference for the active job. Also, we note that the lower bound we will show in Section 5 implies that false information can also benefit a job in Dover . 3 Note that we could then force agent declarations to satisfy ρmin ≤ ˆvi ˆli ≤ ρmax. However, this restriction would not 63 While we feel that it is unlikely that a center would know k without knowing this range, we later present a mechanism that does not depend on this extra knowledge in a restricted setting. The restriction on the schedule is now that S(ˆθ, t) = i implies ˆri ≤ t, to capture the fact that a job cannot be scheduled on the processor before it is declared to the mechanism. As before, preemption of jobs is allowed, and job switching takes no time. The constraints due to the online mechanisms lack of knowledge of the future are that ˆθ(t) = ˆθ (t) implies S(ˆθ, t) = S(ˆθ , t), and ˆθ( ˆdi) = ˆθ ( ˆdi) implies pi(ˆθ) = pi(ˆθ ) for each agent i. The setting can then be summarized as follows. 1Overview of the Setting: for all t do The center instantiates S(ˆθ, t) ← i, for some i s.t. ˆri ≤ t if ∃i, (ri = t) then θi is revealed to agent i if ∃i, (t ≥ ri) and agent i has not declared a job then Agent i can declare any job ˆθi, s.t. ˆri = t and ˆli ≥ li if ∃i, ( ˆdi = t) ∧ (ei(ˆθ, t) ≥ li) then Completed job i is returned to agent i if ∃i, ( ˆdi = t) then Center sets and collects payment pi(ˆθ) from agent i 3.2 Mechanism Goals Our aim as mechanism designer is to maximize the value of completed jobs, subject to the constraints of incentive compatibility and individual rationality. The condition for (dominant strategy) incentive compatibility is that for each agent i, regardless of its true type and of the declared types of all other agents, agent i cannot increase its utility by unilaterally changing its declaration. Definition 1. A direct mechanism Γ satisfies incentive compatibility (IC) if ∀i, θi, θi, ˆθ−i : ui(g(θi, ˆθ−i), θi) ≥ ui(g(θi, ˆθ−i), θi) From an agent perspective, dominant strategies are desirable because the agent does not have to reason about either the strategies of the other agents or the distribution from the which other agents types are drawn. From a mechanism designer perspective, dominant strategies are important because we can reasonably assume that an agent who has a dominant strategy will play according to it. For these reasons, in this paper we require dominant strategies, as opposed to a weaker equilibrium concept such as Bayes-Nash, under which we could improve upon our positive results.4 decrease the lower bound on the competitive ratio. 4 A possible argument against the need for incentive compatibility is that an agents lie may actually improve the schedule. In fact, this was the case in the example we showed for the false declaration ˆd2 = 4.7. However, if an agent lies due to incorrect beliefs over the future input, then the lie could instead make the schedule the worse (for example, if job 3 were never released, then job 1 would have been unnecessarily abandoned). Furthermore, if we do not know the beliefs of the agents, and thus cannot predict how they will lie, then we can no longer provide a competitive guarantee for our mechanism. While restricting ourselves to incentive compatible direct mechanisms may seem limiting at first, the Revelation Principle for Dominant Strategies (see, e.g., [17]) tells us that if our goal is dominant strategy implementation, then we can make this restriction without loss of generality. The second goal for our mechanism, individual rationality, requires that agents who truthfully reveal their type never have negative utility. The rationale behind this goal is that participation in the mechanism is assumed to be voluntary. Definition 2. A direct mechanism Γ satisfies individual rationality (IR) if ∀i, θi, ˆθ−i, ui(g(θi, ˆθ−i), θi) ≥ 0. Finally, the social welfare function that we aim to maximize is the same as the objective function of the non-strategic setting: W(o, θ) = i vi · µ(ei(θ, di) ≥ li) . As in the nonstrategic setting, we will evaluate an online mechanism using competitive analysis to compare it against an optimal oﬄine mechanism (which we will denote by Γoffline). An oﬄine mechanism knows all of the types at time 0, and thus can always achieve W∗ (θ).5 Definition 3. An online mechanism Γ is (strictly) ccompetitive if it satisfies IC and IR, and if there does not exist a profile of agent types θ such that c·W(g(θ), θ) < W∗ (θ). 4. RESULTS In this section, we first present our main positive result: a (1+ √ k)2 +1 -competitive mechanism (Γ1). After providing some intuition as to why Γ1 satisfies individual rationality and incentive compatibility, we formally prove first these two properties and then the competitive ratio. We then consider a special case in which k = 1 and agents cannot lie about the length of their job, which allows us to alter this mechanism so that it no longer requires either knowledge of ρmin or the collection of payments from agents. Unlike TD1 (version 2) and Dover , Γ1 gives no preference to the active job. Instead, it always executes the available job with the highest priority: (ˆvi + √ k · ei(ˆθ, t) · ρmin). Each agent whose job is completed is then charged the lowest value that it could have declared such that its job still would have been completed, holding constant the rest of its declaration. By the use of a payment rule similar to that of a secondprice auction, Γ1 satisfies both IC with respect to values and IR. We now argue why it satisfies IC with respect to the other three characteristics. Declaring an improved job (i.e., declaring an earlier release time, a shorter length, or a later deadline) could possibly decrease the payment of an agent. However, the first two lies are not possible in our setting, while the third would cause the job, if it is completed, to be returned to the agent after the true deadline. This is the reason why it is important to always return a completed job at its declared deadline, instead of at the point at which it is completed. 5 Another possibility is to allow only the agents to know their types at time 0, and to force Γoffline to be incentive compatible so that agents will truthfully declare their types at time 0. However, this would not affect our results, since executing a VCG mechanism (see, e.g., [17]) at time 0 both satisfies incentive compatibility and always maximizes social welfare. 64 Mechanism 1 Γ1 Execute S(ˆθ, ·) according to Algorithm 1 for all i do if ei(ˆθ, ˆdi) ≥ ˆli {Agent is job is completed} then pi(ˆθ) ← arg minvi≥0(ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) else pi(ˆθ) ← 0 Algorithm 1 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < ˆli)∧(ei(ˆθ, t)+ ˆdi−t ≥ ˆli)} {Set of all released, non-completed, non-abandoned jobs} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(ˆvi + √ k · ei(ˆθ, t) · ρmin) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 It remains to argue why an agent does not have incentive to worsen its job. The only possible effects of an inflated length are delaying the completion of the job and causing it to be abandoned, and the only possible effects of an earlier declared deadline are causing to be abandoned and causing it to be returned earlier (which has no effect on the agents utility in our setting). On the other hand, it is less obvious why agents do not have incentive to declare a later release time. Consider a mechanism Γ1 that differs from Γ1 in that it does not preempt the active job i unless there exists another job j such that (ˆvi + √ k·li(ˆθ, t)·ρmin) < ˆvj. Note that as an active job approaches completion in Γ1, its condition for preemption approaches that of Γ1. However, the types in Table 2 for the case of k = 1 show why an agent may have incentive to delay the arrival of its job under Γ1. Job 1 becomes active at time 0, and job 2 is abandoned upon its release at time 6, because 10 + 10 = v1 +l1 > v2 = 13. Then, at time 8, job 1 is preempted by job 3, because 10 + 10 = v1 + l1 < v3 = 22. Job 3 then executes to completion, forcing job 1 to be abandoned. However, job 2 had more weight than job 1, and would have prevented job 3 from being executed if it had been the active job at time 8, since 13 + 13 = v2 + l2 > v3 = 22. Thus, if agent 1 had falsely declared ˆr1 = 20, then job 3 would have been abandoned at time 8, and job 1 would have completed over the range [20, 30]. Job ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6 ? 6 ? 6 ? Table 2: Jobs used to show why a slightly altered version of Γ1 would not be incentive compatible with respect to release times. Intuitively, Γ1 avoids this problem because of two properties. First, when a job becomes active, it must have a greater priority than all other available jobs. Second, because a jobs priority can only increase through the increase of its elapsed time, ei(ˆθ, t), the rate of increase of a jobs priority is independent of its characteristics. These two properties together imply that, while a job is active, there cannot exist a time at which its priority is less than the priority that one of these other jobs would have achieved by executing on the processor instead. 4.1 Proof of Individual Rationality and Incentive Compatibility After presenting the (trivial) proof of IR, we break the proof of IC into lemmas. Theorem 1. Mechanism Γ1 satisfies individual rationality. Proof. For arbitrary i, θi, ˆθ−i, if job i is not completed, then agent i pays nothing and thus has a utility of zero; that is, pi(θi, ˆθ−i) = 0 and ui(g(θi, ˆθ−i), θi) = 0. On the other hand, if job i is completed, then its value must exceed agent is payment. Formally, ui(g(θi, ˆθ−i), θi) = vi − arg minvi≥0(ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) ≥ 0 must hold, since vi = vi satisfies the condition. To prove IC, we need to show that for an arbitrary agent i, and an arbitrary profile ˆθ−i of declarations of the other agents, agent i can never gain by making a false declaration ˆθi = θi, subject to the constraints that ˆri ≥ ri and ˆli ≥ li. We start by showing that, regardless of ˆvi, if truthful declarations of ri, di, and li do not cause job i to be completed, then worse declarations of these variables (that is, declarations that satisfy ˆri ≥ ri, ˆli ≥ li and ˆdi ≤ di) can never cause the job to be completed. We break this part of the proof into two lemmas, first showing that it holds for the release time, regardless of the declarations of the other variables, and then for length and deadline. Lemma 2. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli Proof. Assume by contradiction that this condition does not hold- that is, job i is not completed when ri is truthfully declared, but is completed for some false declaration ˆri ≥ ri. We first analyze the case in which the release time is truthfully declared, and then we show that job i cannot be completed when agent i delays submitting it to the center. Case I: Agent i declares ˆθi = (ri, ˆdi, ˆli, ˆvi). First, define the following three points in the execution of job i. • Let ts = arg mint S((ˆθi, ˆθ−i), t) = i be the time that job i first starts execution. • Let tp = arg mint>ts S((ˆθi, ˆθ−i), t) = i be the time that job i is first preempted. • Let ta = arg mint ei((ˆθi, ˆθ−i), t) + ˆdi − t < ˆli be the time that job i is abandoned. 65 If ts and tp are undefined because job i never becomes active, then let ts = tp = ta . Also, partition the jobs declared by other agents before ta into the following three sets. • X = {j|(ˆrj < tp ) ∧ (j = i)} consists of the jobs (other than i) that arrive before job i is first preempted. • Y = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj > ˆvi + √ k·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have higher priority than job i (note that we are make use of the normalization). • Z = {j|(tp ≤ ˆrj ≤ ta )∧(ˆvj ≤ ˆvi + √ k ·ei((ˆθi, ˆθ−i), ˆrj)} consists of the jobs that arrive in the range [tp , ta ] and that when they arrive have lower priority than job i. We now show that all active jobs during the range (tp , ta ] must be either i or in the set Y . Unless tp = ta (in which case this property trivially holds), it must be the case that job i has a higher priority than an arbitrary job x ∈ X at time tp , since at the time just preceding tp job x was available and job i was active. Formally, ˆvx + √ k · ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) must hold.6 We can then show that, over the range [tp , ta ], no job x ∈ X runs on the processor. Assume by contradiction that this is not true. Let tf ∈ [tp , ta ] be the earliest time in this range that some job x ∈ X is active, which implies that ex((ˆθi, ˆθ−i), tf ) = ex((ˆθi, ˆθ−i), tp ). We can then show that job i has a higher priority at time tf as follows: ˆvx+ √ k·ex((ˆθi, ˆθ−i), tf ) = ˆvx+ √ k·ex((ˆθi, ˆθ−i), tp ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), tp ) ≤ ˆvi + √ k · ei((ˆθi, ˆθ−i), tf ), contradicting the fact that job x is active at time tf . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz > tp , since by definition job i has a higher priority at that time. The only remaining jobs that can be active over the range (tp , ta ] are i and those in the set Y . Case II: Agent i declares ˆθi = (ˆri, ˆdi, ˆli, ˆvi), where ˆri > ri. We now show that job i cannot be completed in this case, given that it was not completed in case I. First, we can restrict the range of ˆri that we need to consider as follows. Declaring ˆri ∈ (ri, ts ] would not affect the schedule, since ts would still be the first time that job i executes. Also, declaring ˆri > ta could not cause the job to be completed, since di − ta < ˆli holds, which implies that job i would be abandoned at its release. Thus, we can restrict consideration to ˆri ∈ (ts , ta ]. In order for declaring ˆθi to cause job i to be completed, a necessary condition is that the execution of some job yc ∈ Y must change during the range (tp , ta ], since the only jobs other than i that are active during that range are in Y . Let tc = arg mint∈(tp,ta][∃yc ∈ Y, (S((ˆθi, ˆθ−i), t) = yc ) ∧ (S((ˆθi, ˆθ−i), t) = yc )] be the first time that such a change occurs. We will now show that for any ˆri ∈ (ts , ta ], there cannot exist a job with higher priority than yc at time tc , contradicting (S((ˆθi, ˆθ−i), t) = yc ). First note that job i cannot have a higher priority, since there would have to exist a t ∈ (tp , tc ) such that ∃y ∈ 6 For simplicity, when we give the formal condition for a job x to have a higher priority than another job y, we will assume that job xs priority is strictly greater than job ys, because, in the case of a tie that favors x, future ties would also be broken in favor of job x. Y, (S((ˆθi, ˆθ−i), t) = y) ∧ (S((ˆθi, ˆθ−i), t) = i), contradicting the definition of tc . Now consider an arbitrary y ∈ Y such that y = yc . In case I, we know that job y has lower priority than yc at time tc ; that is, ˆvy + √ k·ey((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k·eyc ((ˆθi, ˆθ−i), tc ). Thus, moving to case II, job y must replace some other job before tc . Since ˆry ≥ tp , the condition is that there must exist some t ∈ (tp , tc ) such that ∃w ∈ Y ∪{i}, (S((ˆθi, ˆθ−i), t) = w) ∧ (S((ˆθi, ˆθ−i), t) = y). Since w ∈ Y would contradict the definition of tc , we know that w = i. That is, the job that y replaces must be i. By definition of the set Y , we know that ˆvy > ˆvi + √ k · ei((ˆθi, ˆθ−i), ˆry). Thus, if ˆry ≤ t, then job i could not have executed instead of y in case I. On the other hand, if ˆry > t, then job y obviously could not execute at time t, contradicting the existence of such a time t. Now consider an arbitrary job x ∈ X. We know that in case I job i has a higher priority than job x at time ts , or, formally, that ˆvx + √ k · ex((ˆθi, ˆθ−i), ts ) < ˆvi + √ k · ei((ˆθi, ˆθ−i), ts ). We also know that ˆvi + √ k·ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Since delaying is arrival will not affect the execution up to time ts , and since job x cannot execute instead of a job y ∈ Y at any time t ∈ (tp , tc ] by definition of tc , the only way for job xs priority to increase before tc as we move from case I to II is to replace job i over the range (ts , tc ]. Thus, an upper bound on job xs priority when agent i declares ˆθi is: ˆvx+ √ k· ex((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) < ˆvi + √ k· ei((ˆθi, ˆθ−i), ts )+ei((ˆθi, ˆθ−i), tc )−ei((ˆθi, ˆθ−i), ts ) = ˆvi + √ k · ei((ˆθi, ˆθ−i), tc ) < ˆvyc + √ k · eyc ((ˆθi, ˆθ−i), tc ). Thus, even at this upper bound, job yc would execute instead of job x at time tc . A similar argument applies to an arbitrary job z ∈ Z, starting at it release time ˆrz. Since the sets {i}, X, Y, Z partition the set of jobs released before ta , we have shown that no job could execute instead of job yc , contradicting the existence of tc , and completing the proof. Lemma 3. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆvi, ˆli ≥ li, ˆdi ≤ di, ei ((ri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ri, di, li, ˆvi), ˆθ−i), ˆdi ≥ li Proof. Assume by contradiction there exists some instantiation of the above variables such that job i is not completed when li and di are truthfully declared, but is completed for some pair of false declarations ˆli ≥ li and ˆdi ≤ di. Note that the only effect that ˆdi and ˆli have on the execution of the algorithm is on whether or not i ∈ Avail. Specifically, they affect the two conditions: (ei(ˆθ, t) < ˆli) and (ei(ˆθ, t) + ˆdi − t ≥ ˆli). Because job i is completed when ˆli and ˆdi are declared, the former condition (for completion) must become false before the latter. Since truthfully declaring li ≤ ˆli and di ≥ ˆdi will only make the former condition become false earlier and the latter condition become false later, the execution of the algorithm will not be affected when moving to truthful declarations, and job i will be completed, a contradiction. We now use these two lemmas to show that the payment for a completed job can only increase by falsely declaring worse ˆli, ˆdi, and ˆri. 66 Lemma 4. In mechanism Γ1, the following condition holds for all i, θi, ˆθ−i: ∀ ˆli ≥ li, ˆdi ≤ di, ˆri ≥ ri, arg min vi≥0 ei ((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi ≥ ˆli ≥ arg min vi≥0 ei ((ri, di, li, vi), ˆθ−i), di ≥ li Proof. Assume by contradiction that this condition does not hold. This implies that there exists some value vi such that the condition (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) holds, but (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li) does not. Applying Lemmas 2 and 3: (ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli) =⇒ (ei(((ri, di, li, vi), ˆθ−i), di) ≥ li), a contradiction. Finally, the following lemma tells us that the completion of a job is monotonic in its declared value. Lemma 5. In mechanism Γ1, the following condition holds for all i, ˆθi, ˆθ−i: ∀ ˆvi ≥ ˆvi, ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli =⇒ ei ((ˆri, ˆdi, ˆli, ˆvi), ˆθ−i), ˆdi ≥ ˆli The proof, by contradiction, of this lemma is omitted because it is essentially identical to that of Lemma 2 for ˆri. In case I, agent i declares (ˆri, ˆdi, ˆli, ˆvi) and the job is not completed, while in case II he declares (ˆri, ˆdi, ˆli, ˆvi) and the job is completed. The analysis of the two cases then proceeds as before- the execution will not change up to time ts because the initial priority of job i decreases as we move from case I to II; and, as a result, there cannot be a change in the execution of a job other than i over the range (tp , ta ]. We can now combine the lemmas to show that no profitable deviation is possible. Theorem 6. Mechanism Γ1 satisfies incentive compatibility. Proof. For an arbitrary agent i, we know that ˆri ≥ ri and ˆli ≥ li hold by assumption. We also know that agent i has no incentive to declare ˆdi > di, because job i would never be returned before its true deadline. Then, because the payment function is non-negative, agent is utility could not exceed zero. By IR, this is the minimum utility it would achieve if it truthfully declared θi. Thus, we can restrict consideration to ˆθi that satisfy ˆri ≥ ri, ˆli ≥ li, and ˆdi ≤ di. Again using IR, we can further restrict consideration to ˆθi that cause job i to be completed, since any other ˆθi yields a utility of zero. If truthful declaration of θi causes job i to be completed, then by Lemma 4 any such false declaration ˆθi could not decrease the payment of agent i. On the other hand, if truthful declaration does not cause job i to be completed, then declaring such a ˆθi will cause agent i to have negative utility, since vi < arg minvi≥0 ei(((ri, di, li, vi), ˆθ−i), ˆdi) ≥ li ≤ arg minvi≥0 ei(((ˆri, ˆdi, ˆli, vi), ˆθ−i), ˆdi) ≥ ˆli holds by Lemmas 5 and 4, respectively. 4.2 Proof of Competitive Ratio The proof of the competitive ratio, which makes use of techniques adapted from those used in [15], is also broken into lemmas. Having shown IC, we can assume truthful declaration (ˆθ = θ). Since we have also shown IR, in order to prove the competitive ratio it remains to bound the loss of social welfare against Γoffline. Denote by (1, 2, . . . , F) the sequence of jobs completed by Γ1. Divide time into intervals If = (topen f , tclose f ], one for each job f in this sequence. Set tclose f to be the time at which job f is completed, and set topen f = tclose f−1 for f ≥ 2, and topen 1 = 0 for f = 1. Also, let tbegin f be the first time that the processor is not idle in interval If . Lemma 7. For any interval If , the following inequality holds: tclose f − tbegin f ≤ (1 + 1√ k ) · vf Proof. Interval If begins with a (possibly zero length) period of time in which the processor is idle because there is no available job. Then, it continuously executes a sequence of jobs (1, 2, . . . , c), where each job i in this sequence is preempted by job i + 1, except for job c, which is completed (thus, job c in this sequence is the same as job f is the global sequence of completed jobs). Let ts i be the time that job i begins execution. Note that ts 1 = tbegin f . Over the range [tbegin f , tclose f ], the priority (vi+ √ k·ei(θ, t)) of the active job is monotonically increasing with time, because this function linearly increases while a job is active, and can only increase at a point in time when preemption occurs. Thus, each job i > 1 in this sequence begins execution at its release time (that is, ts i = ri), because its priority does not increase while it is not active. We now show that the value of the completed job c exceeds the product of √ k and the time spent in the interval on jobs 1 through c−1, or, more formally, that the following condition holds: vc ≥ √ k c−1 h=1(eh(θ, ts h+1) − eh(θ, ts h)). To show this, we will prove by induction that the stronger condition vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds for all jobs i in the sequence. Base Case: For i = 1, v1 ≥ √ k 0 h=1 eh(θ, ts h+1) = 0, since the sum is over zero elements. Inductive Step: For an arbitrary 1 ≤ i < c, we assume that vi ≥ √ k i−1 h=1 eh(θ, ts h+1) holds. At time ts i+1, we know that vi+1 ≥ vi + √ k · ei(θ, ts i+1) holds, because ts i+1 = ri+1. These two inequalities together imply that vi+1 ≥√ k i h=1 eh(θ, ts h+1), completing the inductive step. We also know that tclose f − ts c ≤ lc ≤ vc must hold, by the simplifying normalization of ρmin = 1 and the fact that job cs execution time cannot exceed its length. We can thus bound the total execution time of If by: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh(θ, ts h+1)−eh(θ, ts h)) ≤ (1+ 1√ k )vf . We now consider the possible execution of uncompleted jobs by Γoffline. Associate each job i that is not completed by Γ1 with the interval during which it was abandoned. All jobs are now associated with an interval, since there are no gaps between the intervals, and since no job i can be abandoned after the close of the last interval at tclose F . Because the processor is idle after tclose F , any such job i would become active at some time t ≥ tclose F , which would lead to the completion of some job, creating a new interval and contradicting the fact that IF is the last one. 67 The following lemma is equivalent to Lemma 5.6 of [15], but the proof is different for our mechanism. Lemma 8. For any interval If and any job i abandoned in If , the following inequality holds: vi ≤ (1 + √ k)vf . Proof. Assume by contradiction that there exists a job i abandoned in If such that vi > (1 + √ k)vf . At tclose f , the priority of job f is vf + √ k · lf < (1 + √ k)vf . Because the priority of the active job monotonically increases over the range [tbegin f , tclose f ], job i would have a higher priority than the active job (and thus begin execution) at some time t ∈ [tbegin f , tclose f ]. Again applying monotonicity, this would imply that the priority of the active job at tclose f exceeds (1 + √ k)vf , contradicting the fact that it is (1 + √ k)vf . As in [15], for each interval If , we give Γoffline the following gift: k times the amount of time in the range [tbegin f , tclose f ] that it does not schedule a job. Additionally, we give the adversary vf , since the adversary may be able to complete this job at some future time, due to the fact that Γ1 ignores deadlines. The following lemma is Lemma 5.10 in [15], and its proof now applies directly. Lemma 9. [15] With the above gifts the total net gain obtained by the clairvoyant algorithm from scheduling the jobs abandoned during If is not greater than (1 + √ k) · vf . The intuition behind this lemma is that the best that the adversary can do is to take almost all of the gift of k ·(tclose f −tbegin f ) (intuitively, this is equivalent to executing jobs with the maximum possible value density over the time that Γ1 is active), and then begin execution of a job abandoned by Γ1 right before tclose f . By Lemma 8, the value of this job is bounded by (1 + √ k) · vf . We can now combine the results of these lemmas to prove the competitive ratio. Theorem 10. Mechanism Γ1 is (1+ √ k)2+1 -competitive. Proof. Using the fact that the way in which jobs are associated with the intervals partitions the entire set of jobs, we can show the competitive ratio by showing that Γ1 is (1+ √ k)2 +1 -competitive for each interval in the sequence (1, . . . , F). Over an arbitrary interval If , the oﬄine algorithm can achieve at most (tclose f −tbegin f )·k+vf +(1+ √ k)vf , from the two gifts and the net gain bounded by Lemma 9. Applying Lemma 7, this quantity is then bounded from above by (1+ 1√ k )·vf ·k+vf +(1+ √ k)vf = ((1+ √ k)2 +1)·vf . Since Γ1 achieves vf , the competitive ratio holds. 4.3 Special Case: Unalterable length and k=1 While so far we have allowed each agent to lie about all four characteristics of its job, lying about the length of the job is not possible in some settings. For example, a user may not know how to alter a computational problem in a way that both lengthens the job and allows the solution of the original problem to be extracted from the solution to the altered problem. Another restriction that is natural in some settings is uniform value densities (k = 1), which was the case considered by [4]. If the setting satisfies these two conditions, then, by using Mechanism Γ2, we can achieve a competitive ratio of 5 (which is the same competitive ratio as Γ1 for the case of k = 1) without knowledge of ρmin and without the use of payments. The latter property may be necessary in settings that are more local than grid computing (e.g., within a department) but in which the users are still self-interested.7 Mechanism 2 Γ2 Execute S(ˆθ, ·) according to Algorithm 2 for all i do pi(ˆθ) ← 0 Algorithm 2 for all t do Avail ← {i|(t ≥ ˆri)∧(ei(ˆθ, t) < li)∧(ei(ˆθ, t)+ ˆdi−t ≥ li)} if Avail = ∅ then S(ˆθ, t) ← arg maxi∈Avail(li + ei(ˆθ, t)) {Break ties in favor of lower ˆri} else S(ˆθ, t) ← 0 Theorem 11. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 satisfies individual rationality and incentive compatibility. Theorem 12. When k = 1, and each agent i cannot falsely declare li, Mechanism Γ2 is 5-competitive. Since this mechanism is essentially a simplification of Γ1, we omit proofs of these theorems. Basically, the fact that k = 1 and ˆli = li both hold allows Γ2 to substitute the priority (li +ei(ˆθ, t)) for the priority used in Γ1; and, since ˆvi is ignored, payments are no longer needed to ensure incentive compatibility. 5. COMPETITIVE LOWER BOUND We now show that the competitive ratio of (1 + √ k)2 + 1 achieved by Γ1 is a lower bound for deterministic online mechanisms. To do so, we will appeal to third requirement on a mechanism, non-negative payments (NNP), which requires that the center never pays an agent (formally, ∀i, ˆθ, pi(ˆθi) ≥ 0). Unlike IC and IR, this requirement is not standard in mechanism design. We note, however, that both Γ1 and Γ2 satisfy it trivially, and that, in the following proof, zero only serves as a baseline utility for an agent, and could be replaced by any non-positive function of ˆθ−i. The proof of the lower bound uses an adversary argument similar to that used in [4] to show a lower bound of (1 +√ k)2 in the non-strategic setting, with the main novelty lying in the perturbation of the job sequence and the related incentive compatibility arguments. We first present a lemma relating to the recurrence used for this argument, with the proof omitted due to space constraints. Lemma 13. For any k ≥ 1, for the recurrence defined by li+1 = λ · li − k · i h=1 lh and l1 = 1, where (1 + √ k)2 − 1 < λ < (1 + √ k)2 , there exists an integer m ≥ 1 such that lm+k· m−1 h=1 lh lm > λ. 7 While payments are not required in this setting, Γ2 can be changed to collect a payments without affecting incentive compatibility by charging some fixed fraction of li for each job i that is completed. 68 Theorem 14. There does not exist a deterministic online mechanism that satisfies NNP and that achieves a competitive ratio less than (1 + √ k)2 + 1. Proof. Assume by contradiction that there exists a deterministic online mechanism Γ that satisfies NNP and that achieves a competitive ratio of c = (1 + √ k)2 + 1 − for some > 0 (and, by implication, satisfies IC and IR as well). Since a competitive ratio of c implies a competitive ratio of c + x, for any x > 0, we assume without loss of generality that < 1. First, we will construct a profile of agent types θ using an adversary argument. After possibly slightly perturbing θ to assure that a strictness property is satisfied, we will then use a more significant perturbation of θ to reach a contradiction. We now construct the original profile θ. Pick an α such that 0 < α < , and define δ = α ck+3k . The adversary uses two sequences of jobs: minor and major. Minor jobs i are characterized by li = δ, vi = k · δ, and zero laxity. The first minor job is released at time 0, and ri = di−1 for all i > 1. The sequence stops whenever Γ completes any job. Major jobs also have zero laxity, but they have the smallest possible value ratio (that is, vi = li). The lengths of the major jobs that may be released, starting with i = 1, are determined by the following recurrence relation. li+1 = (c − 1 + α) · li − k · i h=1 lh l1 = 1 The bounds on α imply that (1 + √ k)2 − 1 < c − 1 + α < (1+ √ k)2 , which allows us to apply Lemma 13. Let m be the smallest positive number such that lm+k· m−1 h=1 lh lm > c−1+α. The first major job has a release time of 0, and each major job i > 1 has a release time of ri = di−1 − δ, just before the deadline of the previous job. The adversary releases major job i ≤ m if and only if each major job j < i was executed continuously over the range [ri, ri+1]. No major job is released after job m. In order to achieve the desired competitive ratio, Γ must complete some major job f, because Γoffline can always at least complete major job 1 (for a value of 1), and Γ can complete at most one minor job (for a value of α c+3 < 1 c ). Also, in order for this job f to be released, the processor time preceding rf can only be spent executing major jobs that are later abandoned. If f < m, then major job f + 1 will be released and it will be the final major job. Γ cannot complete job f +1, because rf +lf = df > rf+1. Therefore, θ consists of major jobs 1 through f + 1 (or, f, if f = m), plus minor jobs from time 0 through time df . We now possibly perturb θ slightly. By IR, we know that vf ≥ pf (θ). Since we will later need this inequality to be strict, if vf = pf (θ), then change θf to θf , where rf = rf , but vf , lf , and df are all incremented by δ over their respective values in θf . By IC, job f must still be completed by Γ for the profile (θf , θ−f ). If not, then by IR and NNP we know that pf (θf , θ−f ) = 0, and thus that uf (g(θf , θ−f ), θf ) = 0. However, agent f could then increase its utility by falsely declaring the original type of θf , receiving a utility of: uf (g(θf , θ−f ), θf ) = vf − pf (θ) = δ > 0, violating IC. Furthermore, agent f must be charged the same amount (that is, pf (θf , θ−f ) = pf (θ)), due to a similar incentive compatibility argument. Thus, for the remainder of the proof, assume that vf > pf (θ). We now use a more substantial perturbation of θ to complete the proof. If f < m, then define θf to be identical to θf , except that df = df+1 + lf , allowing job f to be completely executed after job f + 1 is completed. If f = m, then instead set df = df +lf . IC requires that for the profile (θf , θ−f ), Γ still executes job f continuously over the range [rf , rf +lf ], thus preventing job f +1 from being completed. Assume by contradiction that this were not true. Then, at the original deadline of df , job f is not completed. Consider the possible profile (θf , θ−f , θx), which differs from the new profile only in the addition of a job x which has zero laxity, rx = df , and vx = lx = max(df − df , (c + 1) · (lf + lf+1)). Because this new profile is indistinguishable from (θf , θ−f ) to Γ before time df , it must schedule jobs in the same way until df . Then, in order to achieve the desired competitive ratio, it must execute job x continuously until its deadline, which is by construction at least as late as the new deadline df of job f. Thus, job f will not be completed, and, by IR and NNP, it must be the case that pf (θf , θ−f , θx) = 0 and uf (g(θf , θ−f , θx), θf ) = 0. Using the fact that θ is indistinguishable from (θf , θ−f , θx) up to time df , if agent f falsely declared his type to be the original θf , then its job would be completed by df and it would be charged pf (θ). Its utility would then increase to uf (g(θf , θ−f , θx), θf ) = vf − pf (θ) > 0, contradicting IC. While Γs execution must be identical for both (θf , θ−f ) and (θf , θ−f ), Γoffline can take advantage of the change. If f < m, then Γ achieves a value of at most lf +δ (the value of job f if it were perturbed), while Γoffline achieves a value of at least k·( f h=1 lh −2δ)+lf+1 +lf by executing minor jobs until rf+1, followed by job f +1 and then job f (we subtract two δs instead of one because the last minor job before rf+1 may have to be abandoned). Substituting in for lf+1, the competitive ratio is then at least: k·( f h=1 lh−2δ)+lf+1+lf lf +δ = k·( f h=1 lh)−2k·δ+(c−1+α)·lf −k·( f h=1 lh)+lf lf +δ = c·lf +(α·lf −2k·δ) lf +δ ≥ c·lf +((ck+3k)δ−2k·δ) lf +δ > c. If instead f = m, then Γ achieves a value of at most lm +δ, while Γoffline achieves a value of at least k · ( m h=1 lh − 2δ) + lm by completing minor jobs until dm = rm + lm, and then completing job m. The competitive ratio is then at least: k·( m h=1 lh−2δ)+lm lm+δ = k·( m−1 h=1 lh)−2k·δ+klm+lm lm+δ > (c−1+α)·lm−2k·δ+klm lm+δ = (c+k−1)·lm+(αlm−2k·δ) lm+δ > c. 6. RELATED WORK In this section we describe related work other than the two papers ([4] and [15]) on which this paper is based. Recent work related to this scheduling domain has focused on competitive analysis in which the online algorithm uses a faster processor than the oﬄine algorithm (see, e.g., [13, 14]). Mechanism design was also applied to a scheduling problem in [18]. In their model, the center owns the jobs in an oﬄine setting, and it is the agents who can execute them. The private information of an agent is the time it will require to execute each job. Several incentive compatible mechanisms are presented that are based on approximation algorithms for the computationally infeasible optimization problem. This paper also launched the area of algorithmic mechanism design, in which the mechanism must sat69 isfy computational requirements in addition to the standard incentive requirements. A growing sub-field in this area is multicast cost-sharing mechanism design (see, e.g., [1]), in which the mechanism must efficiently determine, for each agent in a multicast tree, whether the agent receives the transmission and the price it must pay. For a survey of this and other topics in distributed algorithmic mechanism design, see [9]. Online execution presents a different type of algorithmic challenge, and several other papers study online algorithms or mechanisms in economic settings. For example, [5] considers an online market clearing setting, in which the auctioneer matches buy and sells bids (which are assumed to be exogenous) that arrive and expire over time. In [2], a general method is presented for converting an online algorithm into an online mechanism that is incentive compatible with respect to values. Truthful declaration of values is also considered in [3] and [16], which both consider multi-unit online auctions. The main difference between the two is that the former considers the case of a digital good, which thus has unlimited supply. It is pointed out in [16] that their results continue to hold when the setting is extended so that bidders can delay their arrival. The only other paper we are aware of that addresses the issue of incentive compatibility in a real-time system is [11], which considers several variants of a model in which the center allocates bandwidth to agents who declare both their value and their arrival time. A dominant strategy IC mechanism is presented for the variant in which every point in time is essentially independent, while a Bayes-Nash IC mechanism is presented for the variant in which the centers current decision affects the cost of future actions. 7. CONCLUSION In this paper, we considered an online scheduling domain for which algorithms with the best possible competitive ratio had been found, but for which new solutions were required when the setting is extended to include self-interested agents. We presented a mechanism that is incentive compatible with respect to release time, deadline, length and value, and that only increases the competitive ratio by one. We also showed how this mechanism could be simplified when k = 1 and each agent cannot lie about the length of its job. We then showed a matching lower bound on the competitive ratio that can be achieved by a deterministic mechanism that never pays the agents. Several open problems remain in this setting. One is to determine whether the lower bound can be strengthened by removing the restriction of non-negative payments. Also, while we feel that it is reasonable to strengthen the assumption of knowing the maximum possible ratio of value densities (k) to knowing the actual range of possible value densities, it would be interesting to determine whether there exists a ((1 + √ k)2 + 1)-competitive mechanism under the original assumption. Finally, randomized mechanisms provide an unexplored area for future work. 8. REFERENCES [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, and S. Shenker, Approximation and collusion in multicast cost sharing, Games and Economic Behavior (to appear). [2] B. Awerbuch, Y. Azar, and A. Meyerson, Reducing truth-telling online mechanisms to online optimization, Proceedings on the 35th Symposium on the Theory of Computing, 2003. [3] Z. Bar-Yossef, K. Hildrum, and F. Wu, Incentive-compatible online auctions for digital goods, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, and F. Wang, On the competitiveness of on-line real-time task scheduling, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, and M. Zinkevich, Online algorithms for market clearing, Proceedings of the 13th Annual ACM-SIAM Symposium on Discrete Algorithms, 2002. [6] A. Borodin and R. El-Yaniv, Online computation and competitive analysis, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, and H. Stockinger, Economic models for resource management and scheduling in grid computing, The Journal of Concurrency and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation over the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum and S. Shenker, Distributed algorithmic mechanism design: Recent results and future directions, Proceedings of the 6th International Workshop on Discrete Algorithms and Methods for Mobile Computing and Communications, 2002, pp. 1-13. [10] A. Fiat and G. Woeginger (editors), Online algorithms: The state of the art, Springer Verlag, 1998. [11] E. Friedman and D. Parkes, Pricing wifi at starbucksissues in online mechanism design, EC03, 2003. [12] R. L. Graham, Bounds for certain multiprocessor anomalies, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram and K. Pruhs, Speed is as powerful as clairvoyance, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, and K. To, On-line scheduling with tight deadlines, Theoretical Computer Science 295 (2003), 251-261. [15] G. Koren and D. Shasha, D-over: An optimal on-line scheduling algorithm for overloaded real-time systems, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi and N. Nisan, Competitive analysis of online auctions, EC00, 2000. [17] A. Mas-Colell, M. Whinston, and J. Green, Microeconomic theory, Oxford University Press, 1995. [18] N. Nisan and A. Ronen, Algorithmic mechanism design, Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algorithms, games, and the internet, STOC, 2001, pp. 749-753. 70",
    "original_translation": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70",
    "error_count": 18,
    "keys": {
        "online scheduling of job": {
            "translated_key": [
                "máxima",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline"
            ]
        },
        "job online scheduling": {
            "translated_key": [
                "máxima",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline"
            ]
        },
        "competitive ratio": {
            "translated_key": [
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación de competencia",
                "relación competitiva",
                "máxima",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "offline",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "offline",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación de competencia",
                "relación de competencia",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la \"relación competitiva\" que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la \"relación competitiva\" en uno. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la \"relación competitiva\": la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la \"relación competitiva\" para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una \"relación competitiva\" de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre alcanzar al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo de competencia ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la \"relación de competencia\". También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la sección 5 que esta \"relación competitiva\" es un límite inferior para los mecanismos deterministas que no pagan a los agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una \"relación competitiva\" de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una \"relación competitiva\" finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento se requieren estrategias dominantes, frente a un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la \"relación competitiva\". 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la \"relación competitiva\". A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la \"relación competitiva\", que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Dado que también hemos demostrado IR, para demostrar la \"relación competitiva\" queda por vincular la pérdida de la asistencia social contra \"offline\". Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para probar la \"relación competitiva\". Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la \"relación competitiva\" mostrando que el 1 es (1+ فارسى k)2 +1 -competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor 1 alcanza vf, la \"relación competitiva\" se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una \"relación de competencia\" de 5 (que es la misma \"relación de competencia\" que la de 1 para el caso de k = 1) sin conocimiento de Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODALIDAD COMPETITIVA Ahora mostramos que la \"relación competitiva\" de (1 +  k)2 + 1 lograda por 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga a la NNP y que logre una \"relación competitiva\" inferior a (1 + k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una \"relación competitiva\" de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una \"relación competitiva\" de c implica una \"relación competitiva\" de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la \"relación competitiva\" deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la \"relación competitiva\" deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, Łx) = 0 y uf (g(f, f, Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La sustitución por lf+1, la \"relación competitiva\" es por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el que se habían encontrado algoritmos con la mejor \"relación competitiva\" posible, pero para el que se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la \"relación competitiva\" en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. A continuación, mostramos un límite más bajo en la \"relación competitiva\" que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación de competencia",
                "relación competitiva",
                "máxima",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "offline",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "offline",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación de competencia",
                "relación de competencia",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva",
                "relación competitiva"
            ]
        },
        "deterministic algorithm": {
            "translated_key": [
                "algoritmo determinista",
                "máxima",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr con un \"algoritmo determinista\". Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "algoritmo determinista",
                "máxima",
                "offline"
            ]
        },
        "non-strategic setting": {
            "translated_key": [
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "máxima",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "offline",
                "establecimiento no estratégico"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican al \"establecimiento no estratégico\" en el que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del \"establecimiento no estratégico\"), presentamos un mecanismo que aborda cada cuestión de incentivo, mientras que sólo aumentamos la relación de competencia en uno. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el \"establecimiento no estratégico\". Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y revisamos formalmente los resultados del \"establecimiento no estratégico\" original. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente el \"establecimiento no estratégico\" original, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el \"establecimiento no estratégico\" [4] se presenta un algoritmo de 4 competidores llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] se presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el \"establecimiento no estratégico\" era suficiente para que el algoritmo conozca el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del \"establecimiento no estratégico\": W(o, Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1  k)2 en el \"establecimiento no estratégico\", con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "máxima",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "establecimiento no estratégico",
                "offline",
                "establecimiento no estratégico"
            ]
        },
        "deadline": {
            "translated_key": [
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo límite",
                "plazo",
                "plazo",
                "plazo",
                "máxima",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "offline",
                "plazo límite",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y \"plazo\" para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, un \"plazo\", un tiempo de procesamiento, y un valor para completar con éxito por su \"plazo\". El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de liberación verdadero, puede inflar artificialmente la longitud del trabajo, y puede declarar un valor arbitrario y \"plazo\" para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre sea en el mejor interés de cada agente presentar inmediatamente su trabajo en el momento de la liberación, y declarar verazmente su valor, longitud y \"plazo límite\". Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, \"plazo\", la duración del tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada \"plazo\" es firme (o duro), lo que significa que no se obtiene valor para un trabajo que se completa después de su \"plazo\". Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el tiempo t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y todavía se completa con su \"plazo\". Un trabajo es abandonado si no puede ser completado por su \"plazo\" (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y \"plazo\" ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra el último \"plazo\" de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el trabajo 2s \"plazo\" se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve por su verdadero \"plazo\") y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un \"plazo\" o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta o un \"plazo límite\") podría disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después del verdadero \"plazo\". Esta es la razón por la que es importante devolver siempre un trabajo completado en su \"plazo\" declarado, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un \"plazo\" declarado anteriormente están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la longitud y \"plazo\". Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente yo no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero \"plazo\". Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − , justo antes del \"plazo\" del trabajo anterior. El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en el \"plazo\" original de df, el trabajo f no se completa. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar trabajo x continuamente hasta su \"plazo\", que es por construcción por lo menos tan tarde como el nuevo \"plazo\" df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, \"plazo\", longitud y valor, y que sólo aumenta la relación competitiva en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo límite",
                "plazo",
                "plazo",
                "plazo",
                "máxima",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "offline",
                "plazo límite",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo",
                "plazo"
            ]
        },
        "importance ratio": {
            "translated_key": [
                "relación de importancia",
                "máxima",
                "relación de importancia",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La \"relación de importancia\" se define entonces como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos trabajos. Se supone que el algoritmo siempre conoce un límite superior k en la \"relación de importancia\". Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "relación de importancia",
                "máxima",
                "relación de importancia",
                "offline"
            ]
        },
        "zero laxity": {
            "translated_key": [
                "máxima",
                "cero laxitud",
                "cero laxitud",
                "cero laxitud",
                "offline",
                "cero laxitud",
                "cero laxitud"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene \"cero laxitud\". Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con \"cero laxitud\". Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si la fecha límite de trabajo 2s se declaró como d2 = 4.7, entonces tendría \"cero laxitud\" en el momento 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen \"cero laxitud\", pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene \"cero laxitud\", rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "cero laxitud",
                "cero laxitud",
                "cero laxitud",
                "offline",
                "cero laxitud",
                "cero laxitud"
            ]
        },
        "online algorithm": {
            "translated_key": [
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "máxima",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "offline",
                "algoritmo en línea",
                "algoritmo en línea"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del \"algoritmo en línea\" y un adversario. Primero, el diseñador selecciona el \"algoritmo en línea\". Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el \"algoritmo en línea\". Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un \"algoritmo en línea\" es una función f : ­1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el \"algoritmo en línea\" debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión a la vez t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, se evalúa un \"algoritmo en línea\" comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un \"algoritmo en línea\" f(·) es (estrictamente) c-competitivo si no existe una entrada de tal manera que c · W(f( Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el \"algoritmo en línea\" utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un \"algoritmo en línea\" en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "máxima",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "algoritmo en línea",
                "offline",
                "algoritmo en línea",
                "algoritmo en línea"
            ]
        },
        "quasi-linear function": {
            "translated_key": [
                "máxima",
                "función cuasi-lineal",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una \"función cuasi-lineal\" de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "función cuasi-lineal",
                "offline"
            ]
        },
        "deterministic mechanism": {
            "translated_key": [
                "máxima",
                "offline",
                "mecanismo determinista"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor de la relación competitiva que se puede lograr mediante un \"mecanismo determinista\" que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline",
                "mecanismo determinista"
            ]
        },
        "incentive compatibility": {
            "translated_key": [
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "máxima",
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                ", ",
                ", ",
                ") Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar ni sobre las estrategias de los otros agentes ni sobre la distribución Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento contra la necesidad de ",
                " es que una mentira de agentes puede realmente mejorar el horario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por ",
                "). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué el 1 satisface la racionalidad individual y la ",
                ", demostramos formalmente primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface ",
                " y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la ",
                ". Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente no puedo declarar falsamente li, Mechanism Ł2 satisface la racionalidad individual y la ",
                ". Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambos hand permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la ",
                ". 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1  k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos relacionados de ",
                ". Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Si bien los pagos no son requeridos en este entorno, 2 puede ser cambiado para cobrar un pago sin afectar a la ",
                " cargando una fracción fija de li por cada trabajo i que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse la misma cantidad (es decir, pf (f, f ) = pf ()), debido a un argumento similar de ",
                ". Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro artículo que conocemos que aborda la cuestión de la "
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución para el diseño de mecanismos es la \"compatibilidad incentivadora\", que, en nuestro entorno, requiere que sea siempre en el mejor interés de cada agente presentar inmediatamente su trabajo en el momento de su liberación, y declarar de manera veraz su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1), y formalmente demostrar la \"compatibilidad incentivadora\" y la relación competitiva. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la \"compatibilidad incentivadora\" y la racionalidad individual. La condición para (estrategia dominante) \"compatibilidad incentivadora\" es que para cada agente i, independientemente de su verdadero tipo y de los tipos declarados de todos los demás agentes, el agente i no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo satisface \"compatibilidad incentivadora\" (IC) si \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\", \"i\" ≥ \"i\" (g\", \"i\", \"i\") Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar ni sobre las estrategias de los otros agentes ni sobre la distribución Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento contra la necesidad de \"compatibilidad incentivadora\" es que una mentira de agentes puede realmente mejorar el horario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué el 1 satisface la racionalidad individual y la \"compatibilidad incentivadora\", demostramos formalmente primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface \"compatibilidad incentivadora\" y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la \"compatibilidad incentivadora\". Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente no puedo declarar falsamente li, Mechanism Ł2 satisface la racionalidad individual y la \"compatibilidad incentivadora\". Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambos hand permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la \"compatibilidad incentivadora\". 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1  k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos relacionados de \"compatibilidad incentivadora\". Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Si bien los pagos no son requeridos en este entorno, 2 puede ser cambiado para cobrar un pago sin afectar a la \"compatibilidad incentivadora\" cargando una fracción fija de li por cada trabajo i que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse la misma cantidad (es decir, pf (f, f ) = pf ()), debido a un argumento similar de \"compatibilidad incentivadora\". Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro artículo que conocemos que aborda la cuestión de la \"compatibilidad incentivadora\" en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "máxima",
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "compatibilidad incentivadora",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                "i",
                ", ",
                ", ",
                ") Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar ni sobre las estrategias de los otros agentes ni sobre la distribución Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento contra la necesidad de ",
                " es que una mentira de agentes puede realmente mejorar el horario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por ",
                "). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué el 1 satisface la racionalidad individual y la ",
                ", demostramos formalmente primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface ",
                " y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la ",
                ". Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente no puedo declarar falsamente li, Mechanism Ł2 satisface la racionalidad individual y la ",
                ". Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambos hand permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la ",
                ". 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1  k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos relacionados de ",
                ". Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Si bien los pagos no son requeridos en este entorno, 2 puede ser cambiado para cobrar un pago sin afectar a la ",
                " cargando una fracción fija de li por cada trabajo i que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse la misma cantidad (es decir, pf (f, f ) = pf ()), debido a un argumento similar de ",
                ". Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro artículo que conocemos que aborda la cuestión de la "
            ]
        },
        "individual rationality": {
            "translated_key": [
                "máxima",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "offline",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad con los incentivos y la \"racionalidad individual\". La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. El segundo objetivo de nuestro mecanismo, la \"racionalidad individual\", requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo satisface la \"racionalidad individual\" (IR) si Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface \"racionalidad individual\" y compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la \"racionalidad individual\". Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mechanism Ł2 satisface \"racionalidad individual\" y compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual",
                "offline",
                "racionalidad individual",
                "racionalidad individual",
                "racionalidad individual"
            ]
        },
        "profitable deviation": {
            "translated_key": [
                "máxima",
                "offline",
                "desviación rentable"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna \"desviación rentable\" es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline",
                "desviación rentable"
            ]
        },
        "monotonicity": {
            "translated_key": [
                "máxima",
                "offline",
                "monotonicidad"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más aplicando la \"monotonicidad\", esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline",
                "monotonicidad"
            ]
        },
        "mechanism design": {
            "translated_key": [
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "máxima",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "offline",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "mecanismo",
                "diseño mecánico",
                "diseño mecánico"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema resultante del \"diseño mecánico\" (en el que también reforzamos ligeramente una suposición del entorno no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, mientras que sólo aumentamos la relación de competencia en uno. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de \"diseño mecánico\" [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el \"diseño mecánico\" (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución de \"diseño mecánico\" es la compatibilidad de incentivos, que, en nuestro entorno, requiere que siempre es en cada agente el mejor interés para presentar inmediatamente su trabajo en el momento de la liberación, y para declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir los temas de incentivos a través de un ejemplo, formalizamos el \"diseño mecánico\" en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de \"diseño mecánico\". En esta sección presentamos primero la formulación del \"diseño mecánico\", y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco estándar de \"diseño mecánico\", el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el \"diseño mecánico\". Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de \"diseño mecánico\" algorítmico, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivo. Un subcampo creciente en esta área es el multicast de reparto de costos \"diseño mecánico\" (véase, por ejemplo, [1]), en el que el mecanismo debe determinar eficientemente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el \"diseño mecánico\" algorítmico distribuido, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de \"mecanismo\" algorítmico distribuido: Resultados recientes y direcciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en línea \"diseño mecánico\", EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Algorítmico \"diseño mecánico\", Games and Economic Behavior 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "máxima",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "offline",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "diseño mecánico",
                "mecanismo",
                "diseño mecánico",
                "diseño mecánico"
            ]
        },
        "game theory": {
            "translated_key": [
                "máxima",
                "offline"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el horario, sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en esta configuración en línea es que el horario debe ser construido en tiempo real, a pesar de que no se sabe nada sobre un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo programan los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un horario para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un calendario de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el horario a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión en el momento t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide el horario en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un calendario y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el horario es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento en contra de la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el calendario. De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría empeorar el horario (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la programación, ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no programa un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe programar los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "máxima",
                "offline"
            ]
        },
        "schedule": {
            "translated_key": [
                "programa",
                "programa",
                "programan",
                "programa",
                "máxima",
                "programa",
                "programa",
                "programa",
                "plazo",
                "programa",
                "programa",
                "programa",
                "offline",
                "programa",
                "programar",
                "programar"
            ],
            "translated_annotated_text": "Mechanism Design for Online Real-Time Scheduling Ryan Porter* Computer Science Department Stanford University Stanford, CA 94305 rwporter@stanford.edu RESUMEN Para el problema de la programación en línea en tiempo real de trabajos en un solo procesador, el trabajo previo presenta límites superiores e inferiores iguales en la relación competitiva que se puede lograr mediante un algoritmo determinista. Sin embargo, estos resultados sólo se aplican a la configuración no estratégica en la que los trabajos se liberan directamente al algoritmo. Motivados por áreas emergentes como la computación en red, consideramos este problema en un entorno económico, en el que cada trabajo se libera a un agente separado, interesado en sí mismo. El agente puede entonces retrasar la liberación del trabajo al algoritmo, inflar su longitud, y declarar un valor arbitrario y plazo para el trabajo, mientras que el centro determina no sólo el \"programa\", sino el pago de cada agente. Para el problema de diseño del mecanismo resultante (en el que también reforzamos ligeramente una suposición del marco no estratégico), presentamos un mecanismo que aborda cada cuestión de incentivo, al tiempo que aumentamos la relación de competencia en uno solo. Luego mostramos un límite menor para los mecanismos deterministas que nunca pagan a los agentes. Categorías y Descriptores sujetos I.2.11 [Inteligencia Artificial]: Sistemas distribuidos de inteligencia artificial-multaactivos; J.4 [Ciencias Sociales y del Comportamiento]: Economía; F.1.2 [Computación por dispositivos abstractos]: Modos de computación-computación en línea Términos generales Algoritmos, Economía, Diseño, Teoría 1. INTRODUCCIÓN Consideramos el problema de la programación en línea de los trabajos en un solo procesador. Cada trabajo se caracteriza por un tiempo de liberación, una fecha límite, un tiempo de procesamiento, y un valor para el cumplimiento exitoso de su plazo. El objetivo es maximizar la suma de los valores de los trabajos completados en sus respectivos plazos. El reto clave en este entorno en línea es que el \"programa\" debe ser construido en tiempo real, aunque no se sabe nada acerca de un trabajo hasta su tiempo de lanzamiento. El análisis competitivo [6, 10], con sus raíces en [12], es un enfoque bien estudiado para analizar algoritmos en línea comparándolos con el algoritmo offline óptimo, que tiene pleno conocimiento de la entrada al principio de su ejecución. Una interpretación de este enfoque es como un juego entre el diseñador del algoritmo en línea y un adversario. Primero, el diseñador selecciona el algoritmo en línea. Luego, el adversario observa el algoritmo y selecciona la secuencia de trabajos que maximiza la relación competitiva: la relación del valor de los trabajos completados por un algoritmo offline óptimo al valor de aquellos completados por el algoritmo en línea. Dos artículos pintan un cuadro completo en términos de análisis competitivo para este ajuste, en el que se supone que el algoritmo conoce k, la relación máxima entre las densidades de valor (valor dividido por tiempo de procesamiento) de dos trabajos. Para k = 1, [4] presenta un algoritmo de 4 competidores, y demuestra que este es un límite inferior en la relación competitiva para algoritmos deterministas. El mismo documento también generaliza el encuadernado inferior a (1 + k)2 para cualquier k ≥ 1, y [15] entonces presenta un algoritmo competitivo que coincide (1 + k)2. La configuración abordada por estos trabajos es completamente no estratégica, y se asume que el algoritmo siempre conoce las verdaderas características de cada trabajo en su lanzamiento. Sin embargo, en dominios como la computación en red (véase, por ejemplo, [7, 8)) esta suposición es inválida, porque los compradores de tiempo de procesador elegir cuándo y cómo presentar sus trabajos. Además, los vendedores no sólo \"programan\" los trabajos, sino que también determinan la cantidad que cobran a los compradores, una cuestión que no se aborda en el contexto no estratégico. Por lo tanto, consideramos una extensión del entorno en el que cada trabajo es propiedad de un agente separado, interesado en sí mismo. En lugar de ser lanzado al algoritmo, cada trabajo ahora se libera sólo a su propio agente. Cada agente tiene ahora cuatro maneras diferentes en las que puede manipular el algoritmo: decide cuándo someter el trabajo al algoritmo después del tiempo de lanzamiento verdadero, puede inflar artificialmente la duración del trabajo, y puede declarar un valor arbitrario y plazo para el trabajo. Debido a que los agentes están interesados en sí mismos, ellos elegirán manipular el algoritmo si lo hacen hará que 61 su trabajo se complete; y, de hecho, se pueden encontrar ejemplos en los que los agentes tienen incentivos para manipular los algoritmos presentados en [4] y [15]. La adición de agentes interesados mueve el problema del área de diseño de algoritmos al de diseño de mecanismos [17], la ciencia de la elaboración de protocolos para agentes interesados. En los últimos años se ha observado mucha actividad en la interfaz de la informática y el diseño de mecanismos (véase, por ejemplo, [9, 18, 19]). En general, un mecanismo define un protocolo de interacción entre los agentes y el centro que culmina con la selección de un resultado. En nuestro entorno, un mecanismo tomará como entrada un trabajo de cada agente, y devolverá un \"programa\" para los trabajos, y un pago que cada agente hará al centro. Un concepto básico de solución del diseño de mecanismos es la compatibilidad de incentivos, que, en nuestro entorno, requiere que cada agente tenga siempre el mejor interés de presentar inmediatamente su trabajo después de la liberación, y de declarar verazmente su valor, duración y plazo. Para evaluar un mecanismo mediante el análisis competitivo, debe actualizarse el modelo adversario. En el nuevo modelo, el adversario todavía determina la secuencia de los trabajos, pero son los agentes interesados los que determinan la entrada observada del mecanismo. Por lo tanto, para lograr una relación competitiva de c, un mecanismo en línea debe ser compatible con el incentivo, y siempre lograr al menos 1 c del valor que el mecanismo offline óptimo logra en la misma secuencia de trabajos. El resto del documento está estructurado de la siguiente manera. En la sección 2, definimos y examinamos formalmente los resultados del marco original no estratégico. Después de introducir las cuestiones de incentivos a través de un ejemplo, formalizamos la configuración del mecanismo en la Sección 3. En la sección 4 presentamos nuestro primer resultado principal, un mecanismo competitivo ((1 + k)2 + 1) y demostramos formalmente la compatibilidad de los incentivos y la relación de competencia. También mostramos cómo podemos simplificar este mecanismo para el caso especial en el que k = 1 y cada agente no pueden alterar la longitud de su trabajo. Volviendo a la situación general, mostramos en la Sección 5 que esta relación competitiva es un límite inferior para los mecanismos deterministas que no pagan agentes. Finalmente, en la Sección 6, discutimos trabajos relacionados distintos de los directamente relevantes [4] y [15], antes de concluir con la Sección 7. 2. En esta sección, definimos formalmente la configuración original, no estratégica, y recapitulamos los resultados anteriores. 2.1 Formulación Existe un único procesador en el que los trabajos pueden ejecutarse, y trabajos N, aunque este número no se conoce de antemano. Cada trabajo i se caracteriza por una tupla Łi = (ri, di, li, vi), que denota el tiempo de liberación, fecha límite, tiempo de procesamiento requerido, y el valor, respectivamente. El espacio de tuplas posibles es el mismo para cada trabajo y consiste en todos los Łi tales que ri, di, li, vi  (por lo tanto, el modelo de tiempo es continuo). Cada puesto de trabajo se libera en el momento ri, momento en el que se conocen sus otras tres características. No se sabe nada del trabajo antes de su llegada. Cada fecha límite es firme (o dura), lo que significa que no se obtiene valor para un trabajo que se completa después de su fecha límite. Se permite la anticipación de los puestos de trabajo, y no se necesita tiempo para cambiar de empleo. Por lo tanto, el trabajo i se completa si y sólo si el tiempo total que se ejecuta en el procesador antes de di es al menos li. Let • = (• 1,. . . , N) denotar el vector de tuplas para todos los trabajos, y dejar i = (­1,. . . , ­i−1, ­i+1,. . . , N) denotar el mismo vector sin la tupla para el trabajo i. Así, (i, i) denota un vector completo de tuplas. Definir la densidad de valor Łi = vi li de trabajo i para ser la relación de su valor a su longitud. En el caso de los datos de entrada, dedíquense las densidades de valor máximo y mínimo como La razón de importancia se define a continuación como \"máxima\" (máximo)min, la relación máxima de densidades de valor entre dos puestos de trabajo. Se supone que el algoritmo siempre conoce un límite superior k en la relación de importancia. Para la simplicidad, normalizamos el rango de densidades de valor posibles de modo que ­min = 1. Un algoritmo en línea es una función f : 1 ×. . . × N → O que mapea el vector de tuplas (para cualquier número N) a un resultado o. Un resultado o O es simplemente un \"programa\" de trabajos en el procesador, registrado por la función S : + → {0, 1,. . . , N}, que asigna cada punto en el tiempo al trabajo activo, o a 0 si el procesador está inactivo. Para denotar el tiempo total transcurrido que un trabajo ha pasado en el procesador en el tiempo t, usaremos la función ei(t) = t 0 μ(S(x) = i)dx, donde μ(·) es una función indicadora que devuelve 1 si el argumento es verdadero, y cero de lo contrario. Una laxitud de los trabajos en el momento t se define como di − t − li + ei(t), la cantidad de tiempo que puede permanecer inactivo y aún estar completado en su plazo. Un trabajo es abandonado si no puede ser completado dentro de su plazo (formalmente, si di −t+ei(t) < li). Además, sobrecargar S(·) y ei(·) para que también puedan tomar un vector فارسى como argumento. Por ejemplo, S(l, t) es taquigrafía para la S(l) del resultado f(l), y denota el trabajo activo en el momento t cuando la entrada es l. Dado que un trabajo no puede ser ejecutado antes de su tiempo de lanzamiento, el espacio de posibles resultados está restringido en que S(­, t) = i implica ri ≤ t. Además, debido a que el algoritmo en línea debe producir el \"programa\" a lo largo del tiempo, sin conocimiento de futuras entradas, debe tomar la misma decisión a la vez t para las entradas que son indistinguibles en este momento. Formalmente, deje que el subconjunto de las tuplas en el subconjunto que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas en el subconjunto de las tuplas que satisfacen ri ≤ t. La restricción es entonces que el subconjunto de las La función objetiva es la suma de los valores de los trabajos que se completan en sus respectivos plazos: W(o, Let W* (­) = maxo­O W(o, ­) denota el valor total máximo posible para el perfil ­. En el análisis competitivo, un algoritmo en línea se evalúa comparándolo con un algoritmo offline óptimo. Debido a que el algoritmo desconectado conoce la entrada completa en el tiempo 0 (pero todavía no puede iniciar cada trabajo i hasta el tiempo ri), siempre logra W* (­). Un algoritmo en línea f(·) es (estrictamente) c-competitivo si no existe una entrada Un algoritmo que es c-competitivo también se dice para lograr una relación competitiva de c. Asumimos que no existe un período de sobrecarga de duración infinita. Un período de tiempo [ts, tf ] se sobrecarga si la suma de las longitudes de los trabajos cuyo tiempo de liberación y plazo ambos caen dentro del período de tiempo excede la duración del intervalo (formalmente, si tf −ts ≤ i(ts≤ri,di≤tf ) li). Sin tal suposición, no es posible lograr una proporción competitiva finita [15]. 2.2 Resultados anteriores En el contexto no estratégico, [4] presenta un algoritmo de 4-competitividad llamado TD1 (versión 2) para el caso de k = 1, mientras que [15] presenta un algoritmo competitivo (1+  k)2 llamado Dover para el caso general de k ≥ 1. Los límites inferiores correspondientes a los algoritmos deterministas para ambos casos se mostraron en 62 [4]. En esta sección proporcionamos una descripción de alto nivel de TD1 (versión 2) usando un ejemplo. TD1 (versión 2) divide la \"programa\" en intervalos, cada uno de los cuales comienza cuando el procesador pasa de inactivo a ocupado (llame a este tiempo tb ), y termina con la finalización de un trabajo. El primer trabajo activo de un intervalo puede tener laxitud; sin embargo, para el resto del intervalo, la anticipación del trabajo activo sólo se considera cuando algún otro trabajo tiene cero laxitud. Por ejemplo, cuando la entrada es el conjunto de trabajos listados en la Tabla 1, el primer intervalo es la ejecución completa del trabajo 1 sobre el rango [0.0, 0.9]. No se considera ninguna anticipación durante este intervalo, porque el trabajo 2 tiene laxitud hasta el tiempo 1.5. Luego, un nuevo intervalo comienza en tb = 0.9 cuando el trabajo 2 se activa. Antes de que el trabajo 2 pueda terminar, la anticipación se considera en el momento 4.8, cuando el trabajo 3 se libera con cero laxitud. Para decidir si hay que adelantarse al trabajo activo, TD1 (versión 2) utiliza dos variables más: te y p pérdida. El primero registra la fecha límite más reciente de un trabajo que sería abandonado si el trabajo activo se ejecuta a la finalización (o, si no existe tal trabajo, el tiempo que el trabajo activo terminará si no se anticipa). En este caso, te = 17,0. El valor te −tb representa el límite superior de la cantidad de tiempo de ejecución posible perdido para el algoritmo offline óptimo debido a la finalización del trabajo activo. La otra variable, p pérdida, es igual a la longitud del primer trabajo activo del intervalo actual. Porque en general este trabajo podría tener laxitud, el algoritmo offline puede ser capaz de completarlo fuera del rango [tb, te ].1 Si el algoritmo completa el trabajo activo y esta longitud de trabajos es al menos te −tb +p pérdida 4, entonces el algoritmo está garantizado a ser 4-competitivo para este intervalo (note que k = 1 implica que todos los trabajos tienen la misma densidad de valor y por lo tanto Debido a que esto no es el caso en el momento 4.8 (ya que te −tb +p pérdida 4 = 17,0-0,9+4,0 4 > 4,0 = l2), el algoritmo anticipa el trabajo 2 para el trabajo 3, que luego se ejecuta hasta completar. Trabajo ri di li vi 1 0,0 0,9 0,9 0,9 2 0,5 5,5 4,0 4,0 3 4,8 17,0 12,2 12,2 01 5 17 6? ¿6? ¿6? Cuadro 1: Entrada utilizada para recapitular TD1 (versión 2) [4]. Las flechas arriba y abajo representan ri y di, respectivamente, mientras que la longitud de la caja es igual a li. 3. Sin embargo, la información falsa sobre el trabajo 2 causaría TD1 (versión 2) para completar este trabajo. Por ejemplo, si el plazo de trabajo 2s se declaró como d2 = 4.7, entonces tendría cero laxitud en el tiempo 0.7. En este momento, el algoritmo adelantaría trabajo 1 para trabajo 2, porque te −tb + p pérdida 4 = 4.7−0.0+1.0 4 > 0.9 = l1. Job 2 terminaría entonces antes de la llegada del trabajo 3.2 1 Aunque sería fácil alterar el algoritmo para reconocer que esto no es posible para los trabajos en la Tabla 1, nuestro ejemplo no depende del uso de p pérdida. 2 Aunque no vamos a describir lo mucho más complejo para abordar temas de incentivos como este, necesitamos formalizar el entorno como un problema de diseño de mecanismos. En esta sección presentamos primero la formulación del diseño del mecanismo, y luego definimos nuestros objetivos para el mecanismo. 3.1 Formulación Existe un centro, que controla el procesador, y agentes N, donde el valor de N es desconocido por el centro de antemano. Cada trabajo que tengo es propiedad de un agente separado i. Las características del trabajo definen el tipo de agentes. En el momento ri, el agente I observa privadamente su tipo de i, y no tiene información sobre el trabajo i antes de ri. Por lo tanto, los trabajos todavía se liberan con el tiempo, pero ahora cada trabajo se revela sólo al agente propietario. Los agentes interactúan con el centro a través de un mecanismo directo. . . , N, g(·)), en el que cada agente declara un trabajo, denotado por i = (ri, di, li, vi), y g : 1×. . .N → O mapea los tipos declarados a un resultado o O. Un resultado o = (S(·), p1,. . . , pN ) consiste en un \"plazo\" y un pago de cada agente al mecanismo. En un marco de diseño de mecanismos estándar, el resultado se aplica al final del mecanismo. Sin embargo, como el final no está bien definido en esta configuración en línea, optamos por modelizar la devolución del trabajo si se completa y la recaudación de un pago de cada agente i como si se produce en Ódi, que, de acuerdo con la declaración de agentes, es el último momento relevante para ese agente. Es decir, incluso si el trabajo que se ha completado antes de di, el centro no devuelve el trabajo a agente i hasta ese momento. En cambio, esta decisión de modelización podría considerarse una decisión del diseñador de mecanismos de un espacio más amplio de posibles mecanismos. De hecho, como discutiremos más adelante, esta decisión de cuándo devolver un trabajo completado es crucial para nuestro mecanismo. Cada utilidad de los agentes, ui(g(), Łi) = vi · μ(ei(, di) ≥ li) · μ( di ≤ di) − pi(), es una función cuasi lineal de su valor para su trabajo (si se completa y se devuelve dentro de su plazo real) y el pago que hace al centro. Asumimos que cada agente es un maximizador de utilidad racional y esperado. Las declaraciones de los agentes están restringidas en el sentido de que un agente no puede declarar una longitud menor que la verdadera, ya que el centro sería capaz de detectar tal mentira si el trabajo se completara. Por otro lado, en la formulación general vamos a permitir que los agentes declaren largos, ya que en algunos entornos puede ser posible añadir trabajo innecesario a un trabajo. Sin embargo, también vamos a considerar una formulación restringida en la que este tipo de mentira no es posible. El tiempo de liberación declarado ri es el tiempo que el agente elige para enviar el trabajo i al centro, y no puede preceder al tiempo ri en el que el trabajo se revela al agente. El agente puede declarar un plazo o valor arbitrario. Para resumir, el agente i puede declarar cualquier tipo i = (ri, di, li, vi) de tal manera que li ≥ li y ri ≥ ri. Mientras que en el entorno no estratégico era suficiente para el algoritmo para conocer el límite superior k en la relación Además, observamos que el límite inferior que mostraremos en la Sección 5 implica que la información falsa también puede beneficiar a un trabajo en Dover. 3 Tenga en cuenta que, a continuación, podríamos forzar declaraciones de agente para satisfacer Sin embargo, esta restricción no sería 63 Si bien creemos que es poco probable que un centro conozca k sin conocer este rango, más tarde presentamos un mecanismo que no depende de este conocimiento adicional en un entorno restringido. La restricción en el \"programa\" es ahora que S(, t) = i implica ri ≤ t, para capturar el hecho de que un trabajo no se puede programar en el procesador antes de que se declare al mecanismo. Al igual que antes, se permite la predisposición a los puestos de trabajo, y el cambio de puesto de trabajo no toma tiempo. Las limitaciones debidas a los mecanismos en línea falta de conocimiento del futuro son que (t) =  (t) implica S(, t) = S(, t), y ( di) =  ( di) implica pi() = pi( ) para cada agente i. El ajuste puede resumirse de la siguiente manera. 1Overview of the Setting: for all t do El centro presenta S(, t) ← i, for some i s.t. Se revela a agente i si, (t ≥ ri) y agente i no ha declarado un trabajo entonces Agente i puede declarar cualquier trabajo i, s.t. El objetivo de este mecanismo es maximizar el valor de los trabajos completados, con sujeción a las limitaciones de la compatibilidad de incentivos y la racionalidad individual. La condición para la compatibilidad de incentivos (estrategia dominante) es que para cada agente i, independientemente de su tipo verdadero y de los tipos declarados de todos los demás agentes, el agente no puede aumentar su utilidad cambiando unilateralmente su declaración. Definición 1. Un mecanismo directo (C) satisface la compatibilidad de incentivo (IC) si Łi, Łi, Łi, i: ui(g(l'i, i), Łi) ≥ ui(g(l'i, i) Desde una perspectiva de agente, las estrategias dominantes son deseables porque el agente no tiene que razonar sobre las estrategias de los otros agentes o la distribución de la que se Desde la perspectiva del diseñador de mecanismos, las estrategias dominantes son importantes porque podemos suponer razonablemente que un agente que tiene una estrategia dominante jugará de acuerdo con ella. Por estas razones, en este documento requerimos estrategias dominantes, a diferencia de un concepto de equilibrio más débil como Bayes-Nash, bajo el cual podríamos mejorar nuestros resultados positivos.4 disminuir el límite inferior de la relación competitiva. 4 Un posible argumento contra la necesidad de la compatibilidad de incentivos es que una mentira de agentes puede realmente mejorar el \"programa\". De hecho, este fue el caso en el ejemplo que mostramos para la declaración falsa d2 = 4.7. Sin embargo, si un agente miente debido a creencias incorrectas sobre la entrada futura, entonces la mentira podría hacer que la \"programa\" empeore (por ejemplo, si el trabajo 3 nunca fue liberado, entonces el trabajo 1 habría sido abandonado innecesariamente). Además, si no conocemos las creencias de los agentes, y por lo tanto no podemos predecir cómo mentirán, entonces ya no podemos proporcionar una garantía competitiva para nuestro mecanismo. Aunque restringirnos a los mecanismos directos compatibles con incentivos puede parecernos limitantes al principio, el Principio de Revelación para las Estrategias Dominantes (véase, por ejemplo, [17]) nos dice que si nuestra meta es la implementación de la estrategia dominante, entonces podemos hacer esta restricción sin pérdida de generalidad. La segunda meta de nuestro mecanismo, la racionalidad individual, requiere que los agentes que verdaderamente revelan su tipo nunca tengan utilidad negativa. La razón de ser de este objetivo es que se supone que la participación en el mecanismo es voluntaria. Definición 2. Un mecanismo directo (IR) satisface la racionalidad individual (IR) si......................................... Por último, la función de bienestar social que pretendemos maximizar es la misma que la función objetiva del entorno no estratégico: W(o, فارسى) = i vi · μ(ei(♥, di) ≥ li). Al igual que en el entorno no estratégico, evaluaremos un mecanismo en línea utilizando análisis competitivos para compararlo con un mecanismo offline óptimo (que denotaremos por \"offline\"). Un mecanismo offline conoce todos los tipos en el momento 0, y por lo tanto siempre puede lograr W* (­).5 Definición 3. Un mecanismo en línea es (estrictamente) competitivo si satisface IC e IR, y si no existe un perfil de los tipos de agentes es tal que c·W(g( 4. RESULTADOS En esta sección presentamos en primer lugar nuestro principal resultado positivo: un mecanismo competitivo (1+ k)2 +1 (­1). Después de proporcionar alguna intuición en cuanto a por qué â € 1 satisface la racionalidad individual y la compatibilidad de incentivos, formalmente probar primero estas dos propiedades y luego la relación competitiva. A continuación, consideramos un caso especial en el que k = 1 y los agentes no pueden mentir sobre la duración de su trabajo, lo que nos permite modificar este mecanismo para que ya no requiera ni el conocimiento de?min o la recaudación de pagos de los agentes. A diferencia de TD1 (versión 2) y Dover, â € 1 no da preferencia al trabajo activo. En su lugar, siempre ejecuta el trabajo disponible con la máxima prioridad: (vi +  k · ei(, t) min). Cada agente cuyo trabajo se completa se cobra entonces el valor más bajo que podría haber declarado de tal manera que su trabajo todavía se habría completado, manteniendo constante el resto de su declaración. Mediante la aplicación de una norma de pago similar a la de una subasta de segundo precio, el valor 1 satisface tanto el CI con respecto a los valores como el valor IR. Ahora argumentamos por qué satisface IC con respecto a las otras tres características. Declarar un trabajo mejorado (es decir, declarar un tiempo de liberación más temprano, una duración más corta, o un plazo posterior) podría posiblemente disminuir el pago de un agente. Sin embargo, las dos primeras mentiras no son posibles en nuestro entorno, mientras que la tercera causaría que el trabajo, si se completa, para ser devuelto al agente después de la fecha límite verdadera. Esta es la razón por la que es importante devolver siempre un trabajo completado en su fecha límite declarada, en lugar de en el punto en el que se completa. 5 Otra posibilidad es permitir que sólo los agentes conozcan sus tipos a la hora 0, y forzar a •offline a ser compatible con incentivos para que los agentes declaren sus tipos de manera veraz en el momento 0. Sin embargo, esto no afectaría a nuestros resultados, ya que la ejecución de un mecanismo VCG (véase, por ejemplo, [17]) en el momento 0 satisface la compatibilidad de incentivos y siempre maximiza el bienestar social. 64 Mecanismo 1 {Ejecución S(, ·) de acuerdo con Algoritmo 1 para todo lo que hago si se completa el trabajo {Agente es trabajo} entonces pi() ← arg minvi≥0(ei(((ri, di, li, vi), i), di) ≥ li) other pi() ← 0 Algorit Los únicos efectos posibles de una longitud inflada están retrasando la finalización del trabajo y haciendo que sea abandonado, y los únicos efectos posibles de un plazo antes declarado están causando que se abandone y que se devuelva antes (lo que no tiene ningún efecto en la utilidad de los agentes en nuestro entorno). Por otra parte, es menos obvio por qué los agentes no tienen incentivos para declarar un tiempo de liberación posterior. Considerar un mecanismo de 1 que se diferencia de 1 en que no se anticipa el trabajo activo i a menos que exista otro trabajo j tal que (vi +  k·li(, t)min) < vj. Nótese que, como un trabajo activo se aproxima a la finalización en 1o, su condición para los enfoques de anticipación es la de 1. Sin embargo, los tipos que figuran en el cuadro 2 para el caso de k = 1 muestran por qué un agente puede tener incentivos para retrasar la llegada de su puesto de trabajo con arreglo a la norma. El trabajo 1 se activa en el tiempo 0, y el trabajo 2 se abandona al liberarse en el tiempo 6, porque 10 + 10 = v1 +l1 > v2 = 13. Entonces, en el momento 8, el trabajo 1 es anticipado por el trabajo 3, porque 10 + 10 = v1 + l1 < v3 = 22. El trabajo 3 entonces se ejecuta hasta completarse, obligando al trabajo 1 a ser abandonado. Sin embargo, el trabajo 2 tenía más peso que el trabajo 1, y habría impedido que el trabajo 3 fuera ejecutado si hubiera sido el trabajo activo en el momento 8, ya que 13 + 13 = v2 + l2 > v3 = 22. Por lo tanto, si el agente 1 hubiera declarado falsamente r1 = 20, entonces el trabajo 3 habría sido abandonado en el momento 8, y el trabajo 1 habría completado en el rango [20, 30]. Trabajo ri di li vi 1 0 30 10 10 2 6 19 13 13 3 8 30 22 22 0 6 10 20 30 6? ¿6? ¿6? Cuadro 2: Empleos utilizados para mostrar por qué una versión ligeramente alterada de la versión 1 no sería un incentivo compatible con respecto a los tiempos de liberación. Intuitivamente, 1 evita este problema debido a dos propiedades. En primer lugar, cuando un trabajo entra en actividad, debe tener una prioridad mayor que todos los demás puestos disponibles. En segundo lugar, porque una prioridad de empleo sólo puede aumentar a través del aumento de su tiempo transcurrido, ei(, t), la tasa de aumento de una prioridad de empleo es independiente de sus características. Estas dos propiedades en conjunto implican que, si bien un trabajo está activo, no puede existir un momento en el que su prioridad sea menor que la prioridad que uno de estos otros trabajos habría logrado ejecutando en el procesador en su lugar. 4.1 Prueba de Racionalidad Individual y Compatibilidad Incentiva Después de presentar la prueba (trivial) de IR, rompemos la prueba de IC en lemas. Teorema 1. El mecanismo 1 satisface la racionalidad individual. Prueba. Para i arbitrario, i, i, si el trabajo i no se ha completado, entonces el agente i no paga nada y por lo tanto tiene una utilidad de cero; es decir, pi(i, i) = 0 y ui(g(i, i), i) = 0. Por otro lado, si el trabajo i se completa, entonces su valor debe superar el agente es el pago. Formalmente, se debe mantener ≥ 0 (ii((ri, di, li, vi), i), i) = vi − arg minvi≥0(ei(((ri, di, li, vi), i), ≥ li) ≥ 0, ya que vi = vi satisface la condición. Para probar IC, tenemos que demostrar que para un agente arbitrario i, y un perfil arbitrario i de declaraciones de los otros agentes, agente i nunca puede ganar haciendo una declaración falsa i = i, sujeto a las restricciones que ri ≥ ri y li ≥ li. Comenzamos por demostrar que, independientemente de Íñivi, si las declaraciones veraces de ri, di, y li no hacen que el trabajo i se complete, entonces las declaraciones peores de estas variables (es decir, declaraciones que satisfagan Íñiri ≥ ri, Íñili ≥ li y Íñidi ≤ di) nunca pueden hacer que el trabajo se complete. Rompimos esta parte de la prueba en dos lemas, primero mostrando que se mantiene para el tiempo de lanzamiento, independientemente de las declaraciones de las otras variables, y luego para la duración y el plazo. Lemma 2. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñi ≤ di, Íñiri ≥ ri, i ((Íñi, Íñi, Íñi, Íñi, Íñi), Íñi, Íñi, Íñi, Íñi, Íñi, Íñi Asumir por contradicción que esta condición no mantiene - es decir, trabajo i no se completa cuando ri se declara verazmente, pero se completa para alguna declaración falsa ri ≥ ri. Primero analizamos el caso en el que el tiempo de lanzamiento es declarado verazmente, y luego mostramos que el trabajo no se puede completar cuando el agente I retrasa su envío al centro. Caso I: El agente i declara i = (ri, di, li, vi). En primer lugar, definir los siguientes tres puntos en la ejecución de trabajo i. • Let ts = arg mint S((i, i), t) = i ser el tiempo que el trabajo i primero comienza la ejecución. • Let tp = arg mint>ts S((i, i), t) = i ser el tiempo que el trabajo i se anticipa primero. • Let ta = arg mint ei((i, i), t) + Ã3di − t < Ã3li ser el tiempo que el trabajo i es abandonado. 65 Si ts y tp son indefinidos porque trabajo i nunca se convierte en activo, entonces dejar ts = tp = ta. También, particionar los trabajos declarados por otros agentes antes de ta en los siguientes tres conjuntos. • X = {j(rj < tp ) (j = i)} consiste en los trabajos (distintos de i) que llegan antes de que el trabajo i se prevenga por primera vez. • Y = {j(tp ≤ rj ≤ ta )(vj > vi +  k·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen mayor prioridad que el trabajo i (obsérvese que estamos haciendo uso de la normalización). • Z = {j(tp ≤ rj ≤ ta )(vj ≤ vi + فارسى k ·ei((i, i), rj)} consiste en los trabajos que llegan en el rango [tp, ta ] y que cuando llegan tienen menor prioridad que el trabajo i. Ahora mostramos que todos los trabajos activos durante el rango (tp, ta ] debe ser i o en el conjunto Y. A menos que tp = ta (en cuyo caso esta propiedad tiene trivialmente), debe ser el caso de que el trabajo i tiene una prioridad más alta que un trabajo arbitrario x x x en el momento tp, ya que en el momento justo anterior a tp trabajo x estaba disponible y trabajo i estaba activo. Formalmente, vx +  k · ex((i, i), tp ) < vi +  k · ei((i, i), tp ) debe sostener.6 Podemos entonces demostrar que, sobre el rango [tp, ta ], ningún trabajo x  X se ejecuta en el procesador. Supongamos por contradicción que esto no es cierto. Deja que tf [tp, ta ] sea el tiempo más temprano en este rango que algún trabajo x x x es activo, lo que implica que ex((i, i), tf ) = ex(i, i), tp ). A continuación, podemos mostrar que el trabajo i tiene una prioridad más alta en el tiempo tf como sigue: k·ex((i, i), tf ) = k·ex(i, i), tp ) < vi + k · ei((i, i), tp ) ≤ vi + k · ei(i, Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € rz > tp, ya que por definición el trabajo i tiene una mayor prioridad en ese momento. Los únicos trabajos restantes que pueden estar activos en el rango (tp, ta ] son i y los del conjunto Y. Caso II: El agente i declara i = (ri, di, li, vi), donde ri > ri. Ahora mostramos que el trabajo que no se puede completar en este caso, dado que no se completó en el caso I. En primer lugar, podemos restringir el rango de ri que tenemos que considerar de la siguiente manera. Declarar ri  (ri, ts ] no afectaría a la \"programa\", ya que ts seguiría siendo la primera vez que el trabajo que ejecuta. Además, declarando que no podía hacer que el trabajo se completara, ya que di − ta < li se mantiene, lo que implica que el trabajo sería abandonado en su liberación. Por lo tanto, podemos limitar la consideración a ri  (ts, ta ]. Con el fin de declarar i para hacer que el trabajo i a ser completado, una condición necesaria es que la ejecución de algún trabajo yc Y debe cambiar durante el rango (tp, ta ], ya que los únicos trabajos distintos de i que son activos durante ese rango están en Y. Let tc = arg minté(tp,ta][yc  Y, (S((i, i), t) = yc ) (S((i, i), t) = yc )] ser la primera vez que tal cambio ocurre. Ahora vamos a mostrar que para cualquier ri  (ts, ta ], no puede existir un trabajo con mayor prioridad que yc en el momento tc, contradiciendo (S(i, i), t) = yc ). Primero note que el trabajo no puede tener una prioridad más alta, ya que tendría que existir un t (tp, tc ) de tal manera que 6 Para la simplicidad, cuando damos la condición formal para un trabajo x para tener una prioridad más alta que otro trabajo y, vamos a asumir que el trabajo xs prioridad es estrictamente mayor que el trabajo ys, porque, en el caso de un empate que favorece x, los lazos futuros también se romperían a favor Ahora considere una y arbitraria y y tal que y = yc. En el caso I, sabemos que el trabajo y tiene menor prioridad que yc en el momento tc; es decir, vy +  k·ey((i, i), tc ) < vyc +  k·eyc ((i, i), tc ). Por lo tanto, pasar al caso II, trabajo y debe reemplazar algún otro trabajo antes de tc. Puesto que la condición es que debe existir algo de t (tp, tc ) de tal manera que S((i, i), t) = y). Puesto que w Y contradiría la definición de tc, sabemos que w = i. Es decir, el trabajo que Y reemplaza debe ser i. Por definición del conjunto Y, sabemos que â € > â € € > â € € ~ k · ei((i, i), â € € ~ Â). Por lo tanto, si ry ≤ t, entonces el trabajo que no podría haber ejecutado en lugar de y en caso I. Por otro lado, si ry > t, entonces el trabajo y obviamente no podía ejecutar en el tiempo t, contradiciendo la existencia de tal tiempo t. Ahora considere un trabajo arbitrario x  X. Sabemos que en caso de que el trabajo i tiene una prioridad más alta que el trabajo x en el tiempo ts, o, formalmente, que vx + Ł k · ex((i, i), ts ) < vi + k · ei((i, i), ts ). También sabemos que vi +  k·ei((i, i), tc ) < vyc + Ł k · eyc ((i, i), tc ). Dado que el retraso es la llegada no afectará a la ejecución hasta el tiempo ts, y puesto que el trabajo x no puede ejecutar en lugar de un trabajo y â € Y en cualquier momento t â € ( tp, tc ] por definición de tc, la única manera para trabajo xs prioridad para aumentar antes de tc a medida que nos movemos de caso I a II es reemplazar trabajo i sobre el rango (ts Por lo tanto, un límite superior en el trabajo xs prioridad cuando el agente i declara i es: vx+ k· ex((i, i), ts )+ei((i, i), tc )−ei((i, i), ts ) < vi + k· ei((i, i), ts ) Por lo tanto, incluso en este límite superior, trabajo yc se ejecutaría en lugar de trabajo x en el tiempo tc. Un argumento similar se aplica a un trabajo arbitrario z â € Z, a partir de él el tiempo de liberación â € ¬ rz. Puesto que los conjuntos {i}, X, Y, Z partición el conjunto de trabajos liberados antes de ta, hemos demostrado que ningún trabajo podría ejecutar en lugar de trabajo yc, contradiciendo la existencia de tc, y completando la prueba. Lemma 3. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, Íñi, Íñi, Íñi, Íñili ≥ li, Íñidi ≤ di, ei ((ri, Íñi, Íñili, Íñi), Íñi, Íñi, Íñi, Íñili ≥ Íñili =i ((ri, di, li, Asumir por contradicción que existe alguna instanciación de las variables anteriores de tal manera que el trabajo i no se completa cuando li y di se declaran verazmente, pero se completa para algunos par de declaraciones falsas li ≥ li y di ≤ di. Nótese que el único efecto que tienen Íddi y Ídli en la ejecución del algoritmo es en si i Íd Avail o no. Específicamente, afectan a las dos condiciones: (ei(, t) < Íñi) y (ei(, t) + Ídi − t ≥ Íñi). Debido a que el trabajo i se completa cuando se declaran li y di, la primera condición (para completar) debe convertirse en falso ante el segundo. Puesto que la declaración veraz de li ≤ Íñili y di ≥ Íñi sólo hará que la primera condición se vuelva falsa antes y la última condición se vuelva falsa más tarde, la ejecución del algoritmo no se verá afectada al pasar a declaraciones veraces, y el trabajo i se completará, una contradicción. Ahora usamos estos dos lemas para mostrar que el pago por un trabajo completado sólo puede aumentar al declarar falsamente peor li, di, y ri. 66 Lemma 4. En el mecanismo ­1, la siguiente condición se aplica a todos los i, ­­i, i: ­­­«li ≥ li, ­­«di ≤ di, ­«ri ≥ ri, arg min vi≥0 ei ((­»ri, ­«di, ­«li, vi), i), ­­di ≥ ­«li ≥ arg Supongamos, por contradicción, que esta condición no es válida. Esto implica que existe algún valor vi tal que la condición (ei(((ri, di, li, vi), i) ≥ li) sostiene, pero (ei((ri, di, li, vi), i), di) ≥ li) no. Aplicando las Lemmas 2 y 3: (ei(((ri, di, li, vi), i), di) ≥ li) =[ei(((ri, di, li, vi), i), di) ≥ li] =[ei(((ri, di, li, vi), i), di) ≥ li Finalmente, el siguiente lema nos dice que la realización de un trabajo es monotónica en su valor declarado. Lemma 5. En el mecanismo de la letra a), la siguiente condición se aplica a todos los i, i, i:  vi ≥ vi, ei ((ri, di, li, vi), di ≥ li = En el caso I, el agente i declara (ri, di, li, vi) y el trabajo no se ha completado, mientras que en el caso II declara (ri, di, li, vi) y el trabajo se ha completado. El análisis de los dos casos entonces procede como antes- la ejecución no cambiará hasta el tiempo ts porque la prioridad inicial de trabajo i disminuye a medida que pasamos de caso I a II; y, como resultado, no puede haber un cambio en la ejecución de un trabajo que no sea i sobre el rango (tp, ta ]. Ahora podemos combinar los lemas para mostrar que ninguna desviación rentable es posible. Teorema 6. El Mecanismo 1 satisface la compatibilidad de los incentivos. Prueba. En el caso de un agente arbitrario i, se sabe que el término «ri» ≥ ri y el término «li» ≥ li se mantiene por suposición. También sabemos que el agente i no tiene ningún incentivo para declarar di > di, porque el trabajo que nunca sería devuelto antes de su verdadero plazo. Entonces, debido a que la función de pago no es negativa, el agente es utilidad no podría superar cero. Por IR, esta es la utilidad mínima que se lograría si se declarase verazmente i. Por lo tanto, podemos limitar la consideración a i que satisfagan ri ≥ ri, li ≥ li, y di ≤ di. Una vez más utilizando IR, podemos restringir la consideración a i que causa trabajo i a ser completado, ya que cualquier otro i produce una utilidad de cero. Si la declaración veraz de Łi causa trabajo i a ser completado, entonces por Lemma 4 cualquier tal declaración falsa i no podría disminuir el pago de agente i. Por otra parte, si la declaración veraz no hace que el trabajo i se complete, entonces declarar tal i causará que el agente i tenga utilidad negativa, ya que vi < arg minvi≥0 ei(((ri, di, li, vi), i), di) ≥ li ≤ arg minvi≥0 ei(((ri, di, li, vi 4.2 Prueba de la relación competitiva La prueba de la relación competitiva, que utiliza técnicas adaptadas a las utilizadas en [15], también se rompe en lemas. Habiendo mostrado IC, podemos asumir la declaración veraz ( = ♥). Puesto que también hemos demostrado IR, para demostrar la relación de competitividad sigue siendo para vincular la pérdida de bienestar social contra la offline. Denota por (1, 2,. . . , F) la secuencia de los trabajos completados por 1. Divida el tiempo en intervalos Si = (abrir f, tclose f ], uno para cada trabajo f en esta secuencia. Establecer tclose f como el momento en el que se completa el trabajo f, y establecer topen f = tclose f−1 para f ≥ 2, y topen 1 = 0 para f = 1. Además, deje tbegin f ser la primera vez que el procesador no está inactivo en el intervalo Si. Lemma 7. Para cualquier intervalo Si, la siguiente desigualdad se mantiene: tclose f − tbegin f ≤ (1 + 1° k ) · vf Proof. Intervalo Si comienza con un (posiblemente cero longitud) período de tiempo en el que el procesador está inactivo porque no hay trabajo disponible. Luego, ejecuta continuamente una secuencia de trabajos (1, 2,. . . , c), donde cada trabajo i en esta secuencia se anticipa por trabajo i + 1, excepto por trabajo c, que se completa (por lo tanto, trabajo c en esta secuencia es lo mismo que trabajo f es la secuencia global de trabajos completados). Deja que sea el momento en que el trabajo que comienza la ejecución. Tenga en cuenta que ts 1 = tbegin f. Sobre el rango [tbegin f, tclose f ], la prioridad (vi+ k·ei(l, t)) del trabajo activo está aumentando monótonamente con el tiempo, porque esta función aumenta linealmente mientras un trabajo está activo, y sólo puede aumentar en un punto en el tiempo cuando se produce la anticipación. Así, cada trabajo i > 1 en esta secuencia comienza la ejecución en su tiempo de lanzamiento (es decir, ts i = ri), porque su prioridad no aumenta mientras no está activo. Ahora demostramos que el valor del trabajo completado c excede el producto de k y el tiempo pasado en el intervalo en los trabajos 1 a c-1, o, más formalmente, que la siguiente condición se mantiene: vc ≥ k c−1 h=1(eh(♥, ts h+1) − eh(­, ts h)). Para demostrar esto, probaremos por inducción que la condición más fuerte vi ≥ فارسى k i−1 h=1 eh(­, ts h+1) tiene para todos los trabajos i en la secuencia. Caso base: Para i = 1, v1 ≥ Ł k 0 h=1 eh(l, ts h+1) = 0, ya que la suma es sobre cero elementos. Paso inductivo: Para un arbitrario 1 ≤ i < c, suponemos que vi ≥ En el momento ts i+1, sabemos que vi+1 ≥ vi +  k · ei(, ts i+1) sostiene, porque ts i+1 = ri+1. Estas dos desigualdades juntos implican que vi+1  k i h=1 eh(­, ts h+1), completando el paso inductivo. También sabemos que tclose f − ts c ≤ lc ≤ vc debe mantener, mediante la simplificación de la normalización de ­min = 1 y el hecho de que el tiempo de ejecución del trabajo cs no puede exceder su duración. Podemos así limitar el tiempo total de ejecución de If por: tclose f − tbegin f = (tclose f −ts c)+ c−1 h=1(eh( Ahora consideramos la posible ejecución de trabajos no completados por parte de Offline. Asociar cada trabajo i que no se ha completado por 1° con el intervalo durante el cual fue abandonado. Todos los trabajos se asocian ahora con un intervalo, ya que no hay huecos entre los intervalos, y ya que ningún trabajo puedo ser abandonado después del cierre del último intervalo en tclose F. Debido a que el procesador está inactivo después de tclose F, cualquier trabajo de este tipo se volvería activo en algún momento t ≥ tclose F, lo que llevaría a la finalización de algún trabajo, creando un nuevo intervalo y contradiciendo el hecho de que IF es el último. 67 El siguiente lema es equivalente a Lemma 5.6 de [15], pero la prueba es diferente para nuestro mecanismo. Lemma 8. Para cualquier intervalo Si y cualquier trabajo i abandonado en Si, la siguiente desigualdad se mantiene: vi ≤ (1 + k)vf. Prueba. Asumir por contradicción que existe un trabajo i abandonado en Si tal que vi > (1 + K)vf. En tclose f, la prioridad del trabajo f es vf + Ł k · lf < (1 +  k)vf. Debido a que la prioridad del trabajo activo monótonamente aumenta sobre el rango [tbegin f, tclose f ], trabajo tendría una prioridad más alta que el trabajo activo (y así comenzar la ejecución) en algún momento t â € [tbegin f, tclose f ]. Una vez más, aplicando la monotonicidad, esto implicaría que la prioridad del trabajo activo en tclose f excede (1 + k)vf, contradiciendo el hecho de que es (1 + k)vf. Al igual que en [15], para cada intervalo Si, le damos offline el siguiente regalo: k veces la cantidad de tiempo en el rango [tbegin f, tclose f ] que no \"programar\" un trabajo. Además, le damos al adversario vf, ya que el adversario puede ser capaz de completar este trabajo en algún momento futuro, debido al hecho de que •1 ignora los plazos. El siguiente lema es Lemma 5.10 en [15], y su prueba ahora se aplica directamente. Lemma 9. [15] Con los regalos anteriores la ganancia neta total obtenida por el algoritmo clarividente de la programación de los trabajos abandonados durante Si no es mayor que (1 + k) · vf. La intuición detrás de este lema es que lo mejor que el adversario puede hacer es tomar casi todo el don de k ·(tclose f −tbegin f ) (intuitivamente, esto es equivalente a la ejecución de trabajos con la densidad de valor máximo posible durante el tiempo en que •1 está activo), y luego comenzar la ejecución de un trabajo abandonado por •1 justo antes de tclose f. Por Lemma 8, el valor de este trabajo está limitado por (1 + Ł k) · vf. Ahora podemos combinar los resultados de estos lemas para demostrar la relación competitiva. Teorema 10. El mecanismo 1 es competitivo (1+ k)2+1. Prueba. Usando el hecho de que la forma en que los trabajos se asocian con las particiones intervalos todo el conjunto de trabajos, podemos mostrar la relación de competitividad mostrando que el 1 es (1+ k)2 +1 - competitivo para cada intervalo en la secuencia (1,. . . , F). En un intervalo arbitrario Si, el algoritmo offline puede lograr a lo sumo (tclose f −tbegin f )·k+vf +(1+ k)vf, a partir de los dos regalos y la ganancia neta limitada por Lemma 9. Aplicando Lemma 7, esta cantidad se delimita desde arriba por (1 + 1° k )·vf ·k+vf +(1 + k)vf = ((1 + k)2 +1)·vf. Dado que el valor de 1 m2 alcanza vf, la relación de competencia se mantiene. 4.3 Caso especial: Longitud inalterable y k=1 Aunque hasta ahora hemos permitido que cada agente mienta sobre las cuatro características de su trabajo, mentir sobre la longitud del trabajo no es posible en algunos ajustes. Por ejemplo, un usuario puede no saber cómo alterar un problema computacional de una manera que alarga el trabajo y permite que la solución del problema original se extraiga de la solución al problema alterado. Otra restricción que es natural en algunos entornos es la densidad de valor uniforme (k = 1), que fue el caso considerado por [4]. Si el ajuste cumple estas dos condiciones, entonces, mediante el Mecanismo 2 podemos lograr una relación de competencia de 5 (que es la misma relación de competencia de 1 para el caso de k = 1) sin el conocimiento de la min y sin el uso de pagos. Esta última propiedad puede ser necesaria en configuraciones que son más locales que la computación de la red (por ejemplo, dentro de un departamento) pero en las que los usuarios todavía son auto-interesados.7 Mecanismo 2 2 Ejecutar S(, ·) según Algoritmo 2 para todos los i do pi() ← 0 Algoritmo 2 para todos los t do Avail ← {i(t ≥ ri) Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 satisface la racionalidad individual y la compatibilidad de incentivo. Teorema 12. Cuando k = 1, y cada agente i no puede declarar falsamente li, Mecanismo 2 es 5-competitivo. Puesto que este mecanismo es esencialmente una simplificación de â € 1, omitimos las pruebas de estos teoremas. Básicamente, el hecho de que k = 1 y li = li ambas bodegas permite a 2 sustituir la prioridad (li +ei(, t)) por la prioridad utilizada en 1; y, puesto que se ignora vi, los pagos ya no son necesarios para garantizar la compatibilidad del incentivo. 5. MODELO COMPETITIVO Ahora mostramos que la relación de competencia de (1 + k)2 + 1 lograda por el 1 es un límite inferior para los mecanismos en línea deterministas. Para ello, apelaremos al tercer requisito sobre un mecanismo, pagos no negativos (NNP), que requiere que el centro nunca paga un agente (formalmente, Łi,, pi(i) ≥ 0). A diferencia de IC e IR, este requisito no es estándar en el diseño de mecanismos. Observamos, sin embargo, que tanto el 1 como el 2 lo satisfacen trivialmente, y que, en la prueba siguiente, cero sólo sirve como una utilidad de base para un agente, y podría ser reemplazado por cualquier función no positiva de i. La prueba del límite inferior utiliza un argumento adversario similar al utilizado en [4] para mostrar un límite inferior de (1 + k)2 en el entorno no estratégico, con la principal novedad radicada en la perturbación de la secuencia de trabajo y los argumentos de compatibilidad de incentivos relacionados. Presentamos en primer lugar un lema relativo a la repetición utilizada para este argumento, con la prueba omitida debido a las limitaciones de espacio. Lemma 13. Para cualquier k ≥ 1, para la recurrencia definida por li+1 =  · li − k · i h=1 lh y l1 = 1, donde (1 + 7 Aunque los pagos no son necesarios en este contexto, se puede cambiar el valor 2 para cobrar un pago sin afectar a la compatibilidad de los incentivos cobrando una fracción fija de li por cada trabajo que se haya completado. 68 Teorema 14. No existe un mecanismo en línea determinista que satisfaga al NNP y que logre una relación competitiva inferior a (1 + Ł k)2 + 1. Prueba. Supongamos, por contradicción, que existe un mecanismo en línea determinista que satisface el NNP y que logra una relación competitiva de c = (1 + k)2 + 1 − para algunos > 0 (y, por implicación, satisface también el CI y el IR). Dado que una relación competitiva de c implica una relación competitiva de c + x, para cualquier x > 0, suponemos sin pérdida de generalidad que < 1. Primero, vamos a construir un perfil de los tipos de agente • usando un argumento adversario. Después de posiblemente un poco de perturbación para asegurar que una propiedad de rigor está satisfecho, entonces utilizaremos una perturbación más significativa de.. para llegar a una contradicción. Ahora construimos el perfil original. Elija un α de tal manera que 0 < α <, y definir El adversario utiliza dos secuencias de trabajos: menor y mayor. Los trabajos menores i se caracterizan por li = ♥, vi = k · El primer trabajo menor se libera en el momento 0, y ri = di−1 para todos i > 1. La secuencia se detiene cada vez que Ł completa cualquier trabajo. Los trabajos importantes también tienen cero laxitud, pero tienen la menor relación de valor posible (es decir, vi = li). Las longitudes de los trabajos principales que pueden ser liberados, comenzando con i = 1, son determinadas por la siguiente relación de recurrencia. li+1 = (c − 1 + α) · li − k · i h= 1 lh l1 = 1 Los límites en α implican que (1 + Que m sea el número positivo más pequeño de tal manera que lm+k· m−1 h=1 lh lm > c−1. El primer trabajo mayor tiene un tiempo de liberación de 0, y cada trabajo mayor i > 1 tiene un tiempo de liberación de ri = di−1 − El adversario libera trabajo mayor i ≤ m si y sólo si cada trabajo mayor j < i fue ejecutado continuamente sobre el rango [ri, ri+1]. Ningún trabajo importante se libera después del trabajo m. Con el fin de lograr la relación de competencia deseada, • debe completar algún trabajo importante f, porque • offline siempre puede por lo menos completar el trabajo principal 1 (por un valor de 1), y • puede completar como mucho un trabajo menor (por un valor de α c+3 < 1 c ). Además, para que este trabajo f sea liberado, el tiempo de procesador que precede a rf sólo se puede pasar ejecutando trabajos importantes que más tarde se abandonan. Si f < m, entonces el trabajo principal f + 1 será liberado y será el trabajo principal final. No se puede completar el trabajo f + 1, porque rf + lf = df > rf+1. Por lo tanto, se compone de trabajos principales 1 a f + 1 (o, f, si f = m), más trabajos menores de tiempo 0 a tiempo df. Ahora es posible que perturbemos un poco. Por IR, sabemos que vf ≥ pf. Puesto que más tarde necesitaremos que esta desigualdad sea estricta, si vf = pf ( Por IC, el trabajo f todavía debe ser completado por el perfil (f, f). Si no, entonces por IR y NNP sabemos que pf (f, f ) = 0, y por lo tanto que uf (g(f, f ) = 0. Sin embargo, el agente f podría entonces aumentar su utilidad declarando falsamente el tipo original de Łf, recibiendo una utilidad de: uf (g(f, f ), Łf ) = vf − pf ( Además, el agente f debe cobrarse el mismo importe (es decir, pf (f, f ) = pf ()), debido a un argumento similar de compatibilidad de incentivo. Por lo tanto, para el resto de la prueba, asumir que vf > pf. Ahora usamos una perturbación más substancial de... para completar la prueba. Si f < m, a continuación, definir f a ser idéntico a f, excepto que df = df + 1 + lf, permitiendo que el trabajo f se ejecute completamente después de que el trabajo f + 1 se complete. Si f = m, en su lugar establecer df = df +lf. IC requiere que para el perfil (f, f ), todavía ejecuta trabajo f continuamente sobre el rango [rf, rf +lf ], evitando así que el trabajo f +1 se complete. Supongamos, por contradicción, que esto no era cierto. Entonces, en la fecha límite original de df, trabajo f no se ha completado. Considere el posible perfil (f, f, x), que difiere del nuevo perfil sólo en la adición de un trabajo x que tiene cero laxitud, rx = df, y vx = lx = max(df − df, (c + 1) · (lf + lf+1)). Debido a que este nuevo perfil es indistinguible de (f, f ) a  antes df tiempo, debe \"programar\" los trabajos de la misma manera hasta df. Entonces, para lograr la relación competitiva deseada, debe ejecutar el trabajo x continuamente hasta su plazo, que es por construcción al menos tan tarde como el nuevo plazo df de trabajo f. Así, el trabajo f no se completará, y, por IR y NNP, debe ser el caso de que pf (f, f, x) = 0 y uf (g(f, f, x), f) Utilizando el hecho de que فارسى es indistinguible de (f, f, x) hasta el tiempo df, si el agente f falsamente declaró su tipo para ser el original Łf, entonces su trabajo se completaría por df y se cargaría pf. Su utilidad entonces aumentaría a uf (g(f, f, Łx ) = vf − pf (فارسى) > 0, contradiciendo IC. Mientras que la ejecución debe ser idéntica para ambos (f, f ) y (f, f ), offline puede tomar ventaja del cambio. Si f < m, entonces فارسى alcanza un valor de a lo sumo Si (el valor del trabajo f si estaba perturbado), mientras que el valor de offline alcanza un valor de al menos k·( f h=1 lh −2♥)+lf+1 +lf ejecutando trabajos menores hasta rf+1, seguido por el trabajo f +1 y luego el trabajo f (sustraemos dos La proporción competitiva es, por lo menos: k·( f h=1 lh−2?)+lf+1+lf lf = k·( f h=1 lh)−2k(c−1)·lf −k·( f h=1 lh)+lf lf = c·lf +(lf −2k) lf ≥ c·lf +(ck+ TRABAJOS RELACIONADOS En esta sección describimos trabajos relacionados distintos de los dos documentos ([4] y [15]) en los que se basa este trabajo. El trabajo reciente relacionado con este dominio de programación se ha centrado en el análisis competitivo en el que el algoritmo en línea utiliza un procesador más rápido que el algoritmo offline (véase, por ejemplo, [13, 14]). El diseño del mecanismo también se aplicó a un problema de programación en [18]. En su modelo, el centro posee los trabajos en un entorno offline, y son los agentes los que pueden ejecutarlos. La información privada de un agente es el tiempo que requerirá para ejecutar cada trabajo. Se presentan varios mecanismos compatibles con incentivos que se basan en algoritmos de aproximación para el problema de optimización computacionalmente inviable. Este trabajo también lanzó el área de diseño de mecanismos algorítmicos, en el que el mecanismo debe satisfacer los requisitos computacionales, además de los requisitos estándar de incentivos. Un subcampo en crecimiento en esta área es el diseño multicast de mecanismos de participación en los costes (véase, por ejemplo, [1]), en el que el mecanismo debe determinar de manera eficiente, para cada agente en un árbol multicast, si el agente recibe la transmisión y el precio que debe pagar. Para una encuesta de este y otros temas en el diseño de mecanismos algorítmicos distribuidos, véase [9]. La ejecución en línea presenta un tipo diferente de desafío algorítmico, y varios otros artículos estudian algoritmos o mecanismos en línea en entornos económicos. Por ejemplo, [5] considera un sistema de compensación del mercado en línea, en el que el subastador coincide con las ofertas de compra y venta (que se supone que son exógenas) que llegan y expiran con el tiempo. En [2], se presenta un método general para convertir un algoritmo en línea en un mecanismo en línea que es un incentivo compatible con respecto a los valores. La declaración veraz de valores también se considera en [3] y [16], que ambos consideran subastas en línea multiunidad. La principal diferencia entre los dos es que el primero considera el caso de un bien digital, que por lo tanto tiene suministro ilimitado. Se señala en [16] que sus resultados siguen siendo válidos cuando se amplía el marco para que los ofertantes puedan retrasar su llegada. El único otro documento que conocemos que aborda la cuestión de la compatibilidad de incentivos en un sistema en tiempo real es [11], que considera varias variantes de un modelo en el que el centro asigna ancho de banda a los agentes que declaran tanto su valor como su hora de llegada. Se presenta un mecanismo de estrategia dominante IC para la variante en la que cada punto en el tiempo es esencialmente independiente, mientras que un mecanismo de Bayes-Nash IC se presenta para la variante en la que la decisión actual de los centros afecta el costo de acciones futuras. 7. CONCLUSIÓN En este artículo, consideramos un dominio de programación en línea para el cual se habían encontrado algoritmos con la mejor relación competitiva posible, pero para el cual se requerían nuevas soluciones cuando el ajuste se extiende para incluir agentes interesados. Presentamos un mecanismo que es compatible con el incentivo con respecto al tiempo de liberación, el plazo, la duración y el valor, y que sólo aumenta la relación de competencia en uno. También mostramos cómo este mecanismo podría simplificarse cuando k = 1 y cada agente no puede mentir sobre la duración de su trabajo. Luego mostramos un límite menor en la relación competitiva que se puede lograr mediante un mecanismo determinista que nunca paga a los agentes. En este contexto quedan pendientes varios problemas. Uno es determinar si el límite inferior puede reforzarse eliminando la restricción de los pagos no negativos. Además, si bien consideramos que es razonable reforzar la hipótesis de conocer la proporción máxima posible de densidades de valor (k) a conocer el rango real de densidades de valor posibles, sería interesante determinar si existe un mecanismo competitivo ((1 + k)2 + 1) bajo la hipótesis original. Por último, los mecanismos aleatorios proporcionan un área inexplorada para el trabajo futuro. 8. REFERENCIAS [1] A. Archer, J. Feigenbaum, A. Krishnamurthy, R. Sami, y S. Shenker, Aproximación y colusión en el reparto de costos multicast, Juegos y Comportamiento Económico (aparecer). [2] B. Awerbuch, Y. Azar, y A. Meyerson, Reducción de los mecanismos en línea para decir la verdad a la optimización en línea, Actas del 35o Simposio sobre la Teoría de la Computación, 2003. [3] Z. Bar-Yossef, K. Hildrum, y F. Wu, subastas en línea compatibles con incentivos para bienes digitales, Actas del 13o Simposio Anual ACM-SIAM sobre algoritmos discretos, 2002. [4] S. Baruah, G. Koren, D. Mao, B. Mishra, A. Raghunathan, L. Rosier, D. Shasha, y F. Wang, Sobre la competitividad de la programación de tareas en tiempo real en línea, Journal of Real-Time Systems 4 (1992), no. 2, 125-144. [5] A. Blum, T. Sandholm, y M. Zinkevich, Algoritmos en línea para la compensación del mercado, Actas del 13o Simposio Anual ACM-SIAM sobre Algoritmos Discretos, 2002. [6] A. Borodin y R. El-Yaniv, Computación en línea y análisis competitivo, Cambridge University Press, 1998. [7] R. Buyya, D. Abramson, J. Giddy, y H. Stockinger, Modelos económicos para la gestión de recursos y la programación en la computación de red, The Journal of Condition and Computation: Practice and Experience 14 (2002), 1507-1542. [8] N. Camiel, S. London, N. Nisan, and O. Regev, The popcorn project: Distributed computation on the internet in java, 6th International World Wide Web Conference, 1997. [9] J. Feigenbaum y S. Shenker, Diseño de mecanismos algorítmicos distribuidos: Resultados recientes y orientaciones futuras, Actas del 6o Taller Internacional sobre Algoritmos Discretos y Métodos de Computación y Comunicaciones Móviles, 2002, pp. 1-13. [10] A. Fiat y G. Woeginger (editores), Algoritmos en línea: El estado del arte, Springer Verlag, 1998. [11] E. Friedman y D. Parkes, Precios wifi en starbucksissues en el diseño de mecanismos en línea, EC03, 2003. [12] R. L. Graham, Ataduras para ciertas anomalías multiprocesador, Bell System Technical Journal 45 (1966), 1563-1581. [13] B. Kalyanasundaram y K. Pruhs, Speed es tan poderoso como la clarividencia, Journal of the ACM 47 (2000), 617-643. [14] C. Koo, T. Lam, T. Ngan, y K. To, Programación en línea con plazos estrictos, Teórica Informática 295 (2003), 251-261. [15] G. Koren y D. Shasha, D-over: Un algoritmo óptimo de programación en línea para sistemas sobrecargados en tiempo real, SIAM Journal of Computing 24 (1995), no. 2, 318-339. [16] R. Lavi y N. Nisan, Análisis competitivo de las subastas en línea, EC00, 2000. [17] A. Mas-Colell, M. Whinston, y J. Verde, teoría microeconómica, Oxford University Press, 1995. [18] N. Nisan y A. Ronen, Diseño de mecanismos algorítmicos, Juegos y Comportamiento Económico 35 (2001), 166-196. [19] C. Papadimitriou, Algoritmos, juegos e Internet, STOC, 2001, pp. 749-753. 70 ",
            "error": [
                "programa",
                "programa",
                "programan",
                "programa",
                "máxima",
                "programa",
                "programa",
                "programa",
                "plazo",
                "programa",
                "programa",
                "programa",
                "offline",
                "programa",
                "programar",
                "programar"
            ]
        }
    }
}